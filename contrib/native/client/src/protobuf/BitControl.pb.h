// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BitControl.proto

#ifndef PROTOBUF_BitControl_2eproto__INCLUDED
#define PROTOBUF_BitControl_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "ExecutionProtos.pb.h"
#include "Coordination.pb.h"
#include "UserBitShared.pb.h"
// @@protoc_insertion_point(includes)

namespace exec {
namespace bit {
namespace control {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_BitControl_2eproto();
void protobuf_AssignDesc_BitControl_2eproto();
void protobuf_ShutdownFile_BitControl_2eproto();

class BitControlHandshake;
class BitStatus;
class FragmentStatus;
class InitializeFragments;
class CustomMessage;
class PlanFragment;
class Collector;
class QueryContextInformation;
class WorkQueueStatus;
class FinishedReceiver;

enum RpcType {
  HANDSHAKE = 0,
  ACK = 1,
  GOODBYE = 2,
  REQ_INITIALIZE_FRAGMENTS = 3,
  REQ_CANCEL_FRAGMENT = 6,
  REQ_RECEIVER_FINISHED = 7,
  REQ_FRAGMENT_STATUS = 8,
  REQ_BIT_STATUS = 9,
  REQ_QUERY_STATUS = 10,
  REQ_QUERY_CANCEL = 15,
  REQ_UNPAUSE_FRAGMENT = 16,
  REQ_CUSTOM = 17,
  RESP_FRAGMENT_HANDLE = 11,
  RESP_FRAGMENT_STATUS = 12,
  RESP_BIT_STATUS = 13,
  RESP_QUERY_STATUS = 14,
  RESP_CUSTOM = 18,
  SASL_MESSAGE = 19
};
bool RpcType_IsValid(int value);
const RpcType RpcType_MIN = HANDSHAKE;
const RpcType RpcType_MAX = SASL_MESSAGE;
const int RpcType_ARRAYSIZE = RpcType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpcType_descriptor();
inline const ::std::string& RpcType_Name(RpcType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpcType_descriptor(), value);
}
inline bool RpcType_Parse(
    const ::std::string& name, RpcType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcType>(
    RpcType_descriptor(), name, value);
}
// ===================================================================

class BitControlHandshake : public ::google::protobuf::Message {
 public:
  BitControlHandshake();
  virtual ~BitControlHandshake();

  BitControlHandshake(const BitControlHandshake& from);

  inline BitControlHandshake& operator=(const BitControlHandshake& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BitControlHandshake& default_instance();

  void Swap(BitControlHandshake* other);

  // implements Message ----------------------------------------------

  BitControlHandshake* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BitControlHandshake& from);
  void MergeFrom(const BitControlHandshake& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 rpc_version = 1;
  inline bool has_rpc_version() const;
  inline void clear_rpc_version();
  static const int kRpcVersionFieldNumber = 1;
  inline ::google::protobuf::int32 rpc_version() const;
  inline void set_rpc_version(::google::protobuf::int32 value);

  // optional .exec.shared.RpcChannel channel = 2 [default = BIT_CONTROL];
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::exec::shared::RpcChannel channel() const;
  inline void set_channel(::exec::shared::RpcChannel value);

  // optional .exec.DrillbitEndpoint endpoint = 3;
  inline bool has_endpoint() const;
  inline void clear_endpoint();
  static const int kEndpointFieldNumber = 3;
  inline const ::exec::DrillbitEndpoint& endpoint() const;
  inline ::exec::DrillbitEndpoint* mutable_endpoint();
  inline ::exec::DrillbitEndpoint* release_endpoint();
  inline void set_allocated_endpoint(::exec::DrillbitEndpoint* endpoint);

  // repeated string authenticationMechanisms = 4;
  inline int authenticationmechanisms_size() const;
  inline void clear_authenticationmechanisms();
  static const int kAuthenticationMechanismsFieldNumber = 4;
  inline const ::std::string& authenticationmechanisms(int index) const;
  inline ::std::string* mutable_authenticationmechanisms(int index);
  inline void set_authenticationmechanisms(int index, const ::std::string& value);
  inline void set_authenticationmechanisms(int index, const char* value);
  inline void set_authenticationmechanisms(int index, const char* value, size_t size);
  inline ::std::string* add_authenticationmechanisms();
  inline void add_authenticationmechanisms(const ::std::string& value);
  inline void add_authenticationmechanisms(const char* value);
  inline void add_authenticationmechanisms(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& authenticationmechanisms() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_authenticationmechanisms();

  // @@protoc_insertion_point(class_scope:exec.bit.control.BitControlHandshake)
 private:
  inline void set_has_rpc_version();
  inline void clear_has_rpc_version();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_endpoint();
  inline void clear_has_endpoint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 rpc_version_;
  int channel_;
  ::exec::DrillbitEndpoint* endpoint_;
  ::google::protobuf::RepeatedPtrField< ::std::string> authenticationmechanisms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_BitControl_2eproto();
  friend void protobuf_AssignDesc_BitControl_2eproto();
  friend void protobuf_ShutdownFile_BitControl_2eproto();

  void InitAsDefaultInstance();
  static BitControlHandshake* default_instance_;
};
// -------------------------------------------------------------------

class BitStatus : public ::google::protobuf::Message {
 public:
  BitStatus();
  virtual ~BitStatus();

  BitStatus(const BitStatus& from);

  inline BitStatus& operator=(const BitStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BitStatus& default_instance();

  void Swap(BitStatus* other);

  // implements Message ----------------------------------------------

  BitStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BitStatus& from);
  void MergeFrom(const BitStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .exec.bit.control.FragmentStatus fragment_status = 1;
  inline int fragment_status_size() const;
  inline void clear_fragment_status();
  static const int kFragmentStatusFieldNumber = 1;
  inline const ::exec::bit::control::FragmentStatus& fragment_status(int index) const;
  inline ::exec::bit::control::FragmentStatus* mutable_fragment_status(int index);
  inline ::exec::bit::control::FragmentStatus* add_fragment_status();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::bit::control::FragmentStatus >&
      fragment_status() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::bit::control::FragmentStatus >*
      mutable_fragment_status();

  // @@protoc_insertion_point(class_scope:exec.bit.control.BitStatus)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::exec::bit::control::FragmentStatus > fragment_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_BitControl_2eproto();
  friend void protobuf_AssignDesc_BitControl_2eproto();
  friend void protobuf_ShutdownFile_BitControl_2eproto();

  void InitAsDefaultInstance();
  static BitStatus* default_instance_;
};
// -------------------------------------------------------------------

class FragmentStatus : public ::google::protobuf::Message {
 public:
  FragmentStatus();
  virtual ~FragmentStatus();

  FragmentStatus(const FragmentStatus& from);

  inline FragmentStatus& operator=(const FragmentStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FragmentStatus& default_instance();

  void Swap(FragmentStatus* other);

  // implements Message ----------------------------------------------

  FragmentStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FragmentStatus& from);
  void MergeFrom(const FragmentStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.shared.MinorFragmentProfile profile = 1;
  inline bool has_profile() const;
  inline void clear_profile();
  static const int kProfileFieldNumber = 1;
  inline const ::exec::shared::MinorFragmentProfile& profile() const;
  inline ::exec::shared::MinorFragmentProfile* mutable_profile();
  inline ::exec::shared::MinorFragmentProfile* release_profile();
  inline void set_allocated_profile(::exec::shared::MinorFragmentProfile* profile);

  // optional .exec.bit.FragmentHandle handle = 2;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 2;
  inline const ::exec::bit::FragmentHandle& handle() const;
  inline ::exec::bit::FragmentHandle* mutable_handle();
  inline ::exec::bit::FragmentHandle* release_handle();
  inline void set_allocated_handle(::exec::bit::FragmentHandle* handle);

  // @@protoc_insertion_point(class_scope:exec.bit.control.FragmentStatus)
 private:
  inline void set_has_profile();
  inline void clear_has_profile();
  inline void set_has_handle();
  inline void clear_has_handle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::exec::shared::MinorFragmentProfile* profile_;
  ::exec::bit::FragmentHandle* handle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BitControl_2eproto();
  friend void protobuf_AssignDesc_BitControl_2eproto();
  friend void protobuf_ShutdownFile_BitControl_2eproto();

  void InitAsDefaultInstance();
  static FragmentStatus* default_instance_;
};
// -------------------------------------------------------------------

class InitializeFragments : public ::google::protobuf::Message {
 public:
  InitializeFragments();
  virtual ~InitializeFragments();

  InitializeFragments(const InitializeFragments& from);

  inline InitializeFragments& operator=(const InitializeFragments& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitializeFragments& default_instance();

  void Swap(InitializeFragments* other);

  // implements Message ----------------------------------------------

  InitializeFragments* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitializeFragments& from);
  void MergeFrom(const InitializeFragments& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .exec.bit.control.PlanFragment fragment = 1;
  inline int fragment_size() const;
  inline void clear_fragment();
  static const int kFragmentFieldNumber = 1;
  inline const ::exec::bit::control::PlanFragment& fragment(int index) const;
  inline ::exec::bit::control::PlanFragment* mutable_fragment(int index);
  inline ::exec::bit::control::PlanFragment* add_fragment();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment >&
      fragment() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment >*
      mutable_fragment();

  // @@protoc_insertion_point(class_scope:exec.bit.control.InitializeFragments)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment > fragment_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_BitControl_2eproto();
  friend void protobuf_AssignDesc_BitControl_2eproto();
  friend void protobuf_ShutdownFile_BitControl_2eproto();

  void InitAsDefaultInstance();
  static InitializeFragments* default_instance_;
};
// -------------------------------------------------------------------

class CustomMessage : public ::google::protobuf::Message {
 public:
  CustomMessage();
  virtual ~CustomMessage();

  CustomMessage(const CustomMessage& from);

  inline CustomMessage& operator=(const CustomMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CustomMessage& default_instance();

  void Swap(CustomMessage* other);

  // implements Message ----------------------------------------------

  CustomMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CustomMessage& from);
  void MergeFrom(const CustomMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional bytes message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:exec.bit.control.CustomMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BitControl_2eproto();
  friend void protobuf_AssignDesc_BitControl_2eproto();
  friend void protobuf_ShutdownFile_BitControl_2eproto();

  void InitAsDefaultInstance();
  static CustomMessage* default_instance_;
};
// -------------------------------------------------------------------

class PlanFragment : public ::google::protobuf::Message {
 public:
  PlanFragment();
  virtual ~PlanFragment();

  PlanFragment(const PlanFragment& from);

  inline PlanFragment& operator=(const PlanFragment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlanFragment& default_instance();

  void Swap(PlanFragment* other);

  // implements Message ----------------------------------------------

  PlanFragment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlanFragment& from);
  void MergeFrom(const PlanFragment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.bit.FragmentHandle handle = 1;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 1;
  inline const ::exec::bit::FragmentHandle& handle() const;
  inline ::exec::bit::FragmentHandle* mutable_handle();
  inline ::exec::bit::FragmentHandle* release_handle();
  inline void set_allocated_handle(::exec::bit::FragmentHandle* handle);

  // optional float network_cost = 4;
  inline bool has_network_cost() const;
  inline void clear_network_cost();
  static const int kNetworkCostFieldNumber = 4;
  inline float network_cost() const;
  inline void set_network_cost(float value);

  // optional float cpu_cost = 5;
  inline bool has_cpu_cost() const;
  inline void clear_cpu_cost();
  static const int kCpuCostFieldNumber = 5;
  inline float cpu_cost() const;
  inline void set_cpu_cost(float value);

  // optional float disk_cost = 6;
  inline bool has_disk_cost() const;
  inline void clear_disk_cost();
  static const int kDiskCostFieldNumber = 6;
  inline float disk_cost() const;
  inline void set_disk_cost(float value);

  // optional float memory_cost = 7;
  inline bool has_memory_cost() const;
  inline void clear_memory_cost();
  static const int kMemoryCostFieldNumber = 7;
  inline float memory_cost() const;
  inline void set_memory_cost(float value);

  // optional string fragment_json = 8;
  inline bool has_fragment_json() const;
  inline void clear_fragment_json();
  static const int kFragmentJsonFieldNumber = 8;
  inline const ::std::string& fragment_json() const;
  inline void set_fragment_json(const ::std::string& value);
  inline void set_fragment_json(const char* value);
  inline void set_fragment_json(const char* value, size_t size);
  inline ::std::string* mutable_fragment_json();
  inline ::std::string* release_fragment_json();
  inline void set_allocated_fragment_json(::std::string* fragment_json);

  // optional bool leaf_fragment = 9;
  inline bool has_leaf_fragment() const;
  inline void clear_leaf_fragment();
  static const int kLeafFragmentFieldNumber = 9;
  inline bool leaf_fragment() const;
  inline void set_leaf_fragment(bool value);

  // optional .exec.DrillbitEndpoint assignment = 10;
  inline bool has_assignment() const;
  inline void clear_assignment();
  static const int kAssignmentFieldNumber = 10;
  inline const ::exec::DrillbitEndpoint& assignment() const;
  inline ::exec::DrillbitEndpoint* mutable_assignment();
  inline ::exec::DrillbitEndpoint* release_assignment();
  inline void set_allocated_assignment(::exec::DrillbitEndpoint* assignment);

  // optional .exec.DrillbitEndpoint foreman = 11;
  inline bool has_foreman() const;
  inline void clear_foreman();
  static const int kForemanFieldNumber = 11;
  inline const ::exec::DrillbitEndpoint& foreman() const;
  inline ::exec::DrillbitEndpoint* mutable_foreman();
  inline ::exec::DrillbitEndpoint* release_foreman();
  inline void set_allocated_foreman(::exec::DrillbitEndpoint* foreman);

  // optional int64 mem_initial = 12 [default = 20000000];
  inline bool has_mem_initial() const;
  inline void clear_mem_initial();
  static const int kMemInitialFieldNumber = 12;
  inline ::google::protobuf::int64 mem_initial() const;
  inline void set_mem_initial(::google::protobuf::int64 value);

  // optional int64 mem_max = 13 [default = 2000000000];
  inline bool has_mem_max() const;
  inline void clear_mem_max();
  static const int kMemMaxFieldNumber = 13;
  inline ::google::protobuf::int64 mem_max() const;
  inline void set_mem_max(::google::protobuf::int64 value);

  // optional .exec.shared.UserCredentials credentials = 14;
  inline bool has_credentials() const;
  inline void clear_credentials();
  static const int kCredentialsFieldNumber = 14;
  inline const ::exec::shared::UserCredentials& credentials() const;
  inline ::exec::shared::UserCredentials* mutable_credentials();
  inline ::exec::shared::UserCredentials* release_credentials();
  inline void set_allocated_credentials(::exec::shared::UserCredentials* credentials);

  // optional string options_json = 15;
  inline bool has_options_json() const;
  inline void clear_options_json();
  static const int kOptionsJsonFieldNumber = 15;
  inline const ::std::string& options_json() const;
  inline void set_options_json(const ::std::string& value);
  inline void set_options_json(const char* value);
  inline void set_options_json(const char* value, size_t size);
  inline ::std::string* mutable_options_json();
  inline ::std::string* release_options_json();
  inline void set_allocated_options_json(::std::string* options_json);

  // optional .exec.bit.control.QueryContextInformation context = 16;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 16;
  inline const ::exec::bit::control::QueryContextInformation& context() const;
  inline ::exec::bit::control::QueryContextInformation* mutable_context();
  inline ::exec::bit::control::QueryContextInformation* release_context();
  inline void set_allocated_context(::exec::bit::control::QueryContextInformation* context);

  // repeated .exec.bit.control.Collector collector = 17;
  inline int collector_size() const;
  inline void clear_collector();
  static const int kCollectorFieldNumber = 17;
  inline const ::exec::bit::control::Collector& collector(int index) const;
  inline ::exec::bit::control::Collector* mutable_collector(int index);
  inline ::exec::bit::control::Collector* add_collector();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::bit::control::Collector >&
      collector() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::bit::control::Collector >*
      mutable_collector();

  // @@protoc_insertion_point(class_scope:exec.bit.control.PlanFragment)
 private:
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_network_cost();
  inline void clear_has_network_cost();
  inline void set_has_cpu_cost();
  inline void clear_has_cpu_cost();
  inline void set_has_disk_cost();
  inline void clear_has_disk_cost();
  inline void set_has_memory_cost();
  inline void clear_has_memory_cost();
  inline void set_has_fragment_json();
  inline void clear_has_fragment_json();
  inline void set_has_leaf_fragment();
  inline void clear_has_leaf_fragment();
  inline void set_has_assignment();
  inline void clear_has_assignment();
  inline void set_has_foreman();
  inline void clear_has_foreman();
  inline void set_has_mem_initial();
  inline void clear_has_mem_initial();
  inline void set_has_mem_max();
  inline void clear_has_mem_max();
  inline void set_has_credentials();
  inline void clear_has_credentials();
  inline void set_has_options_json();
  inline void clear_has_options_json();
  inline void set_has_context();
  inline void clear_has_context();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::exec::bit::FragmentHandle* handle_;
  float network_cost_;
  float cpu_cost_;
  float disk_cost_;
  float memory_cost_;
  ::std::string* fragment_json_;
  ::exec::DrillbitEndpoint* assignment_;
  ::exec::DrillbitEndpoint* foreman_;
  ::google::protobuf::int64 mem_initial_;
  ::google::protobuf::int64 mem_max_;
  ::exec::shared::UserCredentials* credentials_;
  ::std::string* options_json_;
  ::exec::bit::control::QueryContextInformation* context_;
  ::google::protobuf::RepeatedPtrField< ::exec::bit::control::Collector > collector_;
  bool leaf_fragment_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_BitControl_2eproto();
  friend void protobuf_AssignDesc_BitControl_2eproto();
  friend void protobuf_ShutdownFile_BitControl_2eproto();

  void InitAsDefaultInstance();
  static PlanFragment* default_instance_;
};
// -------------------------------------------------------------------

class Collector : public ::google::protobuf::Message {
 public:
  Collector();
  virtual ~Collector();

  Collector(const Collector& from);

  inline Collector& operator=(const Collector& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Collector& default_instance();

  void Swap(Collector* other);

  // implements Message ----------------------------------------------

  Collector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Collector& from);
  void MergeFrom(const Collector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 opposite_major_fragment_id = 1;
  inline bool has_opposite_major_fragment_id() const;
  inline void clear_opposite_major_fragment_id();
  static const int kOppositeMajorFragmentIdFieldNumber = 1;
  inline ::google::protobuf::int32 opposite_major_fragment_id() const;
  inline void set_opposite_major_fragment_id(::google::protobuf::int32 value);

  // repeated int32 incoming_minor_fragment = 2 [packed = true];
  inline int incoming_minor_fragment_size() const;
  inline void clear_incoming_minor_fragment();
  static const int kIncomingMinorFragmentFieldNumber = 2;
  inline ::google::protobuf::int32 incoming_minor_fragment(int index) const;
  inline void set_incoming_minor_fragment(int index, ::google::protobuf::int32 value);
  inline void add_incoming_minor_fragment(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      incoming_minor_fragment() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_incoming_minor_fragment();

  // optional bool supports_out_of_order = 3;
  inline bool has_supports_out_of_order() const;
  inline void clear_supports_out_of_order();
  static const int kSupportsOutOfOrderFieldNumber = 3;
  inline bool supports_out_of_order() const;
  inline void set_supports_out_of_order(bool value);

  // optional bool is_spooling = 4;
  inline bool has_is_spooling() const;
  inline void clear_is_spooling();
  static const int kIsSpoolingFieldNumber = 4;
  inline bool is_spooling() const;
  inline void set_is_spooling(bool value);

  // @@protoc_insertion_point(class_scope:exec.bit.control.Collector)
 private:
  inline void set_has_opposite_major_fragment_id();
  inline void clear_has_opposite_major_fragment_id();
  inline void set_has_supports_out_of_order();
  inline void clear_has_supports_out_of_order();
  inline void set_has_is_spooling();
  inline void clear_has_is_spooling();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > incoming_minor_fragment_;
  mutable int _incoming_minor_fragment_cached_byte_size_;
  ::google::protobuf::int32 opposite_major_fragment_id_;
  bool supports_out_of_order_;
  bool is_spooling_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_BitControl_2eproto();
  friend void protobuf_AssignDesc_BitControl_2eproto();
  friend void protobuf_ShutdownFile_BitControl_2eproto();

  void InitAsDefaultInstance();
  static Collector* default_instance_;
};
// -------------------------------------------------------------------

class QueryContextInformation : public ::google::protobuf::Message {
 public:
  QueryContextInformation();
  virtual ~QueryContextInformation();

  QueryContextInformation(const QueryContextInformation& from);

  inline QueryContextInformation& operator=(const QueryContextInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryContextInformation& default_instance();

  void Swap(QueryContextInformation* other);

  // implements Message ----------------------------------------------

  QueryContextInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryContextInformation& from);
  void MergeFrom(const QueryContextInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 query_start_time = 1;
  inline bool has_query_start_time() const;
  inline void clear_query_start_time();
  static const int kQueryStartTimeFieldNumber = 1;
  inline ::google::protobuf::int64 query_start_time() const;
  inline void set_query_start_time(::google::protobuf::int64 value);

  // optional int32 time_zone = 2;
  inline bool has_time_zone() const;
  inline void clear_time_zone();
  static const int kTimeZoneFieldNumber = 2;
  inline ::google::protobuf::int32 time_zone() const;
  inline void set_time_zone(::google::protobuf::int32 value);

  // optional string default_schema_name = 3;
  inline bool has_default_schema_name() const;
  inline void clear_default_schema_name();
  static const int kDefaultSchemaNameFieldNumber = 3;
  inline const ::std::string& default_schema_name() const;
  inline void set_default_schema_name(const ::std::string& value);
  inline void set_default_schema_name(const char* value);
  inline void set_default_schema_name(const char* value, size_t size);
  inline ::std::string* mutable_default_schema_name();
  inline ::std::string* release_default_schema_name();
  inline void set_allocated_default_schema_name(::std::string* default_schema_name);

  // optional string session_id = 4;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 4;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  inline void set_allocated_session_id(::std::string* session_id);

  // @@protoc_insertion_point(class_scope:exec.bit.control.QueryContextInformation)
 private:
  inline void set_has_query_start_time();
  inline void clear_has_query_start_time();
  inline void set_has_time_zone();
  inline void clear_has_time_zone();
  inline void set_has_default_schema_name();
  inline void clear_has_default_schema_name();
  inline void set_has_session_id();
  inline void clear_has_session_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 query_start_time_;
  ::std::string* default_schema_name_;
  ::std::string* session_id_;
  ::google::protobuf::int32 time_zone_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_BitControl_2eproto();
  friend void protobuf_AssignDesc_BitControl_2eproto();
  friend void protobuf_ShutdownFile_BitControl_2eproto();

  void InitAsDefaultInstance();
  static QueryContextInformation* default_instance_;
};
// -------------------------------------------------------------------

class WorkQueueStatus : public ::google::protobuf::Message {
 public:
  WorkQueueStatus();
  virtual ~WorkQueueStatus();

  WorkQueueStatus(const WorkQueueStatus& from);

  inline WorkQueueStatus& operator=(const WorkQueueStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WorkQueueStatus& default_instance();

  void Swap(WorkQueueStatus* other);

  // implements Message ----------------------------------------------

  WorkQueueStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WorkQueueStatus& from);
  void MergeFrom(const WorkQueueStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.DrillbitEndpoint endpoint = 1;
  inline bool has_endpoint() const;
  inline void clear_endpoint();
  static const int kEndpointFieldNumber = 1;
  inline const ::exec::DrillbitEndpoint& endpoint() const;
  inline ::exec::DrillbitEndpoint* mutable_endpoint();
  inline ::exec::DrillbitEndpoint* release_endpoint();
  inline void set_allocated_endpoint(::exec::DrillbitEndpoint* endpoint);

  // optional int32 queue_length = 2;
  inline bool has_queue_length() const;
  inline void clear_queue_length();
  static const int kQueueLengthFieldNumber = 2;
  inline ::google::protobuf::int32 queue_length() const;
  inline void set_queue_length(::google::protobuf::int32 value);

  // optional int64 report_time = 3;
  inline bool has_report_time() const;
  inline void clear_report_time();
  static const int kReportTimeFieldNumber = 3;
  inline ::google::protobuf::int64 report_time() const;
  inline void set_report_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:exec.bit.control.WorkQueueStatus)
 private:
  inline void set_has_endpoint();
  inline void clear_has_endpoint();
  inline void set_has_queue_length();
  inline void clear_has_queue_length();
  inline void set_has_report_time();
  inline void clear_has_report_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::exec::DrillbitEndpoint* endpoint_;
  ::google::protobuf::int64 report_time_;
  ::google::protobuf::int32 queue_length_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_BitControl_2eproto();
  friend void protobuf_AssignDesc_BitControl_2eproto();
  friend void protobuf_ShutdownFile_BitControl_2eproto();

  void InitAsDefaultInstance();
  static WorkQueueStatus* default_instance_;
};
// -------------------------------------------------------------------

class FinishedReceiver : public ::google::protobuf::Message {
 public:
  FinishedReceiver();
  virtual ~FinishedReceiver();

  FinishedReceiver(const FinishedReceiver& from);

  inline FinishedReceiver& operator=(const FinishedReceiver& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FinishedReceiver& default_instance();

  void Swap(FinishedReceiver* other);

  // implements Message ----------------------------------------------

  FinishedReceiver* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FinishedReceiver& from);
  void MergeFrom(const FinishedReceiver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.bit.FragmentHandle receiver = 1;
  inline bool has_receiver() const;
  inline void clear_receiver();
  static const int kReceiverFieldNumber = 1;
  inline const ::exec::bit::FragmentHandle& receiver() const;
  inline ::exec::bit::FragmentHandle* mutable_receiver();
  inline ::exec::bit::FragmentHandle* release_receiver();
  inline void set_allocated_receiver(::exec::bit::FragmentHandle* receiver);

  // optional .exec.bit.FragmentHandle sender = 2;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 2;
  inline const ::exec::bit::FragmentHandle& sender() const;
  inline ::exec::bit::FragmentHandle* mutable_sender();
  inline ::exec::bit::FragmentHandle* release_sender();
  inline void set_allocated_sender(::exec::bit::FragmentHandle* sender);

  // @@protoc_insertion_point(class_scope:exec.bit.control.FinishedReceiver)
 private:
  inline void set_has_receiver();
  inline void clear_has_receiver();
  inline void set_has_sender();
  inline void clear_has_sender();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::exec::bit::FragmentHandle* receiver_;
  ::exec::bit::FragmentHandle* sender_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BitControl_2eproto();
  friend void protobuf_AssignDesc_BitControl_2eproto();
  friend void protobuf_ShutdownFile_BitControl_2eproto();

  void InitAsDefaultInstance();
  static FinishedReceiver* default_instance_;
};
// ===================================================================


// ===================================================================

// BitControlHandshake

// optional int32 rpc_version = 1;
inline bool BitControlHandshake::has_rpc_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BitControlHandshake::set_has_rpc_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BitControlHandshake::clear_has_rpc_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BitControlHandshake::clear_rpc_version() {
  rpc_version_ = 0;
  clear_has_rpc_version();
}
inline ::google::protobuf::int32 BitControlHandshake::rpc_version() const {
  return rpc_version_;
}
inline void BitControlHandshake::set_rpc_version(::google::protobuf::int32 value) {
  set_has_rpc_version();
  rpc_version_ = value;
}

// optional .exec.shared.RpcChannel channel = 2 [default = BIT_CONTROL];
inline bool BitControlHandshake::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BitControlHandshake::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BitControlHandshake::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BitControlHandshake::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::exec::shared::RpcChannel BitControlHandshake::channel() const {
  return static_cast< ::exec::shared::RpcChannel >(channel_);
}
inline void BitControlHandshake::set_channel(::exec::shared::RpcChannel value) {
  assert(::exec::shared::RpcChannel_IsValid(value));
  set_has_channel();
  channel_ = value;
}

// optional .exec.DrillbitEndpoint endpoint = 3;
inline bool BitControlHandshake::has_endpoint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BitControlHandshake::set_has_endpoint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BitControlHandshake::clear_has_endpoint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BitControlHandshake::clear_endpoint() {
  if (endpoint_ != NULL) endpoint_->::exec::DrillbitEndpoint::Clear();
  clear_has_endpoint();
}
inline const ::exec::DrillbitEndpoint& BitControlHandshake::endpoint() const {
  return endpoint_ != NULL ? *endpoint_ : *default_instance_->endpoint_;
}
inline ::exec::DrillbitEndpoint* BitControlHandshake::mutable_endpoint() {
  set_has_endpoint();
  if (endpoint_ == NULL) endpoint_ = new ::exec::DrillbitEndpoint;
  return endpoint_;
}
inline ::exec::DrillbitEndpoint* BitControlHandshake::release_endpoint() {
  clear_has_endpoint();
  ::exec::DrillbitEndpoint* temp = endpoint_;
  endpoint_ = NULL;
  return temp;
}
inline void BitControlHandshake::set_allocated_endpoint(::exec::DrillbitEndpoint* endpoint) {
  delete endpoint_;
  endpoint_ = endpoint;
  if (endpoint) {
    set_has_endpoint();
  } else {
    clear_has_endpoint();
  }
}

// repeated string authenticationMechanisms = 4;
inline int BitControlHandshake::authenticationmechanisms_size() const {
  return authenticationmechanisms_.size();
}
inline void BitControlHandshake::clear_authenticationmechanisms() {
  authenticationmechanisms_.Clear();
}
inline const ::std::string& BitControlHandshake::authenticationmechanisms(int index) const {
  return authenticationmechanisms_.Get(index);
}
inline ::std::string* BitControlHandshake::mutable_authenticationmechanisms(int index) {
  return authenticationmechanisms_.Mutable(index);
}
inline void BitControlHandshake::set_authenticationmechanisms(int index, const ::std::string& value) {
  authenticationmechanisms_.Mutable(index)->assign(value);
}
inline void BitControlHandshake::set_authenticationmechanisms(int index, const char* value) {
  authenticationmechanisms_.Mutable(index)->assign(value);
}
inline void BitControlHandshake::set_authenticationmechanisms(int index, const char* value, size_t size) {
  authenticationmechanisms_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BitControlHandshake::add_authenticationmechanisms() {
  return authenticationmechanisms_.Add();
}
inline void BitControlHandshake::add_authenticationmechanisms(const ::std::string& value) {
  authenticationmechanisms_.Add()->assign(value);
}
inline void BitControlHandshake::add_authenticationmechanisms(const char* value) {
  authenticationmechanisms_.Add()->assign(value);
}
inline void BitControlHandshake::add_authenticationmechanisms(const char* value, size_t size) {
  authenticationmechanisms_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BitControlHandshake::authenticationmechanisms() const {
  return authenticationmechanisms_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BitControlHandshake::mutable_authenticationmechanisms() {
  return &authenticationmechanisms_;
}

// -------------------------------------------------------------------

// BitStatus

// repeated .exec.bit.control.FragmentStatus fragment_status = 1;
inline int BitStatus::fragment_status_size() const {
  return fragment_status_.size();
}
inline void BitStatus::clear_fragment_status() {
  fragment_status_.Clear();
}
inline const ::exec::bit::control::FragmentStatus& BitStatus::fragment_status(int index) const {
  return fragment_status_.Get(index);
}
inline ::exec::bit::control::FragmentStatus* BitStatus::mutable_fragment_status(int index) {
  return fragment_status_.Mutable(index);
}
inline ::exec::bit::control::FragmentStatus* BitStatus::add_fragment_status() {
  return fragment_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::bit::control::FragmentStatus >&
BitStatus::fragment_status() const {
  return fragment_status_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::bit::control::FragmentStatus >*
BitStatus::mutable_fragment_status() {
  return &fragment_status_;
}

// -------------------------------------------------------------------

// FragmentStatus

// optional .exec.shared.MinorFragmentProfile profile = 1;
inline bool FragmentStatus::has_profile() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FragmentStatus::set_has_profile() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FragmentStatus::clear_has_profile() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FragmentStatus::clear_profile() {
  if (profile_ != NULL) profile_->::exec::shared::MinorFragmentProfile::Clear();
  clear_has_profile();
}
inline const ::exec::shared::MinorFragmentProfile& FragmentStatus::profile() const {
  return profile_ != NULL ? *profile_ : *default_instance_->profile_;
}
inline ::exec::shared::MinorFragmentProfile* FragmentStatus::mutable_profile() {
  set_has_profile();
  if (profile_ == NULL) profile_ = new ::exec::shared::MinorFragmentProfile;
  return profile_;
}
inline ::exec::shared::MinorFragmentProfile* FragmentStatus::release_profile() {
  clear_has_profile();
  ::exec::shared::MinorFragmentProfile* temp = profile_;
  profile_ = NULL;
  return temp;
}
inline void FragmentStatus::set_allocated_profile(::exec::shared::MinorFragmentProfile* profile) {
  delete profile_;
  profile_ = profile;
  if (profile) {
    set_has_profile();
  } else {
    clear_has_profile();
  }
}

// optional .exec.bit.FragmentHandle handle = 2;
inline bool FragmentStatus::has_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FragmentStatus::set_has_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FragmentStatus::clear_has_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FragmentStatus::clear_handle() {
  if (handle_ != NULL) handle_->::exec::bit::FragmentHandle::Clear();
  clear_has_handle();
}
inline const ::exec::bit::FragmentHandle& FragmentStatus::handle() const {
  return handle_ != NULL ? *handle_ : *default_instance_->handle_;
}
inline ::exec::bit::FragmentHandle* FragmentStatus::mutable_handle() {
  set_has_handle();
  if (handle_ == NULL) handle_ = new ::exec::bit::FragmentHandle;
  return handle_;
}
inline ::exec::bit::FragmentHandle* FragmentStatus::release_handle() {
  clear_has_handle();
  ::exec::bit::FragmentHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline void FragmentStatus::set_allocated_handle(::exec::bit::FragmentHandle* handle) {
  delete handle_;
  handle_ = handle;
  if (handle) {
    set_has_handle();
  } else {
    clear_has_handle();
  }
}

// -------------------------------------------------------------------

// InitializeFragments

// repeated .exec.bit.control.PlanFragment fragment = 1;
inline int InitializeFragments::fragment_size() const {
  return fragment_.size();
}
inline void InitializeFragments::clear_fragment() {
  fragment_.Clear();
}
inline const ::exec::bit::control::PlanFragment& InitializeFragments::fragment(int index) const {
  return fragment_.Get(index);
}
inline ::exec::bit::control::PlanFragment* InitializeFragments::mutable_fragment(int index) {
  return fragment_.Mutable(index);
}
inline ::exec::bit::control::PlanFragment* InitializeFragments::add_fragment() {
  return fragment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment >&
InitializeFragments::fragment() const {
  return fragment_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment >*
InitializeFragments::mutable_fragment() {
  return &fragment_;
}

// -------------------------------------------------------------------

// CustomMessage

// optional int32 type = 1;
inline bool CustomMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CustomMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CustomMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CustomMessage::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 CustomMessage::type() const {
  return type_;
}
inline void CustomMessage::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional bytes message = 2;
inline bool CustomMessage::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CustomMessage::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CustomMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CustomMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& CustomMessage::message() const {
  return *message_;
}
inline void CustomMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void CustomMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void CustomMessage::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CustomMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* CustomMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CustomMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PlanFragment

// optional .exec.bit.FragmentHandle handle = 1;
inline bool PlanFragment::has_handle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanFragment::set_has_handle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanFragment::clear_has_handle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanFragment::clear_handle() {
  if (handle_ != NULL) handle_->::exec::bit::FragmentHandle::Clear();
  clear_has_handle();
}
inline const ::exec::bit::FragmentHandle& PlanFragment::handle() const {
  return handle_ != NULL ? *handle_ : *default_instance_->handle_;
}
inline ::exec::bit::FragmentHandle* PlanFragment::mutable_handle() {
  set_has_handle();
  if (handle_ == NULL) handle_ = new ::exec::bit::FragmentHandle;
  return handle_;
}
inline ::exec::bit::FragmentHandle* PlanFragment::release_handle() {
  clear_has_handle();
  ::exec::bit::FragmentHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline void PlanFragment::set_allocated_handle(::exec::bit::FragmentHandle* handle) {
  delete handle_;
  handle_ = handle;
  if (handle) {
    set_has_handle();
  } else {
    clear_has_handle();
  }
}

// optional float network_cost = 4;
inline bool PlanFragment::has_network_cost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanFragment::set_has_network_cost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanFragment::clear_has_network_cost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanFragment::clear_network_cost() {
  network_cost_ = 0;
  clear_has_network_cost();
}
inline float PlanFragment::network_cost() const {
  return network_cost_;
}
inline void PlanFragment::set_network_cost(float value) {
  set_has_network_cost();
  network_cost_ = value;
}

// optional float cpu_cost = 5;
inline bool PlanFragment::has_cpu_cost() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlanFragment::set_has_cpu_cost() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlanFragment::clear_has_cpu_cost() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlanFragment::clear_cpu_cost() {
  cpu_cost_ = 0;
  clear_has_cpu_cost();
}
inline float PlanFragment::cpu_cost() const {
  return cpu_cost_;
}
inline void PlanFragment::set_cpu_cost(float value) {
  set_has_cpu_cost();
  cpu_cost_ = value;
}

// optional float disk_cost = 6;
inline bool PlanFragment::has_disk_cost() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlanFragment::set_has_disk_cost() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlanFragment::clear_has_disk_cost() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlanFragment::clear_disk_cost() {
  disk_cost_ = 0;
  clear_has_disk_cost();
}
inline float PlanFragment::disk_cost() const {
  return disk_cost_;
}
inline void PlanFragment::set_disk_cost(float value) {
  set_has_disk_cost();
  disk_cost_ = value;
}

// optional float memory_cost = 7;
inline bool PlanFragment::has_memory_cost() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlanFragment::set_has_memory_cost() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlanFragment::clear_has_memory_cost() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlanFragment::clear_memory_cost() {
  memory_cost_ = 0;
  clear_has_memory_cost();
}
inline float PlanFragment::memory_cost() const {
  return memory_cost_;
}
inline void PlanFragment::set_memory_cost(float value) {
  set_has_memory_cost();
  memory_cost_ = value;
}

// optional string fragment_json = 8;
inline bool PlanFragment::has_fragment_json() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlanFragment::set_has_fragment_json() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlanFragment::clear_has_fragment_json() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlanFragment::clear_fragment_json() {
  if (fragment_json_ != &::google::protobuf::internal::kEmptyString) {
    fragment_json_->clear();
  }
  clear_has_fragment_json();
}
inline const ::std::string& PlanFragment::fragment_json() const {
  return *fragment_json_;
}
inline void PlanFragment::set_fragment_json(const ::std::string& value) {
  set_has_fragment_json();
  if (fragment_json_ == &::google::protobuf::internal::kEmptyString) {
    fragment_json_ = new ::std::string;
  }
  fragment_json_->assign(value);
}
inline void PlanFragment::set_fragment_json(const char* value) {
  set_has_fragment_json();
  if (fragment_json_ == &::google::protobuf::internal::kEmptyString) {
    fragment_json_ = new ::std::string;
  }
  fragment_json_->assign(value);
}
inline void PlanFragment::set_fragment_json(const char* value, size_t size) {
  set_has_fragment_json();
  if (fragment_json_ == &::google::protobuf::internal::kEmptyString) {
    fragment_json_ = new ::std::string;
  }
  fragment_json_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlanFragment::mutable_fragment_json() {
  set_has_fragment_json();
  if (fragment_json_ == &::google::protobuf::internal::kEmptyString) {
    fragment_json_ = new ::std::string;
  }
  return fragment_json_;
}
inline ::std::string* PlanFragment::release_fragment_json() {
  clear_has_fragment_json();
  if (fragment_json_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fragment_json_;
    fragment_json_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlanFragment::set_allocated_fragment_json(::std::string* fragment_json) {
  if (fragment_json_ != &::google::protobuf::internal::kEmptyString) {
    delete fragment_json_;
  }
  if (fragment_json) {
    set_has_fragment_json();
    fragment_json_ = fragment_json;
  } else {
    clear_has_fragment_json();
    fragment_json_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool leaf_fragment = 9;
inline bool PlanFragment::has_leaf_fragment() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlanFragment::set_has_leaf_fragment() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlanFragment::clear_has_leaf_fragment() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlanFragment::clear_leaf_fragment() {
  leaf_fragment_ = false;
  clear_has_leaf_fragment();
}
inline bool PlanFragment::leaf_fragment() const {
  return leaf_fragment_;
}
inline void PlanFragment::set_leaf_fragment(bool value) {
  set_has_leaf_fragment();
  leaf_fragment_ = value;
}

// optional .exec.DrillbitEndpoint assignment = 10;
inline bool PlanFragment::has_assignment() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlanFragment::set_has_assignment() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlanFragment::clear_has_assignment() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlanFragment::clear_assignment() {
  if (assignment_ != NULL) assignment_->::exec::DrillbitEndpoint::Clear();
  clear_has_assignment();
}
inline const ::exec::DrillbitEndpoint& PlanFragment::assignment() const {
  return assignment_ != NULL ? *assignment_ : *default_instance_->assignment_;
}
inline ::exec::DrillbitEndpoint* PlanFragment::mutable_assignment() {
  set_has_assignment();
  if (assignment_ == NULL) assignment_ = new ::exec::DrillbitEndpoint;
  return assignment_;
}
inline ::exec::DrillbitEndpoint* PlanFragment::release_assignment() {
  clear_has_assignment();
  ::exec::DrillbitEndpoint* temp = assignment_;
  assignment_ = NULL;
  return temp;
}
inline void PlanFragment::set_allocated_assignment(::exec::DrillbitEndpoint* assignment) {
  delete assignment_;
  assignment_ = assignment;
  if (assignment) {
    set_has_assignment();
  } else {
    clear_has_assignment();
  }
}

// optional .exec.DrillbitEndpoint foreman = 11;
inline bool PlanFragment::has_foreman() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PlanFragment::set_has_foreman() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PlanFragment::clear_has_foreman() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PlanFragment::clear_foreman() {
  if (foreman_ != NULL) foreman_->::exec::DrillbitEndpoint::Clear();
  clear_has_foreman();
}
inline const ::exec::DrillbitEndpoint& PlanFragment::foreman() const {
  return foreman_ != NULL ? *foreman_ : *default_instance_->foreman_;
}
inline ::exec::DrillbitEndpoint* PlanFragment::mutable_foreman() {
  set_has_foreman();
  if (foreman_ == NULL) foreman_ = new ::exec::DrillbitEndpoint;
  return foreman_;
}
inline ::exec::DrillbitEndpoint* PlanFragment::release_foreman() {
  clear_has_foreman();
  ::exec::DrillbitEndpoint* temp = foreman_;
  foreman_ = NULL;
  return temp;
}
inline void PlanFragment::set_allocated_foreman(::exec::DrillbitEndpoint* foreman) {
  delete foreman_;
  foreman_ = foreman;
  if (foreman) {
    set_has_foreman();
  } else {
    clear_has_foreman();
  }
}

// optional int64 mem_initial = 12 [default = 20000000];
inline bool PlanFragment::has_mem_initial() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PlanFragment::set_has_mem_initial() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PlanFragment::clear_has_mem_initial() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PlanFragment::clear_mem_initial() {
  mem_initial_ = GOOGLE_LONGLONG(20000000);
  clear_has_mem_initial();
}
inline ::google::protobuf::int64 PlanFragment::mem_initial() const {
  return mem_initial_;
}
inline void PlanFragment::set_mem_initial(::google::protobuf::int64 value) {
  set_has_mem_initial();
  mem_initial_ = value;
}

// optional int64 mem_max = 13 [default = 2000000000];
inline bool PlanFragment::has_mem_max() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PlanFragment::set_has_mem_max() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PlanFragment::clear_has_mem_max() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PlanFragment::clear_mem_max() {
  mem_max_ = GOOGLE_LONGLONG(2000000000);
  clear_has_mem_max();
}
inline ::google::protobuf::int64 PlanFragment::mem_max() const {
  return mem_max_;
}
inline void PlanFragment::set_mem_max(::google::protobuf::int64 value) {
  set_has_mem_max();
  mem_max_ = value;
}

// optional .exec.shared.UserCredentials credentials = 14;
inline bool PlanFragment::has_credentials() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PlanFragment::set_has_credentials() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PlanFragment::clear_has_credentials() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PlanFragment::clear_credentials() {
  if (credentials_ != NULL) credentials_->::exec::shared::UserCredentials::Clear();
  clear_has_credentials();
}
inline const ::exec::shared::UserCredentials& PlanFragment::credentials() const {
  return credentials_ != NULL ? *credentials_ : *default_instance_->credentials_;
}
inline ::exec::shared::UserCredentials* PlanFragment::mutable_credentials() {
  set_has_credentials();
  if (credentials_ == NULL) credentials_ = new ::exec::shared::UserCredentials;
  return credentials_;
}
inline ::exec::shared::UserCredentials* PlanFragment::release_credentials() {
  clear_has_credentials();
  ::exec::shared::UserCredentials* temp = credentials_;
  credentials_ = NULL;
  return temp;
}
inline void PlanFragment::set_allocated_credentials(::exec::shared::UserCredentials* credentials) {
  delete credentials_;
  credentials_ = credentials;
  if (credentials) {
    set_has_credentials();
  } else {
    clear_has_credentials();
  }
}

// optional string options_json = 15;
inline bool PlanFragment::has_options_json() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PlanFragment::set_has_options_json() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PlanFragment::clear_has_options_json() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PlanFragment::clear_options_json() {
  if (options_json_ != &::google::protobuf::internal::kEmptyString) {
    options_json_->clear();
  }
  clear_has_options_json();
}
inline const ::std::string& PlanFragment::options_json() const {
  return *options_json_;
}
inline void PlanFragment::set_options_json(const ::std::string& value) {
  set_has_options_json();
  if (options_json_ == &::google::protobuf::internal::kEmptyString) {
    options_json_ = new ::std::string;
  }
  options_json_->assign(value);
}
inline void PlanFragment::set_options_json(const char* value) {
  set_has_options_json();
  if (options_json_ == &::google::protobuf::internal::kEmptyString) {
    options_json_ = new ::std::string;
  }
  options_json_->assign(value);
}
inline void PlanFragment::set_options_json(const char* value, size_t size) {
  set_has_options_json();
  if (options_json_ == &::google::protobuf::internal::kEmptyString) {
    options_json_ = new ::std::string;
  }
  options_json_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlanFragment::mutable_options_json() {
  set_has_options_json();
  if (options_json_ == &::google::protobuf::internal::kEmptyString) {
    options_json_ = new ::std::string;
  }
  return options_json_;
}
inline ::std::string* PlanFragment::release_options_json() {
  clear_has_options_json();
  if (options_json_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = options_json_;
    options_json_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlanFragment::set_allocated_options_json(::std::string* options_json) {
  if (options_json_ != &::google::protobuf::internal::kEmptyString) {
    delete options_json_;
  }
  if (options_json) {
    set_has_options_json();
    options_json_ = options_json;
  } else {
    clear_has_options_json();
    options_json_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .exec.bit.control.QueryContextInformation context = 16;
inline bool PlanFragment::has_context() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PlanFragment::set_has_context() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PlanFragment::clear_has_context() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PlanFragment::clear_context() {
  if (context_ != NULL) context_->::exec::bit::control::QueryContextInformation::Clear();
  clear_has_context();
}
inline const ::exec::bit::control::QueryContextInformation& PlanFragment::context() const {
  return context_ != NULL ? *context_ : *default_instance_->context_;
}
inline ::exec::bit::control::QueryContextInformation* PlanFragment::mutable_context() {
  set_has_context();
  if (context_ == NULL) context_ = new ::exec::bit::control::QueryContextInformation;
  return context_;
}
inline ::exec::bit::control::QueryContextInformation* PlanFragment::release_context() {
  clear_has_context();
  ::exec::bit::control::QueryContextInformation* temp = context_;
  context_ = NULL;
  return temp;
}
inline void PlanFragment::set_allocated_context(::exec::bit::control::QueryContextInformation* context) {
  delete context_;
  context_ = context;
  if (context) {
    set_has_context();
  } else {
    clear_has_context();
  }
}

// repeated .exec.bit.control.Collector collector = 17;
inline int PlanFragment::collector_size() const {
  return collector_.size();
}
inline void PlanFragment::clear_collector() {
  collector_.Clear();
}
inline const ::exec::bit::control::Collector& PlanFragment::collector(int index) const {
  return collector_.Get(index);
}
inline ::exec::bit::control::Collector* PlanFragment::mutable_collector(int index) {
  return collector_.Mutable(index);
}
inline ::exec::bit::control::Collector* PlanFragment::add_collector() {
  return collector_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::bit::control::Collector >&
PlanFragment::collector() const {
  return collector_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::bit::control::Collector >*
PlanFragment::mutable_collector() {
  return &collector_;
}

// -------------------------------------------------------------------

// Collector

// optional int32 opposite_major_fragment_id = 1;
inline bool Collector::has_opposite_major_fragment_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Collector::set_has_opposite_major_fragment_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Collector::clear_has_opposite_major_fragment_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Collector::clear_opposite_major_fragment_id() {
  opposite_major_fragment_id_ = 0;
  clear_has_opposite_major_fragment_id();
}
inline ::google::protobuf::int32 Collector::opposite_major_fragment_id() const {
  return opposite_major_fragment_id_;
}
inline void Collector::set_opposite_major_fragment_id(::google::protobuf::int32 value) {
  set_has_opposite_major_fragment_id();
  opposite_major_fragment_id_ = value;
}

// repeated int32 incoming_minor_fragment = 2 [packed = true];
inline int Collector::incoming_minor_fragment_size() const {
  return incoming_minor_fragment_.size();
}
inline void Collector::clear_incoming_minor_fragment() {
  incoming_minor_fragment_.Clear();
}
inline ::google::protobuf::int32 Collector::incoming_minor_fragment(int index) const {
  return incoming_minor_fragment_.Get(index);
}
inline void Collector::set_incoming_minor_fragment(int index, ::google::protobuf::int32 value) {
  incoming_minor_fragment_.Set(index, value);
}
inline void Collector::add_incoming_minor_fragment(::google::protobuf::int32 value) {
  incoming_minor_fragment_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Collector::incoming_minor_fragment() const {
  return incoming_minor_fragment_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Collector::mutable_incoming_minor_fragment() {
  return &incoming_minor_fragment_;
}

// optional bool supports_out_of_order = 3;
inline bool Collector::has_supports_out_of_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Collector::set_has_supports_out_of_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Collector::clear_has_supports_out_of_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Collector::clear_supports_out_of_order() {
  supports_out_of_order_ = false;
  clear_has_supports_out_of_order();
}
inline bool Collector::supports_out_of_order() const {
  return supports_out_of_order_;
}
inline void Collector::set_supports_out_of_order(bool value) {
  set_has_supports_out_of_order();
  supports_out_of_order_ = value;
}

// optional bool is_spooling = 4;
inline bool Collector::has_is_spooling() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Collector::set_has_is_spooling() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Collector::clear_has_is_spooling() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Collector::clear_is_spooling() {
  is_spooling_ = false;
  clear_has_is_spooling();
}
inline bool Collector::is_spooling() const {
  return is_spooling_;
}
inline void Collector::set_is_spooling(bool value) {
  set_has_is_spooling();
  is_spooling_ = value;
}

// -------------------------------------------------------------------

// QueryContextInformation

// optional int64 query_start_time = 1;
inline bool QueryContextInformation::has_query_start_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryContextInformation::set_has_query_start_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryContextInformation::clear_has_query_start_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryContextInformation::clear_query_start_time() {
  query_start_time_ = GOOGLE_LONGLONG(0);
  clear_has_query_start_time();
}
inline ::google::protobuf::int64 QueryContextInformation::query_start_time() const {
  return query_start_time_;
}
inline void QueryContextInformation::set_query_start_time(::google::protobuf::int64 value) {
  set_has_query_start_time();
  query_start_time_ = value;
}

// optional int32 time_zone = 2;
inline bool QueryContextInformation::has_time_zone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryContextInformation::set_has_time_zone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryContextInformation::clear_has_time_zone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryContextInformation::clear_time_zone() {
  time_zone_ = 0;
  clear_has_time_zone();
}
inline ::google::protobuf::int32 QueryContextInformation::time_zone() const {
  return time_zone_;
}
inline void QueryContextInformation::set_time_zone(::google::protobuf::int32 value) {
  set_has_time_zone();
  time_zone_ = value;
}

// optional string default_schema_name = 3;
inline bool QueryContextInformation::has_default_schema_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryContextInformation::set_has_default_schema_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryContextInformation::clear_has_default_schema_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryContextInformation::clear_default_schema_name() {
  if (default_schema_name_ != &::google::protobuf::internal::kEmptyString) {
    default_schema_name_->clear();
  }
  clear_has_default_schema_name();
}
inline const ::std::string& QueryContextInformation::default_schema_name() const {
  return *default_schema_name_;
}
inline void QueryContextInformation::set_default_schema_name(const ::std::string& value) {
  set_has_default_schema_name();
  if (default_schema_name_ == &::google::protobuf::internal::kEmptyString) {
    default_schema_name_ = new ::std::string;
  }
  default_schema_name_->assign(value);
}
inline void QueryContextInformation::set_default_schema_name(const char* value) {
  set_has_default_schema_name();
  if (default_schema_name_ == &::google::protobuf::internal::kEmptyString) {
    default_schema_name_ = new ::std::string;
  }
  default_schema_name_->assign(value);
}
inline void QueryContextInformation::set_default_schema_name(const char* value, size_t size) {
  set_has_default_schema_name();
  if (default_schema_name_ == &::google::protobuf::internal::kEmptyString) {
    default_schema_name_ = new ::std::string;
  }
  default_schema_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryContextInformation::mutable_default_schema_name() {
  set_has_default_schema_name();
  if (default_schema_name_ == &::google::protobuf::internal::kEmptyString) {
    default_schema_name_ = new ::std::string;
  }
  return default_schema_name_;
}
inline ::std::string* QueryContextInformation::release_default_schema_name() {
  clear_has_default_schema_name();
  if (default_schema_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = default_schema_name_;
    default_schema_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryContextInformation::set_allocated_default_schema_name(::std::string* default_schema_name) {
  if (default_schema_name_ != &::google::protobuf::internal::kEmptyString) {
    delete default_schema_name_;
  }
  if (default_schema_name) {
    set_has_default_schema_name();
    default_schema_name_ = default_schema_name;
  } else {
    clear_has_default_schema_name();
    default_schema_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string session_id = 4;
inline bool QueryContextInformation::has_session_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QueryContextInformation::set_has_session_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QueryContextInformation::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QueryContextInformation::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& QueryContextInformation::session_id() const {
  return *session_id_;
}
inline void QueryContextInformation::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void QueryContextInformation::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void QueryContextInformation::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryContextInformation::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* QueryContextInformation::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryContextInformation::set_allocated_session_id(::std::string* session_id) {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    delete session_id_;
  }
  if (session_id) {
    set_has_session_id();
    session_id_ = session_id;
  } else {
    clear_has_session_id();
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// WorkQueueStatus

// optional .exec.DrillbitEndpoint endpoint = 1;
inline bool WorkQueueStatus::has_endpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WorkQueueStatus::set_has_endpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WorkQueueStatus::clear_has_endpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WorkQueueStatus::clear_endpoint() {
  if (endpoint_ != NULL) endpoint_->::exec::DrillbitEndpoint::Clear();
  clear_has_endpoint();
}
inline const ::exec::DrillbitEndpoint& WorkQueueStatus::endpoint() const {
  return endpoint_ != NULL ? *endpoint_ : *default_instance_->endpoint_;
}
inline ::exec::DrillbitEndpoint* WorkQueueStatus::mutable_endpoint() {
  set_has_endpoint();
  if (endpoint_ == NULL) endpoint_ = new ::exec::DrillbitEndpoint;
  return endpoint_;
}
inline ::exec::DrillbitEndpoint* WorkQueueStatus::release_endpoint() {
  clear_has_endpoint();
  ::exec::DrillbitEndpoint* temp = endpoint_;
  endpoint_ = NULL;
  return temp;
}
inline void WorkQueueStatus::set_allocated_endpoint(::exec::DrillbitEndpoint* endpoint) {
  delete endpoint_;
  endpoint_ = endpoint;
  if (endpoint) {
    set_has_endpoint();
  } else {
    clear_has_endpoint();
  }
}

// optional int32 queue_length = 2;
inline bool WorkQueueStatus::has_queue_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WorkQueueStatus::set_has_queue_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WorkQueueStatus::clear_has_queue_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WorkQueueStatus::clear_queue_length() {
  queue_length_ = 0;
  clear_has_queue_length();
}
inline ::google::protobuf::int32 WorkQueueStatus::queue_length() const {
  return queue_length_;
}
inline void WorkQueueStatus::set_queue_length(::google::protobuf::int32 value) {
  set_has_queue_length();
  queue_length_ = value;
}

// optional int64 report_time = 3;
inline bool WorkQueueStatus::has_report_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WorkQueueStatus::set_has_report_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WorkQueueStatus::clear_has_report_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WorkQueueStatus::clear_report_time() {
  report_time_ = GOOGLE_LONGLONG(0);
  clear_has_report_time();
}
inline ::google::protobuf::int64 WorkQueueStatus::report_time() const {
  return report_time_;
}
inline void WorkQueueStatus::set_report_time(::google::protobuf::int64 value) {
  set_has_report_time();
  report_time_ = value;
}

// -------------------------------------------------------------------

// FinishedReceiver

// optional .exec.bit.FragmentHandle receiver = 1;
inline bool FinishedReceiver::has_receiver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FinishedReceiver::set_has_receiver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FinishedReceiver::clear_has_receiver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FinishedReceiver::clear_receiver() {
  if (receiver_ != NULL) receiver_->::exec::bit::FragmentHandle::Clear();
  clear_has_receiver();
}
inline const ::exec::bit::FragmentHandle& FinishedReceiver::receiver() const {
  return receiver_ != NULL ? *receiver_ : *default_instance_->receiver_;
}
inline ::exec::bit::FragmentHandle* FinishedReceiver::mutable_receiver() {
  set_has_receiver();
  if (receiver_ == NULL) receiver_ = new ::exec::bit::FragmentHandle;
  return receiver_;
}
inline ::exec::bit::FragmentHandle* FinishedReceiver::release_receiver() {
  clear_has_receiver();
  ::exec::bit::FragmentHandle* temp = receiver_;
  receiver_ = NULL;
  return temp;
}
inline void FinishedReceiver::set_allocated_receiver(::exec::bit::FragmentHandle* receiver) {
  delete receiver_;
  receiver_ = receiver;
  if (receiver) {
    set_has_receiver();
  } else {
    clear_has_receiver();
  }
}

// optional .exec.bit.FragmentHandle sender = 2;
inline bool FinishedReceiver::has_sender() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FinishedReceiver::set_has_sender() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FinishedReceiver::clear_has_sender() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FinishedReceiver::clear_sender() {
  if (sender_ != NULL) sender_->::exec::bit::FragmentHandle::Clear();
  clear_has_sender();
}
inline const ::exec::bit::FragmentHandle& FinishedReceiver::sender() const {
  return sender_ != NULL ? *sender_ : *default_instance_->sender_;
}
inline ::exec::bit::FragmentHandle* FinishedReceiver::mutable_sender() {
  set_has_sender();
  if (sender_ == NULL) sender_ = new ::exec::bit::FragmentHandle;
  return sender_;
}
inline ::exec::bit::FragmentHandle* FinishedReceiver::release_sender() {
  clear_has_sender();
  ::exec::bit::FragmentHandle* temp = sender_;
  sender_ = NULL;
  return temp;
}
inline void FinishedReceiver::set_allocated_sender(::exec::bit::FragmentHandle* sender) {
  delete sender_;
  sender_ = sender;
  if (sender) {
    set_has_sender();
  } else {
    clear_has_sender();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace control
}  // namespace bit
}  // namespace exec

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::bit::control::RpcType>() {
  return ::exec::bit::control::RpcType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_BitControl_2eproto__INCLUDED
