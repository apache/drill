// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BitControl.proto

#include "BitControl.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace exec {
namespace bit {
namespace control {
constexpr BitControlHandshake::BitControlHandshake(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : authenticationmechanisms_()
  , endpoint_(nullptr)
  , rpc_version_(0)
  , channel_(0)
{}
struct BitControlHandshakeDefaultTypeInternal {
  constexpr BitControlHandshakeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BitControlHandshakeDefaultTypeInternal() {}
  union {
    BitControlHandshake _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BitControlHandshakeDefaultTypeInternal _BitControlHandshake_default_instance_;
constexpr BitStatus::BitStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : fragment_status_(){}
struct BitStatusDefaultTypeInternal {
  constexpr BitStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BitStatusDefaultTypeInternal() {}
  union {
    BitStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BitStatusDefaultTypeInternal _BitStatus_default_instance_;
constexpr FragmentStatus::FragmentStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : profile_(nullptr)
  , handle_(nullptr){}
struct FragmentStatusDefaultTypeInternal {
  constexpr FragmentStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FragmentStatusDefaultTypeInternal() {}
  union {
    FragmentStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FragmentStatusDefaultTypeInternal _FragmentStatus_default_instance_;
constexpr InitializeFragments::InitializeFragments(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : fragment_(){}
struct InitializeFragmentsDefaultTypeInternal {
  constexpr InitializeFragmentsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InitializeFragmentsDefaultTypeInternal() {}
  union {
    InitializeFragments _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InitializeFragmentsDefaultTypeInternal _InitializeFragments_default_instance_;
constexpr CustomMessage::CustomMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , type_(0){}
struct CustomMessageDefaultTypeInternal {
  constexpr CustomMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CustomMessageDefaultTypeInternal() {}
  union {
    CustomMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CustomMessageDefaultTypeInternal _CustomMessage_default_instance_;
constexpr PlanFragment::PlanFragment(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : collector_()
  , fragment_json_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , options_json_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , handle_(nullptr)
  , assignment_(nullptr)
  , foreman_(nullptr)
  , credentials_(nullptr)
  , context_(nullptr)
  , network_cost_(0)
  , cpu_cost_(0)
  , disk_cost_(0)
  , memory_cost_(0)
  , leaf_fragment_(false)
  , mem_initial_(PROTOBUF_LONGLONG(20000000))
  , mem_max_(PROTOBUF_LONGLONG(2000000000)){}
struct PlanFragmentDefaultTypeInternal {
  constexpr PlanFragmentDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PlanFragmentDefaultTypeInternal() {}
  union {
    PlanFragment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PlanFragmentDefaultTypeInternal _PlanFragment_default_instance_;
constexpr Collector::Collector(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : incoming_minor_fragment_()
  , _incoming_minor_fragment_cached_byte_size_()
  , opposite_major_fragment_id_(0)
  , supports_out_of_order_(false)
  , is_spooling_(false)
  , enable_dynamic_fc_(false){}
struct CollectorDefaultTypeInternal {
  constexpr CollectorDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CollectorDefaultTypeInternal() {}
  union {
    Collector _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CollectorDefaultTypeInternal _Collector_default_instance_;
constexpr QueryContextInformation::QueryContextInformation(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : default_schema_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , session_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , query_start_time_(PROTOBUF_LONGLONG(0))
  , time_zone_(0){}
struct QueryContextInformationDefaultTypeInternal {
  constexpr QueryContextInformationDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~QueryContextInformationDefaultTypeInternal() {}
  union {
    QueryContextInformation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT QueryContextInformationDefaultTypeInternal _QueryContextInformation_default_instance_;
constexpr WorkQueueStatus::WorkQueueStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : endpoint_(nullptr)
  , report_time_(PROTOBUF_LONGLONG(0))
  , queue_length_(0){}
struct WorkQueueStatusDefaultTypeInternal {
  constexpr WorkQueueStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WorkQueueStatusDefaultTypeInternal() {}
  union {
    WorkQueueStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WorkQueueStatusDefaultTypeInternal _WorkQueueStatus_default_instance_;
constexpr FinishedReceiver::FinishedReceiver(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : receiver_(nullptr)
  , sender_(nullptr){}
struct FinishedReceiverDefaultTypeInternal {
  constexpr FinishedReceiverDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FinishedReceiverDefaultTypeInternal() {}
  union {
    FinishedReceiver _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FinishedReceiverDefaultTypeInternal _FinishedReceiver_default_instance_;
}  // namespace control
}  // namespace bit
}  // namespace exec
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_BitControl_2eproto[10];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_BitControl_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_BitControl_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_BitControl_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::BitControlHandshake, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::BitControlHandshake, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::BitControlHandshake, rpc_version_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::BitControlHandshake, channel_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::BitControlHandshake, endpoint_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::BitControlHandshake, authenticationmechanisms_),
  1,
  2,
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::BitStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::BitStatus, fragment_status_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::FragmentStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::FragmentStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::FragmentStatus, profile_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::FragmentStatus, handle_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::InitializeFragments, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::InitializeFragments, fragment_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::CustomMessage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::CustomMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::CustomMessage, type_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::CustomMessage, message_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::PlanFragment, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::PlanFragment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::PlanFragment, handle_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::PlanFragment, network_cost_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::PlanFragment, cpu_cost_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::PlanFragment, disk_cost_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::PlanFragment, memory_cost_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::PlanFragment, fragment_json_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::PlanFragment, leaf_fragment_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::PlanFragment, assignment_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::PlanFragment, foreman_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::PlanFragment, mem_initial_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::PlanFragment, mem_max_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::PlanFragment, credentials_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::PlanFragment, options_json_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::PlanFragment, context_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::PlanFragment, collector_),
  2,
  7,
  8,
  9,
  10,
  0,
  11,
  3,
  4,
  12,
  13,
  5,
  1,
  6,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::Collector, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::Collector, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::Collector, opposite_major_fragment_id_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::Collector, incoming_minor_fragment_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::Collector, supports_out_of_order_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::Collector, is_spooling_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::Collector, enable_dynamic_fc_),
  0,
  ~0u,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::QueryContextInformation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::QueryContextInformation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::QueryContextInformation, query_start_time_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::QueryContextInformation, time_zone_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::QueryContextInformation, default_schema_name_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::QueryContextInformation, session_id_),
  2,
  3,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::WorkQueueStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::WorkQueueStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::WorkQueueStatus, endpoint_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::WorkQueueStatus, queue_length_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::WorkQueueStatus, report_time_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::FinishedReceiver, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::FinishedReceiver, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::FinishedReceiver, receiver_),
  PROTOBUF_FIELD_OFFSET(::exec::bit::control::FinishedReceiver, sender_),
  0,
  1,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 9, sizeof(::exec::bit::control::BitControlHandshake)},
  { 13, -1, sizeof(::exec::bit::control::BitStatus)},
  { 19, 26, sizeof(::exec::bit::control::FragmentStatus)},
  { 28, -1, sizeof(::exec::bit::control::InitializeFragments)},
  { 34, 41, sizeof(::exec::bit::control::CustomMessage)},
  { 43, 63, sizeof(::exec::bit::control::PlanFragment)},
  { 78, 88, sizeof(::exec::bit::control::Collector)},
  { 93, 102, sizeof(::exec::bit::control::QueryContextInformation)},
  { 106, 114, sizeof(::exec::bit::control::WorkQueueStatus)},
  { 117, 124, sizeof(::exec::bit::control::FinishedReceiver)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::exec::bit::control::_BitControlHandshake_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::exec::bit::control::_BitStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::exec::bit::control::_FragmentStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::exec::bit::control::_InitializeFragments_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::exec::bit::control::_CustomMessage_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::exec::bit::control::_PlanFragment_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::exec::bit::control::_Collector_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::exec::bit::control::_QueryContextInformation_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::exec::bit::control::_WorkQueueStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::exec::bit::control::_FinishedReceiver_default_instance_),
};

const char descriptor_table_protodef_BitControl_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\020BitControl.proto\022\020exec.bit.control\032\025Ex"
  "ecutionProtos.proto\032\022Coordination.proto\032"
  "\023UserBitShared.proto\"\255\001\n\023BitControlHands"
  "hake\022\023\n\013rpc_version\030\001 \001(\005\0225\n\007channel\030\002 \001"
  "(\0162\027.exec.shared.RpcChannel:\013BIT_CONTROL"
  "\022(\n\010endpoint\030\003 \001(\0132\026.exec.DrillbitEndpoi"
  "nt\022 \n\030authenticationMechanisms\030\004 \003(\t\"F\n\t"
  "BitStatus\0229\n\017fragment_status\030\001 \003(\0132 .exe"
  "c.bit.control.FragmentStatus\"n\n\016Fragment"
  "Status\0222\n\007profile\030\001 \001(\0132!.exec.shared.Mi"
  "norFragmentProfile\022(\n\006handle\030\002 \001(\0132\030.exe"
  "c.bit.FragmentHandle\"G\n\023InitializeFragme"
  "nts\0220\n\010fragment\030\001 \003(\0132\036.exec.bit.control"
  ".PlanFragment\".\n\rCustomMessage\022\014\n\004type\030\001"
  " \001(\005\022\017\n\007message\030\002 \001(\014\"\374\003\n\014PlanFragment\022("
  "\n\006handle\030\001 \001(\0132\030.exec.bit.FragmentHandle"
  "\022\024\n\014network_cost\030\004 \001(\002\022\020\n\010cpu_cost\030\005 \001(\002"
  "\022\021\n\tdisk_cost\030\006 \001(\002\022\023\n\013memory_cost\030\007 \001(\002"
  "\022\025\n\rfragment_json\030\010 \001(\t\022\025\n\rleaf_fragment"
  "\030\t \001(\010\022*\n\nassignment\030\n \001(\0132\026.exec.Drillb"
  "itEndpoint\022\'\n\007foreman\030\013 \001(\0132\026.exec.Drill"
  "bitEndpoint\022\035\n\013mem_initial\030\014 \001(\003:\010200000"
  "00\022\033\n\007mem_max\030\r \001(\003:\n2000000000\0221\n\013crede"
  "ntials\030\016 \001(\0132\034.exec.shared.UserCredentia"
  "ls\022\024\n\014options_json\030\017 \001(\t\022:\n\007context\030\020 \001("
  "\0132).exec.bit.control.QueryContextInforma"
  "tion\022.\n\tcollector\030\021 \003(\0132\033.exec.bit.contr"
  "ol.Collector\"\243\001\n\tCollector\022\"\n\032opposite_m"
  "ajor_fragment_id\030\001 \001(\005\022#\n\027incoming_minor"
  "_fragment\030\002 \003(\005B\002\020\001\022\035\n\025supports_out_of_o"
  "rder\030\003 \001(\010\022\023\n\013is_spooling\030\004 \001(\010\022\031\n\021enabl"
  "e_dynamic_fc\030\005 \001(\010\"w\n\027QueryContextInform"
  "ation\022\030\n\020query_start_time\030\001 \001(\003\022\021\n\ttime_"
  "zone\030\002 \001(\005\022\033\n\023default_schema_name\030\003 \001(\t\022"
  "\022\n\nsession_id\030\004 \001(\t\"f\n\017WorkQueueStatus\022("
  "\n\010endpoint\030\001 \001(\0132\026.exec.DrillbitEndpoint"
  "\022\024\n\014queue_length\030\002 \001(\005\022\023\n\013report_time\030\003 "
  "\001(\003\"h\n\020FinishedReceiver\022*\n\010receiver\030\001 \001("
  "\0132\030.exec.bit.FragmentHandle\022(\n\006sender\030\002 "
  "\001(\0132\030.exec.bit.FragmentHandle*\206\003\n\007RpcTyp"
  "e\022\r\n\tHANDSHAKE\020\000\022\007\n\003ACK\020\001\022\013\n\007GOODBYE\020\002\022\034"
  "\n\030REQ_INITIALIZE_FRAGMENTS\020\003\022\027\n\023REQ_CANC"
  "EL_FRAGMENT\020\006\022\031\n\025REQ_RECEIVER_FINISHED\020\007"
  "\022\027\n\023REQ_FRAGMENT_STATUS\020\010\022\022\n\016REQ_BIT_STA"
  "TUS\020\t\022\024\n\020REQ_QUERY_STATUS\020\n\022\024\n\020REQ_QUERY"
  "_CANCEL\020\017\022\030\n\024REQ_UNPAUSE_FRAGMENT\020\020\022\016\n\nR"
  "EQ_CUSTOM\020\021\022\030\n\024RESP_FRAGMENT_HANDLE\020\013\022\030\n"
  "\024RESP_FRAGMENT_STATUS\020\014\022\023\n\017RESP_BIT_STAT"
  "US\020\r\022\025\n\021RESP_QUERY_STATUS\020\016\022\017\n\013RESP_CUST"
  "OM\020\022\022\020\n\014SASL_MESSAGE\020\023B+\n\033org.apache.dri"
  "ll.exec.protoB\nBitControlH\001"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_BitControl_2eproto_deps[3] = {
  &::descriptor_table_Coordination_2eproto,
  &::descriptor_table_ExecutionProtos_2eproto,
  &::descriptor_table_UserBitShared_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_BitControl_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_BitControl_2eproto = {
  false, false, 2027, descriptor_table_protodef_BitControl_2eproto, "BitControl.proto", 
  &descriptor_table_BitControl_2eproto_once, descriptor_table_BitControl_2eproto_deps, 3, 10,
  schemas, file_default_instances, TableStruct_BitControl_2eproto::offsets,
  file_level_metadata_BitControl_2eproto, file_level_enum_descriptors_BitControl_2eproto, file_level_service_descriptors_BitControl_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_BitControl_2eproto_getter() {
  return &descriptor_table_BitControl_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_BitControl_2eproto(&descriptor_table_BitControl_2eproto);
namespace exec {
namespace bit {
namespace control {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RpcType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_BitControl_2eproto);
  return file_level_enum_descriptors_BitControl_2eproto[0];
}
bool RpcType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class BitControlHandshake::_Internal {
 public:
  using HasBits = decltype(std::declval<BitControlHandshake>()._has_bits_);
  static void set_has_rpc_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::exec::DrillbitEndpoint& endpoint(const BitControlHandshake* msg);
  static void set_has_endpoint(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::exec::DrillbitEndpoint&
BitControlHandshake::_Internal::endpoint(const BitControlHandshake* msg) {
  return *msg->endpoint_;
}
void BitControlHandshake::clear_endpoint() {
  if (endpoint_ != nullptr) endpoint_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
BitControlHandshake::BitControlHandshake(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  authenticationmechanisms_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:exec.bit.control.BitControlHandshake)
}
BitControlHandshake::BitControlHandshake(const BitControlHandshake& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      authenticationmechanisms_(from.authenticationmechanisms_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_endpoint()) {
    endpoint_ = new ::exec::DrillbitEndpoint(*from.endpoint_);
  } else {
    endpoint_ = nullptr;
  }
  ::memcpy(&rpc_version_, &from.rpc_version_,
    static_cast<size_t>(reinterpret_cast<char*>(&channel_) -
    reinterpret_cast<char*>(&rpc_version_)) + sizeof(channel_));
  // @@protoc_insertion_point(copy_constructor:exec.bit.control.BitControlHandshake)
}

void BitControlHandshake::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&endpoint_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&channel_) -
    reinterpret_cast<char*>(&endpoint_)) + sizeof(channel_));
}

BitControlHandshake::~BitControlHandshake() {
  // @@protoc_insertion_point(destructor:exec.bit.control.BitControlHandshake)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void BitControlHandshake::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete endpoint_;
}

void BitControlHandshake::ArenaDtor(void* object) {
  BitControlHandshake* _this = reinterpret_cast< BitControlHandshake* >(object);
  (void)_this;
}
void BitControlHandshake::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BitControlHandshake::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BitControlHandshake::Clear() {
// @@protoc_insertion_point(message_clear_start:exec.bit.control.BitControlHandshake)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  authenticationmechanisms_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(endpoint_ != nullptr);
    endpoint_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&rpc_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&channel_) -
        reinterpret_cast<char*>(&rpc_version_)) + sizeof(channel_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BitControlHandshake::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 rpc_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_rpc_version(&has_bits);
          rpc_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .exec.shared.RpcChannel channel = 2 [default = BIT_CONTROL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::exec::shared::RpcChannel_IsValid(val))) {
            _internal_set_channel(static_cast<::exec::shared::RpcChannel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .exec.DrillbitEndpoint endpoint = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_endpoint(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string authenticationMechanisms = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_authenticationmechanisms();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "exec.bit.control.BitControlHandshake.authenticationMechanisms");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BitControlHandshake::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:exec.bit.control.BitControlHandshake)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 rpc_version = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_rpc_version(), target);
  }

  // optional .exec.shared.RpcChannel channel = 2 [default = BIT_CONTROL];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_channel(), target);
  }

  // optional .exec.DrillbitEndpoint endpoint = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::endpoint(this), target, stream);
  }

  // repeated string authenticationMechanisms = 4;
  for (int i = 0, n = this->_internal_authenticationmechanisms_size(); i < n; i++) {
    const auto& s = this->_internal_authenticationmechanisms(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "exec.bit.control.BitControlHandshake.authenticationMechanisms");
    target = stream->WriteString(4, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:exec.bit.control.BitControlHandshake)
  return target;
}

size_t BitControlHandshake::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:exec.bit.control.BitControlHandshake)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string authenticationMechanisms = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(authenticationmechanisms_.size());
  for (int i = 0, n = authenticationmechanisms_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      authenticationmechanisms_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .exec.DrillbitEndpoint endpoint = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *endpoint_);
    }

    // optional int32 rpc_version = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_rpc_version());
    }

    // optional .exec.shared.RpcChannel channel = 2 [default = BIT_CONTROL];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_channel());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BitControlHandshake::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:exec.bit.control.BitControlHandshake)
  GOOGLE_DCHECK_NE(&from, this);
  const BitControlHandshake* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<BitControlHandshake>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:exec.bit.control.BitControlHandshake)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:exec.bit.control.BitControlHandshake)
    MergeFrom(*source);
  }
}

void BitControlHandshake::MergeFrom(const BitControlHandshake& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:exec.bit.control.BitControlHandshake)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  authenticationmechanisms_.MergeFrom(from.authenticationmechanisms_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_endpoint()->::exec::DrillbitEndpoint::MergeFrom(from._internal_endpoint());
    }
    if (cached_has_bits & 0x00000002u) {
      rpc_version_ = from.rpc_version_;
    }
    if (cached_has_bits & 0x00000004u) {
      channel_ = from.channel_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void BitControlHandshake::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:exec.bit.control.BitControlHandshake)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BitControlHandshake::CopyFrom(const BitControlHandshake& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:exec.bit.control.BitControlHandshake)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BitControlHandshake::IsInitialized() const {
  return true;
}

void BitControlHandshake::InternalSwap(BitControlHandshake* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  authenticationmechanisms_.InternalSwap(&other->authenticationmechanisms_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BitControlHandshake, channel_)
      + sizeof(BitControlHandshake::channel_)
      - PROTOBUF_FIELD_OFFSET(BitControlHandshake, endpoint_)>(
          reinterpret_cast<char*>(&endpoint_),
          reinterpret_cast<char*>(&other->endpoint_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BitControlHandshake::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_BitControl_2eproto_getter, &descriptor_table_BitControl_2eproto_once,
      file_level_metadata_BitControl_2eproto[0]);
}

// ===================================================================

class BitStatus::_Internal {
 public:
};

BitStatus::BitStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  fragment_status_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:exec.bit.control.BitStatus)
}
BitStatus::BitStatus(const BitStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      fragment_status_(from.fragment_status_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:exec.bit.control.BitStatus)
}

void BitStatus::SharedCtor() {
}

BitStatus::~BitStatus() {
  // @@protoc_insertion_point(destructor:exec.bit.control.BitStatus)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void BitStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void BitStatus::ArenaDtor(void* object) {
  BitStatus* _this = reinterpret_cast< BitStatus* >(object);
  (void)_this;
}
void BitStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BitStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BitStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:exec.bit.control.BitStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  fragment_status_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BitStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .exec.bit.control.FragmentStatus fragment_status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fragment_status(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BitStatus::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:exec.bit.control.BitStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .exec.bit.control.FragmentStatus fragment_status = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_fragment_status_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_fragment_status(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:exec.bit.control.BitStatus)
  return target;
}

size_t BitStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:exec.bit.control.BitStatus)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .exec.bit.control.FragmentStatus fragment_status = 1;
  total_size += 1UL * this->_internal_fragment_status_size();
  for (const auto& msg : this->fragment_status_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BitStatus::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:exec.bit.control.BitStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const BitStatus* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<BitStatus>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:exec.bit.control.BitStatus)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:exec.bit.control.BitStatus)
    MergeFrom(*source);
  }
}

void BitStatus::MergeFrom(const BitStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:exec.bit.control.BitStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  fragment_status_.MergeFrom(from.fragment_status_);
}

void BitStatus::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:exec.bit.control.BitStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BitStatus::CopyFrom(const BitStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:exec.bit.control.BitStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BitStatus::IsInitialized() const {
  return true;
}

void BitStatus::InternalSwap(BitStatus* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  fragment_status_.InternalSwap(&other->fragment_status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BitStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_BitControl_2eproto_getter, &descriptor_table_BitControl_2eproto_once,
      file_level_metadata_BitControl_2eproto[1]);
}

// ===================================================================

class FragmentStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<FragmentStatus>()._has_bits_);
  static const ::exec::shared::MinorFragmentProfile& profile(const FragmentStatus* msg);
  static void set_has_profile(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::exec::bit::FragmentHandle& handle(const FragmentStatus* msg);
  static void set_has_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::exec::shared::MinorFragmentProfile&
FragmentStatus::_Internal::profile(const FragmentStatus* msg) {
  return *msg->profile_;
}
const ::exec::bit::FragmentHandle&
FragmentStatus::_Internal::handle(const FragmentStatus* msg) {
  return *msg->handle_;
}
void FragmentStatus::clear_profile() {
  if (profile_ != nullptr) profile_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void FragmentStatus::clear_handle() {
  if (handle_ != nullptr) handle_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
FragmentStatus::FragmentStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:exec.bit.control.FragmentStatus)
}
FragmentStatus::FragmentStatus(const FragmentStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_profile()) {
    profile_ = new ::exec::shared::MinorFragmentProfile(*from.profile_);
  } else {
    profile_ = nullptr;
  }
  if (from._internal_has_handle()) {
    handle_ = new ::exec::bit::FragmentHandle(*from.handle_);
  } else {
    handle_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:exec.bit.control.FragmentStatus)
}

void FragmentStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&profile_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&handle_) -
    reinterpret_cast<char*>(&profile_)) + sizeof(handle_));
}

FragmentStatus::~FragmentStatus() {
  // @@protoc_insertion_point(destructor:exec.bit.control.FragmentStatus)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void FragmentStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete profile_;
  if (this != internal_default_instance()) delete handle_;
}

void FragmentStatus::ArenaDtor(void* object) {
  FragmentStatus* _this = reinterpret_cast< FragmentStatus* >(object);
  (void)_this;
}
void FragmentStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FragmentStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FragmentStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:exec.bit.control.FragmentStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(profile_ != nullptr);
      profile_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(handle_ != nullptr);
      handle_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FragmentStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .exec.shared.MinorFragmentProfile profile = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_profile(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .exec.bit.FragmentHandle handle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_handle(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FragmentStatus::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:exec.bit.control.FragmentStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .exec.shared.MinorFragmentProfile profile = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::profile(this), target, stream);
  }

  // optional .exec.bit.FragmentHandle handle = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::handle(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:exec.bit.control.FragmentStatus)
  return target;
}

size_t FragmentStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:exec.bit.control.FragmentStatus)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .exec.shared.MinorFragmentProfile profile = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *profile_);
    }

    // optional .exec.bit.FragmentHandle handle = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *handle_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FragmentStatus::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:exec.bit.control.FragmentStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const FragmentStatus* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FragmentStatus>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:exec.bit.control.FragmentStatus)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:exec.bit.control.FragmentStatus)
    MergeFrom(*source);
  }
}

void FragmentStatus::MergeFrom(const FragmentStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:exec.bit.control.FragmentStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_profile()->::exec::shared::MinorFragmentProfile::MergeFrom(from._internal_profile());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_handle()->::exec::bit::FragmentHandle::MergeFrom(from._internal_handle());
    }
  }
}

void FragmentStatus::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:exec.bit.control.FragmentStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FragmentStatus::CopyFrom(const FragmentStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:exec.bit.control.FragmentStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FragmentStatus::IsInitialized() const {
  return true;
}

void FragmentStatus::InternalSwap(FragmentStatus* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FragmentStatus, handle_)
      + sizeof(FragmentStatus::handle_)
      - PROTOBUF_FIELD_OFFSET(FragmentStatus, profile_)>(
          reinterpret_cast<char*>(&profile_),
          reinterpret_cast<char*>(&other->profile_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FragmentStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_BitControl_2eproto_getter, &descriptor_table_BitControl_2eproto_once,
      file_level_metadata_BitControl_2eproto[2]);
}

// ===================================================================

class InitializeFragments::_Internal {
 public:
};

InitializeFragments::InitializeFragments(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  fragment_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:exec.bit.control.InitializeFragments)
}
InitializeFragments::InitializeFragments(const InitializeFragments& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      fragment_(from.fragment_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:exec.bit.control.InitializeFragments)
}

void InitializeFragments::SharedCtor() {
}

InitializeFragments::~InitializeFragments() {
  // @@protoc_insertion_point(destructor:exec.bit.control.InitializeFragments)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void InitializeFragments::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void InitializeFragments::ArenaDtor(void* object) {
  InitializeFragments* _this = reinterpret_cast< InitializeFragments* >(object);
  (void)_this;
}
void InitializeFragments::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void InitializeFragments::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InitializeFragments::Clear() {
// @@protoc_insertion_point(message_clear_start:exec.bit.control.InitializeFragments)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  fragment_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InitializeFragments::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .exec.bit.control.PlanFragment fragment = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fragment(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* InitializeFragments::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:exec.bit.control.InitializeFragments)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .exec.bit.control.PlanFragment fragment = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_fragment_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_fragment(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:exec.bit.control.InitializeFragments)
  return target;
}

size_t InitializeFragments::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:exec.bit.control.InitializeFragments)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .exec.bit.control.PlanFragment fragment = 1;
  total_size += 1UL * this->_internal_fragment_size();
  for (const auto& msg : this->fragment_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InitializeFragments::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:exec.bit.control.InitializeFragments)
  GOOGLE_DCHECK_NE(&from, this);
  const InitializeFragments* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<InitializeFragments>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:exec.bit.control.InitializeFragments)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:exec.bit.control.InitializeFragments)
    MergeFrom(*source);
  }
}

void InitializeFragments::MergeFrom(const InitializeFragments& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:exec.bit.control.InitializeFragments)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  fragment_.MergeFrom(from.fragment_);
}

void InitializeFragments::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:exec.bit.control.InitializeFragments)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InitializeFragments::CopyFrom(const InitializeFragments& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:exec.bit.control.InitializeFragments)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitializeFragments::IsInitialized() const {
  return true;
}

void InitializeFragments::InternalSwap(InitializeFragments* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  fragment_.InternalSwap(&other->fragment_);
}

::PROTOBUF_NAMESPACE_ID::Metadata InitializeFragments::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_BitControl_2eproto_getter, &descriptor_table_BitControl_2eproto_once,
      file_level_metadata_BitControl_2eproto[3]);
}

// ===================================================================

class CustomMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<CustomMessage>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CustomMessage::CustomMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:exec.bit.control.CustomMessage)
}
CustomMessage::CustomMessage(const CustomMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message()) {
    message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_message(), 
      GetArena());
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:exec.bit.control.CustomMessage)
}

void CustomMessage::SharedCtor() {
message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
type_ = 0;
}

CustomMessage::~CustomMessage() {
  // @@protoc_insertion_point(destructor:exec.bit.control.CustomMessage)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CustomMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CustomMessage::ArenaDtor(void* object) {
  CustomMessage* _this = reinterpret_cast< CustomMessage* >(object);
  (void)_this;
}
void CustomMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CustomMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CustomMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:exec.bit.control.CustomMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmpty();
  }
  type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CustomMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CustomMessage::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:exec.bit.control.CustomMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_type(), target);
  }

  // optional bytes message = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:exec.bit.control.CustomMessage)
  return target;
}

size_t CustomMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:exec.bit.control.CustomMessage)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes message = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_message());
    }

    // optional int32 type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CustomMessage::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:exec.bit.control.CustomMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const CustomMessage* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CustomMessage>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:exec.bit.control.CustomMessage)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:exec.bit.control.CustomMessage)
    MergeFrom(*source);
  }
}

void CustomMessage::MergeFrom(const CustomMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:exec.bit.control.CustomMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CustomMessage::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:exec.bit.control.CustomMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CustomMessage::CopyFrom(const CustomMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:exec.bit.control.CustomMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CustomMessage::IsInitialized() const {
  return true;
}

void CustomMessage::InternalSwap(CustomMessage* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  message_.Swap(&other->message_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CustomMessage::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_BitControl_2eproto_getter, &descriptor_table_BitControl_2eproto_once,
      file_level_metadata_BitControl_2eproto[4]);
}

// ===================================================================

class PlanFragment::_Internal {
 public:
  using HasBits = decltype(std::declval<PlanFragment>()._has_bits_);
  static const ::exec::bit::FragmentHandle& handle(const PlanFragment* msg);
  static void set_has_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_network_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_cpu_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_disk_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_memory_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_fragment_json(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_leaf_fragment(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::exec::DrillbitEndpoint& assignment(const PlanFragment* msg);
  static void set_has_assignment(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::exec::DrillbitEndpoint& foreman(const PlanFragment* msg);
  static void set_has_foreman(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mem_initial(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_mem_max(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::exec::shared::UserCredentials& credentials(const PlanFragment* msg);
  static void set_has_credentials(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_options_json(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::exec::bit::control::QueryContextInformation& context(const PlanFragment* msg);
  static void set_has_context(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::exec::bit::FragmentHandle&
PlanFragment::_Internal::handle(const PlanFragment* msg) {
  return *msg->handle_;
}
const ::exec::DrillbitEndpoint&
PlanFragment::_Internal::assignment(const PlanFragment* msg) {
  return *msg->assignment_;
}
const ::exec::DrillbitEndpoint&
PlanFragment::_Internal::foreman(const PlanFragment* msg) {
  return *msg->foreman_;
}
const ::exec::shared::UserCredentials&
PlanFragment::_Internal::credentials(const PlanFragment* msg) {
  return *msg->credentials_;
}
const ::exec::bit::control::QueryContextInformation&
PlanFragment::_Internal::context(const PlanFragment* msg) {
  return *msg->context_;
}
void PlanFragment::clear_handle() {
  if (handle_ != nullptr) handle_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void PlanFragment::clear_assignment() {
  if (assignment_ != nullptr) assignment_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
void PlanFragment::clear_foreman() {
  if (foreman_ != nullptr) foreman_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
void PlanFragment::clear_credentials() {
  if (credentials_ != nullptr) credentials_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
PlanFragment::PlanFragment(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  collector_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:exec.bit.control.PlanFragment)
}
PlanFragment::PlanFragment(const PlanFragment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      collector_(from.collector_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  fragment_json_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_fragment_json()) {
    fragment_json_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_fragment_json(), 
      GetArena());
  }
  options_json_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_options_json()) {
    options_json_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_options_json(), 
      GetArena());
  }
  if (from._internal_has_handle()) {
    handle_ = new ::exec::bit::FragmentHandle(*from.handle_);
  } else {
    handle_ = nullptr;
  }
  if (from._internal_has_assignment()) {
    assignment_ = new ::exec::DrillbitEndpoint(*from.assignment_);
  } else {
    assignment_ = nullptr;
  }
  if (from._internal_has_foreman()) {
    foreman_ = new ::exec::DrillbitEndpoint(*from.foreman_);
  } else {
    foreman_ = nullptr;
  }
  if (from._internal_has_credentials()) {
    credentials_ = new ::exec::shared::UserCredentials(*from.credentials_);
  } else {
    credentials_ = nullptr;
  }
  if (from._internal_has_context()) {
    context_ = new ::exec::bit::control::QueryContextInformation(*from.context_);
  } else {
    context_ = nullptr;
  }
  ::memcpy(&network_cost_, &from.network_cost_,
    static_cast<size_t>(reinterpret_cast<char*>(&mem_max_) -
    reinterpret_cast<char*>(&network_cost_)) + sizeof(mem_max_));
  // @@protoc_insertion_point(copy_constructor:exec.bit.control.PlanFragment)
}

void PlanFragment::SharedCtor() {
fragment_json_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
options_json_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&handle_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&leaf_fragment_) -
    reinterpret_cast<char*>(&handle_)) + sizeof(leaf_fragment_));
mem_initial_ = PROTOBUF_LONGLONG(20000000);
mem_max_ = PROTOBUF_LONGLONG(2000000000);
}

PlanFragment::~PlanFragment() {
  // @@protoc_insertion_point(destructor:exec.bit.control.PlanFragment)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void PlanFragment::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  fragment_json_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  options_json_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete handle_;
  if (this != internal_default_instance()) delete assignment_;
  if (this != internal_default_instance()) delete foreman_;
  if (this != internal_default_instance()) delete credentials_;
  if (this != internal_default_instance()) delete context_;
}

void PlanFragment::ArenaDtor(void* object) {
  PlanFragment* _this = reinterpret_cast< PlanFragment* >(object);
  (void)_this;
}
void PlanFragment::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PlanFragment::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PlanFragment::Clear() {
// @@protoc_insertion_point(message_clear_start:exec.bit.control.PlanFragment)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  collector_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      fragment_json_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      options_json_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(handle_ != nullptr);
      handle_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(assignment_ != nullptr);
      assignment_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(foreman_ != nullptr);
      foreman_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(credentials_ != nullptr);
      credentials_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(context_ != nullptr);
      context_->Clear();
    }
  }
  network_cost_ = 0;
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&cpu_cost_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&leaf_fragment_) -
        reinterpret_cast<char*>(&cpu_cost_)) + sizeof(leaf_fragment_));
    mem_initial_ = PROTOBUF_LONGLONG(20000000);
    mem_max_ = PROTOBUF_LONGLONG(2000000000);
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlanFragment::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .exec.bit.FragmentHandle handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_handle(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float network_cost = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_network_cost(&has_bits);
          network_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float cpu_cost = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_cpu_cost(&has_bits);
          cpu_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float disk_cost = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_disk_cost(&has_bits);
          disk_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float memory_cost = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_memory_cost(&has_bits);
          memory_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional string fragment_json = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          auto str = _internal_mutable_fragment_json();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "exec.bit.control.PlanFragment.fragment_json");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool leaf_fragment = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_leaf_fragment(&has_bits);
          leaf_fragment_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .exec.DrillbitEndpoint assignment = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_assignment(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .exec.DrillbitEndpoint foreman = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_foreman(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 mem_initial = 12 [default = 20000000];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_mem_initial(&has_bits);
          mem_initial_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 mem_max = 13 [default = 2000000000];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_mem_max(&has_bits);
          mem_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .exec.shared.UserCredentials credentials = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_credentials(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string options_json = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          auto str = _internal_mutable_options_json();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "exec.bit.control.PlanFragment.options_json");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .exec.bit.control.QueryContextInformation context = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_context(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .exec.bit.control.Collector collector = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_collector(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<138>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PlanFragment::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:exec.bit.control.PlanFragment)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .exec.bit.FragmentHandle handle = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::handle(this), target, stream);
  }

  // optional float network_cost = 4;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_network_cost(), target);
  }

  // optional float cpu_cost = 5;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_cpu_cost(), target);
  }

  // optional float disk_cost = 6;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_disk_cost(), target);
  }

  // optional float memory_cost = 7;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_memory_cost(), target);
  }

  // optional string fragment_json = 8;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_fragment_json().data(), static_cast<int>(this->_internal_fragment_json().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "exec.bit.control.PlanFragment.fragment_json");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_fragment_json(), target);
  }

  // optional bool leaf_fragment = 9;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_leaf_fragment(), target);
  }

  // optional .exec.DrillbitEndpoint assignment = 10;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::assignment(this), target, stream);
  }

  // optional .exec.DrillbitEndpoint foreman = 11;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::foreman(this), target, stream);
  }

  // optional int64 mem_initial = 12 [default = 20000000];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(12, this->_internal_mem_initial(), target);
  }

  // optional int64 mem_max = 13 [default = 2000000000];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(13, this->_internal_mem_max(), target);
  }

  // optional .exec.shared.UserCredentials credentials = 14;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        14, _Internal::credentials(this), target, stream);
  }

  // optional string options_json = 15;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_options_json().data(), static_cast<int>(this->_internal_options_json().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "exec.bit.control.PlanFragment.options_json");
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_options_json(), target);
  }

  // optional .exec.bit.control.QueryContextInformation context = 16;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        16, _Internal::context(this), target, stream);
  }

  // repeated .exec.bit.control.Collector collector = 17;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_collector_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, this->_internal_collector(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:exec.bit.control.PlanFragment)
  return target;
}

size_t PlanFragment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:exec.bit.control.PlanFragment)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .exec.bit.control.Collector collector = 17;
  total_size += 2UL * this->_internal_collector_size();
  for (const auto& msg : this->collector_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string fragment_json = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_fragment_json());
    }

    // optional string options_json = 15;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_options_json());
    }

    // optional .exec.bit.FragmentHandle handle = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *handle_);
    }

    // optional .exec.DrillbitEndpoint assignment = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *assignment_);
    }

    // optional .exec.DrillbitEndpoint foreman = 11;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *foreman_);
    }

    // optional .exec.shared.UserCredentials credentials = 14;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *credentials_);
    }

    // optional .exec.bit.control.QueryContextInformation context = 16;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *context_);
    }

    // optional float network_cost = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional float cpu_cost = 5;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float disk_cost = 6;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional float memory_cost = 7;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional bool leaf_fragment = 9;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional int64 mem_initial = 12 [default = 20000000];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_mem_initial());
    }

    // optional int64 mem_max = 13 [default = 2000000000];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_mem_max());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PlanFragment::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:exec.bit.control.PlanFragment)
  GOOGLE_DCHECK_NE(&from, this);
  const PlanFragment* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<PlanFragment>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:exec.bit.control.PlanFragment)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:exec.bit.control.PlanFragment)
    MergeFrom(*source);
  }
}

void PlanFragment::MergeFrom(const PlanFragment& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:exec.bit.control.PlanFragment)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  collector_.MergeFrom(from.collector_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_fragment_json(from._internal_fragment_json());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_options_json(from._internal_options_json());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_handle()->::exec::bit::FragmentHandle::MergeFrom(from._internal_handle());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_assignment()->::exec::DrillbitEndpoint::MergeFrom(from._internal_assignment());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_foreman()->::exec::DrillbitEndpoint::MergeFrom(from._internal_foreman());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_credentials()->::exec::shared::UserCredentials::MergeFrom(from._internal_credentials());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_context()->::exec::bit::control::QueryContextInformation::MergeFrom(from._internal_context());
    }
    if (cached_has_bits & 0x00000080u) {
      network_cost_ = from.network_cost_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      cpu_cost_ = from.cpu_cost_;
    }
    if (cached_has_bits & 0x00000200u) {
      disk_cost_ = from.disk_cost_;
    }
    if (cached_has_bits & 0x00000400u) {
      memory_cost_ = from.memory_cost_;
    }
    if (cached_has_bits & 0x00000800u) {
      leaf_fragment_ = from.leaf_fragment_;
    }
    if (cached_has_bits & 0x00001000u) {
      mem_initial_ = from.mem_initial_;
    }
    if (cached_has_bits & 0x00002000u) {
      mem_max_ = from.mem_max_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PlanFragment::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:exec.bit.control.PlanFragment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlanFragment::CopyFrom(const PlanFragment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:exec.bit.control.PlanFragment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlanFragment::IsInitialized() const {
  return true;
}

void PlanFragment::InternalSwap(PlanFragment* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  collector_.InternalSwap(&other->collector_);
  fragment_json_.Swap(&other->fragment_json_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  options_json_.Swap(&other->options_json_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlanFragment, leaf_fragment_)
      + sizeof(PlanFragment::leaf_fragment_)
      - PROTOBUF_FIELD_OFFSET(PlanFragment, handle_)>(
          reinterpret_cast<char*>(&handle_),
          reinterpret_cast<char*>(&other->handle_));
  swap(mem_initial_, other->mem_initial_);
  swap(mem_max_, other->mem_max_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlanFragment::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_BitControl_2eproto_getter, &descriptor_table_BitControl_2eproto_once,
      file_level_metadata_BitControl_2eproto[5]);
}

// ===================================================================

class Collector::_Internal {
 public:
  using HasBits = decltype(std::declval<Collector>()._has_bits_);
  static void set_has_opposite_major_fragment_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_supports_out_of_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_spooling(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_enable_dynamic_fc(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Collector::Collector(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  incoming_minor_fragment_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:exec.bit.control.Collector)
}
Collector::Collector(const Collector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      incoming_minor_fragment_(from.incoming_minor_fragment_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&opposite_major_fragment_id_, &from.opposite_major_fragment_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&enable_dynamic_fc_) -
    reinterpret_cast<char*>(&opposite_major_fragment_id_)) + sizeof(enable_dynamic_fc_));
  // @@protoc_insertion_point(copy_constructor:exec.bit.control.Collector)
}

void Collector::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&opposite_major_fragment_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&enable_dynamic_fc_) -
    reinterpret_cast<char*>(&opposite_major_fragment_id_)) + sizeof(enable_dynamic_fc_));
}

Collector::~Collector() {
  // @@protoc_insertion_point(destructor:exec.bit.control.Collector)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Collector::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Collector::ArenaDtor(void* object) {
  Collector* _this = reinterpret_cast< Collector* >(object);
  (void)_this;
}
void Collector::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Collector::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Collector::Clear() {
// @@protoc_insertion_point(message_clear_start:exec.bit.control.Collector)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  incoming_minor_fragment_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&opposite_major_fragment_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&enable_dynamic_fc_) -
        reinterpret_cast<char*>(&opposite_major_fragment_id_)) + sizeof(enable_dynamic_fc_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Collector::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 opposite_major_fragment_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_opposite_major_fragment_id(&has_bits);
          opposite_major_fragment_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 incoming_minor_fragment = 2 [packed = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_incoming_minor_fragment(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16) {
          _internal_add_incoming_minor_fragment(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool supports_out_of_order = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_supports_out_of_order(&has_bits);
          supports_out_of_order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_spooling = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_is_spooling(&has_bits);
          is_spooling_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool enable_dynamic_fc = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_enable_dynamic_fc(&has_bits);
          enable_dynamic_fc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Collector::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:exec.bit.control.Collector)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 opposite_major_fragment_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_opposite_major_fragment_id(), target);
  }

  // repeated int32 incoming_minor_fragment = 2 [packed = true];
  {
    int byte_size = _incoming_minor_fragment_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          2, _internal_incoming_minor_fragment(), byte_size, target);
    }
  }

  // optional bool supports_out_of_order = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_supports_out_of_order(), target);
  }

  // optional bool is_spooling = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_is_spooling(), target);
  }

  // optional bool enable_dynamic_fc = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_enable_dynamic_fc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:exec.bit.control.Collector)
  return target;
}

size_t Collector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:exec.bit.control.Collector)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 incoming_minor_fragment = 2 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->incoming_minor_fragment_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _incoming_minor_fragment_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 opposite_major_fragment_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_opposite_major_fragment_id());
    }

    // optional bool supports_out_of_order = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool is_spooling = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool enable_dynamic_fc = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Collector::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:exec.bit.control.Collector)
  GOOGLE_DCHECK_NE(&from, this);
  const Collector* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Collector>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:exec.bit.control.Collector)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:exec.bit.control.Collector)
    MergeFrom(*source);
  }
}

void Collector::MergeFrom(const Collector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:exec.bit.control.Collector)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  incoming_minor_fragment_.MergeFrom(from.incoming_minor_fragment_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      opposite_major_fragment_id_ = from.opposite_major_fragment_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      supports_out_of_order_ = from.supports_out_of_order_;
    }
    if (cached_has_bits & 0x00000004u) {
      is_spooling_ = from.is_spooling_;
    }
    if (cached_has_bits & 0x00000008u) {
      enable_dynamic_fc_ = from.enable_dynamic_fc_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Collector::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:exec.bit.control.Collector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Collector::CopyFrom(const Collector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:exec.bit.control.Collector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Collector::IsInitialized() const {
  return true;
}

void Collector::InternalSwap(Collector* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  incoming_minor_fragment_.InternalSwap(&other->incoming_minor_fragment_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Collector, enable_dynamic_fc_)
      + sizeof(Collector::enable_dynamic_fc_)
      - PROTOBUF_FIELD_OFFSET(Collector, opposite_major_fragment_id_)>(
          reinterpret_cast<char*>(&opposite_major_fragment_id_),
          reinterpret_cast<char*>(&other->opposite_major_fragment_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Collector::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_BitControl_2eproto_getter, &descriptor_table_BitControl_2eproto_once,
      file_level_metadata_BitControl_2eproto[6]);
}

// ===================================================================

class QueryContextInformation::_Internal {
 public:
  using HasBits = decltype(std::declval<QueryContextInformation>()._has_bits_);
  static void set_has_query_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_time_zone(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_default_schema_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

QueryContextInformation::QueryContextInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:exec.bit.control.QueryContextInformation)
}
QueryContextInformation::QueryContextInformation(const QueryContextInformation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  default_schema_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_default_schema_name()) {
    default_schema_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_default_schema_name(), 
      GetArena());
  }
  session_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_session_id()) {
    session_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_session_id(), 
      GetArena());
  }
  ::memcpy(&query_start_time_, &from.query_start_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&time_zone_) -
    reinterpret_cast<char*>(&query_start_time_)) + sizeof(time_zone_));
  // @@protoc_insertion_point(copy_constructor:exec.bit.control.QueryContextInformation)
}

void QueryContextInformation::SharedCtor() {
default_schema_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
session_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&query_start_time_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&time_zone_) -
    reinterpret_cast<char*>(&query_start_time_)) + sizeof(time_zone_));
}

QueryContextInformation::~QueryContextInformation() {
  // @@protoc_insertion_point(destructor:exec.bit.control.QueryContextInformation)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void QueryContextInformation::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  default_schema_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  session_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void QueryContextInformation::ArenaDtor(void* object) {
  QueryContextInformation* _this = reinterpret_cast< QueryContextInformation* >(object);
  (void)_this;
}
void QueryContextInformation::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void QueryContextInformation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void QueryContextInformation::Clear() {
// @@protoc_insertion_point(message_clear_start:exec.bit.control.QueryContextInformation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      default_schema_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      session_id_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&query_start_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&time_zone_) -
        reinterpret_cast<char*>(&query_start_time_)) + sizeof(time_zone_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QueryContextInformation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 query_start_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_query_start_time(&has_bits);
          query_start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 time_zone = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_time_zone(&has_bits);
          time_zone_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string default_schema_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_default_schema_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "exec.bit.control.QueryContextInformation.default_schema_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string session_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_session_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "exec.bit.control.QueryContextInformation.session_id");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* QueryContextInformation::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:exec.bit.control.QueryContextInformation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 query_start_time = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_query_start_time(), target);
  }

  // optional int32 time_zone = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_time_zone(), target);
  }

  // optional string default_schema_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_default_schema_name().data(), static_cast<int>(this->_internal_default_schema_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "exec.bit.control.QueryContextInformation.default_schema_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_default_schema_name(), target);
  }

  // optional string session_id = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_session_id().data(), static_cast<int>(this->_internal_session_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "exec.bit.control.QueryContextInformation.session_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_session_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:exec.bit.control.QueryContextInformation)
  return target;
}

size_t QueryContextInformation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:exec.bit.control.QueryContextInformation)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string default_schema_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_default_schema_name());
    }

    // optional string session_id = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_session_id());
    }

    // optional int64 query_start_time = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_query_start_time());
    }

    // optional int32 time_zone = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_time_zone());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void QueryContextInformation::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:exec.bit.control.QueryContextInformation)
  GOOGLE_DCHECK_NE(&from, this);
  const QueryContextInformation* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<QueryContextInformation>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:exec.bit.control.QueryContextInformation)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:exec.bit.control.QueryContextInformation)
    MergeFrom(*source);
  }
}

void QueryContextInformation::MergeFrom(const QueryContextInformation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:exec.bit.control.QueryContextInformation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_default_schema_name(from._internal_default_schema_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_session_id(from._internal_session_id());
    }
    if (cached_has_bits & 0x00000004u) {
      query_start_time_ = from.query_start_time_;
    }
    if (cached_has_bits & 0x00000008u) {
      time_zone_ = from.time_zone_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void QueryContextInformation::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:exec.bit.control.QueryContextInformation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void QueryContextInformation::CopyFrom(const QueryContextInformation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:exec.bit.control.QueryContextInformation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QueryContextInformation::IsInitialized() const {
  return true;
}

void QueryContextInformation::InternalSwap(QueryContextInformation* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  default_schema_name_.Swap(&other->default_schema_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  session_id_.Swap(&other->session_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QueryContextInformation, time_zone_)
      + sizeof(QueryContextInformation::time_zone_)
      - PROTOBUF_FIELD_OFFSET(QueryContextInformation, query_start_time_)>(
          reinterpret_cast<char*>(&query_start_time_),
          reinterpret_cast<char*>(&other->query_start_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata QueryContextInformation::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_BitControl_2eproto_getter, &descriptor_table_BitControl_2eproto_once,
      file_level_metadata_BitControl_2eproto[7]);
}

// ===================================================================

class WorkQueueStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<WorkQueueStatus>()._has_bits_);
  static const ::exec::DrillbitEndpoint& endpoint(const WorkQueueStatus* msg);
  static void set_has_endpoint(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_queue_length(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_report_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::exec::DrillbitEndpoint&
WorkQueueStatus::_Internal::endpoint(const WorkQueueStatus* msg) {
  return *msg->endpoint_;
}
void WorkQueueStatus::clear_endpoint() {
  if (endpoint_ != nullptr) endpoint_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
WorkQueueStatus::WorkQueueStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:exec.bit.control.WorkQueueStatus)
}
WorkQueueStatus::WorkQueueStatus(const WorkQueueStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_endpoint()) {
    endpoint_ = new ::exec::DrillbitEndpoint(*from.endpoint_);
  } else {
    endpoint_ = nullptr;
  }
  ::memcpy(&report_time_, &from.report_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&queue_length_) -
    reinterpret_cast<char*>(&report_time_)) + sizeof(queue_length_));
  // @@protoc_insertion_point(copy_constructor:exec.bit.control.WorkQueueStatus)
}

void WorkQueueStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&endpoint_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&queue_length_) -
    reinterpret_cast<char*>(&endpoint_)) + sizeof(queue_length_));
}

WorkQueueStatus::~WorkQueueStatus() {
  // @@protoc_insertion_point(destructor:exec.bit.control.WorkQueueStatus)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void WorkQueueStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete endpoint_;
}

void WorkQueueStatus::ArenaDtor(void* object) {
  WorkQueueStatus* _this = reinterpret_cast< WorkQueueStatus* >(object);
  (void)_this;
}
void WorkQueueStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WorkQueueStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WorkQueueStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:exec.bit.control.WorkQueueStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(endpoint_ != nullptr);
    endpoint_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&report_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&queue_length_) -
        reinterpret_cast<char*>(&report_time_)) + sizeof(queue_length_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WorkQueueStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .exec.DrillbitEndpoint endpoint = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_endpoint(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 queue_length = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_queue_length(&has_bits);
          queue_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 report_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_report_time(&has_bits);
          report_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* WorkQueueStatus::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:exec.bit.control.WorkQueueStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .exec.DrillbitEndpoint endpoint = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::endpoint(this), target, stream);
  }

  // optional int32 queue_length = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_queue_length(), target);
  }

  // optional int64 report_time = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_report_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:exec.bit.control.WorkQueueStatus)
  return target;
}

size_t WorkQueueStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:exec.bit.control.WorkQueueStatus)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .exec.DrillbitEndpoint endpoint = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *endpoint_);
    }

    // optional int64 report_time = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_report_time());
    }

    // optional int32 queue_length = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_queue_length());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WorkQueueStatus::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:exec.bit.control.WorkQueueStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const WorkQueueStatus* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<WorkQueueStatus>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:exec.bit.control.WorkQueueStatus)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:exec.bit.control.WorkQueueStatus)
    MergeFrom(*source);
  }
}

void WorkQueueStatus::MergeFrom(const WorkQueueStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:exec.bit.control.WorkQueueStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_endpoint()->::exec::DrillbitEndpoint::MergeFrom(from._internal_endpoint());
    }
    if (cached_has_bits & 0x00000002u) {
      report_time_ = from.report_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      queue_length_ = from.queue_length_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void WorkQueueStatus::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:exec.bit.control.WorkQueueStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WorkQueueStatus::CopyFrom(const WorkQueueStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:exec.bit.control.WorkQueueStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WorkQueueStatus::IsInitialized() const {
  return true;
}

void WorkQueueStatus::InternalSwap(WorkQueueStatus* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WorkQueueStatus, queue_length_)
      + sizeof(WorkQueueStatus::queue_length_)
      - PROTOBUF_FIELD_OFFSET(WorkQueueStatus, endpoint_)>(
          reinterpret_cast<char*>(&endpoint_),
          reinterpret_cast<char*>(&other->endpoint_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WorkQueueStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_BitControl_2eproto_getter, &descriptor_table_BitControl_2eproto_once,
      file_level_metadata_BitControl_2eproto[8]);
}

// ===================================================================

class FinishedReceiver::_Internal {
 public:
  using HasBits = decltype(std::declval<FinishedReceiver>()._has_bits_);
  static const ::exec::bit::FragmentHandle& receiver(const FinishedReceiver* msg);
  static void set_has_receiver(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::exec::bit::FragmentHandle& sender(const FinishedReceiver* msg);
  static void set_has_sender(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::exec::bit::FragmentHandle&
FinishedReceiver::_Internal::receiver(const FinishedReceiver* msg) {
  return *msg->receiver_;
}
const ::exec::bit::FragmentHandle&
FinishedReceiver::_Internal::sender(const FinishedReceiver* msg) {
  return *msg->sender_;
}
void FinishedReceiver::clear_receiver() {
  if (receiver_ != nullptr) receiver_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void FinishedReceiver::clear_sender() {
  if (sender_ != nullptr) sender_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
FinishedReceiver::FinishedReceiver(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:exec.bit.control.FinishedReceiver)
}
FinishedReceiver::FinishedReceiver(const FinishedReceiver& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_receiver()) {
    receiver_ = new ::exec::bit::FragmentHandle(*from.receiver_);
  } else {
    receiver_ = nullptr;
  }
  if (from._internal_has_sender()) {
    sender_ = new ::exec::bit::FragmentHandle(*from.sender_);
  } else {
    sender_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:exec.bit.control.FinishedReceiver)
}

void FinishedReceiver::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&receiver_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&sender_) -
    reinterpret_cast<char*>(&receiver_)) + sizeof(sender_));
}

FinishedReceiver::~FinishedReceiver() {
  // @@protoc_insertion_point(destructor:exec.bit.control.FinishedReceiver)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void FinishedReceiver::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete receiver_;
  if (this != internal_default_instance()) delete sender_;
}

void FinishedReceiver::ArenaDtor(void* object) {
  FinishedReceiver* _this = reinterpret_cast< FinishedReceiver* >(object);
  (void)_this;
}
void FinishedReceiver::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FinishedReceiver::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FinishedReceiver::Clear() {
// @@protoc_insertion_point(message_clear_start:exec.bit.control.FinishedReceiver)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(receiver_ != nullptr);
      receiver_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(sender_ != nullptr);
      sender_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FinishedReceiver::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .exec.bit.FragmentHandle receiver = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_receiver(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .exec.bit.FragmentHandle sender = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_sender(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FinishedReceiver::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:exec.bit.control.FinishedReceiver)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .exec.bit.FragmentHandle receiver = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::receiver(this), target, stream);
  }

  // optional .exec.bit.FragmentHandle sender = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::sender(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:exec.bit.control.FinishedReceiver)
  return target;
}

size_t FinishedReceiver::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:exec.bit.control.FinishedReceiver)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .exec.bit.FragmentHandle receiver = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *receiver_);
    }

    // optional .exec.bit.FragmentHandle sender = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *sender_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FinishedReceiver::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:exec.bit.control.FinishedReceiver)
  GOOGLE_DCHECK_NE(&from, this);
  const FinishedReceiver* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FinishedReceiver>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:exec.bit.control.FinishedReceiver)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:exec.bit.control.FinishedReceiver)
    MergeFrom(*source);
  }
}

void FinishedReceiver::MergeFrom(const FinishedReceiver& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:exec.bit.control.FinishedReceiver)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_receiver()->::exec::bit::FragmentHandle::MergeFrom(from._internal_receiver());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_sender()->::exec::bit::FragmentHandle::MergeFrom(from._internal_sender());
    }
  }
}

void FinishedReceiver::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:exec.bit.control.FinishedReceiver)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FinishedReceiver::CopyFrom(const FinishedReceiver& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:exec.bit.control.FinishedReceiver)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FinishedReceiver::IsInitialized() const {
  return true;
}

void FinishedReceiver::InternalSwap(FinishedReceiver* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FinishedReceiver, sender_)
      + sizeof(FinishedReceiver::sender_)
      - PROTOBUF_FIELD_OFFSET(FinishedReceiver, receiver_)>(
          reinterpret_cast<char*>(&receiver_),
          reinterpret_cast<char*>(&other->receiver_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FinishedReceiver::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_BitControl_2eproto_getter, &descriptor_table_BitControl_2eproto_once,
      file_level_metadata_BitControl_2eproto[9]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace control
}  // namespace bit
}  // namespace exec
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::exec::bit::control::BitControlHandshake* Arena::CreateMaybeMessage< ::exec::bit::control::BitControlHandshake >(Arena* arena) {
  return Arena::CreateMessageInternal< ::exec::bit::control::BitControlHandshake >(arena);
}
template<> PROTOBUF_NOINLINE ::exec::bit::control::BitStatus* Arena::CreateMaybeMessage< ::exec::bit::control::BitStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::exec::bit::control::BitStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::exec::bit::control::FragmentStatus* Arena::CreateMaybeMessage< ::exec::bit::control::FragmentStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::exec::bit::control::FragmentStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::exec::bit::control::InitializeFragments* Arena::CreateMaybeMessage< ::exec::bit::control::InitializeFragments >(Arena* arena) {
  return Arena::CreateMessageInternal< ::exec::bit::control::InitializeFragments >(arena);
}
template<> PROTOBUF_NOINLINE ::exec::bit::control::CustomMessage* Arena::CreateMaybeMessage< ::exec::bit::control::CustomMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::exec::bit::control::CustomMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::exec::bit::control::PlanFragment* Arena::CreateMaybeMessage< ::exec::bit::control::PlanFragment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::exec::bit::control::PlanFragment >(arena);
}
template<> PROTOBUF_NOINLINE ::exec::bit::control::Collector* Arena::CreateMaybeMessage< ::exec::bit::control::Collector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::exec::bit::control::Collector >(arena);
}
template<> PROTOBUF_NOINLINE ::exec::bit::control::QueryContextInformation* Arena::CreateMaybeMessage< ::exec::bit::control::QueryContextInformation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::exec::bit::control::QueryContextInformation >(arena);
}
template<> PROTOBUF_NOINLINE ::exec::bit::control::WorkQueueStatus* Arena::CreateMaybeMessage< ::exec::bit::control::WorkQueueStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::exec::bit::control::WorkQueueStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::exec::bit::control::FinishedReceiver* Arena::CreateMaybeMessage< ::exec::bit::control::FinishedReceiver >(Arena* arena) {
  return Arena::CreateMessageInternal< ::exec::bit::control::FinishedReceiver >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
