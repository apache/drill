// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: User.proto

#ifndef PROTOBUF_User_2eproto__INCLUDED
#define PROTOBUF_User_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "SchemaDef.pb.h"
#include "Types.pb.h"
#include "UserBitShared.pb.h"
#include "BitData.pb.h"
#include "BitControl.pb.h"
#include "ExecutionProtos.pb.h"
// @@protoc_insertion_point(includes)

namespace exec {
namespace user {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_User_2eproto();
void protobuf_AssignDesc_User_2eproto();
void protobuf_ShutdownFile_User_2eproto();

class Property;
class UserProperties;
class RpcEndpointInfos;
class UserToBitHandshake;
class RequestResults;
class GetQueryPlanFragments;
class QueryPlanFragments;
class BitToUserHandshake;
class LikeFilter;
class GetCatalogsReq;
class CatalogMetadata;
class GetCatalogsResp;
class GetSchemasReq;
class SchemaMetadata;
class GetSchemasResp;
class GetTablesReq;
class TableMetadata;
class GetTablesResp;
class GetColumnsReq;
class ColumnMetadata;
class GetColumnsResp;
class CreatePreparedStatementReq;
class ResultColumnMetadata;
class PreparedStatementHandle;
class PreparedStatement;
class CreatePreparedStatementResp;
class GetServerMetaReq;
class ConvertSupport;
class GetServerMetaResp;
class ServerMeta;
class RunQuery;

enum RpcType {
  HANDSHAKE = 0,
  ACK = 1,
  GOODBYE = 2,
  RUN_QUERY = 3,
  CANCEL_QUERY = 4,
  REQUEST_RESULTS = 5,
  RESUME_PAUSED_QUERY = 11,
  GET_QUERY_PLAN_FRAGMENTS = 12,
  GET_CATALOGS = 14,
  GET_SCHEMAS = 15,
  GET_TABLES = 16,
  GET_COLUMNS = 17,
  CREATE_PREPARED_STATEMENT = 22,
  GET_SERVER_META = 8,
  QUERY_DATA = 6,
  QUERY_HANDLE = 7,
  QUERY_PLAN_FRAGMENTS = 13,
  CATALOGS = 18,
  SCHEMAS = 19,
  TABLES = 20,
  COLUMNS = 21,
  PREPARED_STATEMENT = 23,
  SERVER_META = 9,
  QUERY_RESULT = 10,
  SASL_MESSAGE = 24
};
bool RpcType_IsValid(int value);
const RpcType RpcType_MIN = HANDSHAKE;
const RpcType RpcType_MAX = SASL_MESSAGE;
const int RpcType_ARRAYSIZE = RpcType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpcType_descriptor();
inline const ::std::string& RpcType_Name(RpcType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpcType_descriptor(), value);
}
inline bool RpcType_Parse(
    const ::std::string& name, RpcType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcType>(
    RpcType_descriptor(), name, value);
}
enum SaslSupport {
  UNKNOWN_SASL_SUPPORT = 0,
  SASL_AUTH = 1,
  SASL_PRIVACY = 2
};
bool SaslSupport_IsValid(int value);
const SaslSupport SaslSupport_MIN = UNKNOWN_SASL_SUPPORT;
const SaslSupport SaslSupport_MAX = SASL_PRIVACY;
const int SaslSupport_ARRAYSIZE = SaslSupport_MAX + 1;

const ::google::protobuf::EnumDescriptor* SaslSupport_descriptor();
inline const ::std::string& SaslSupport_Name(SaslSupport value) {
  return ::google::protobuf::internal::NameOfEnum(
    SaslSupport_descriptor(), value);
}
inline bool SaslSupport_Parse(
    const ::std::string& name, SaslSupport* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SaslSupport>(
    SaslSupport_descriptor(), name, value);
}
enum QueryResultsMode {
  STREAM_FULL = 1
};
bool QueryResultsMode_IsValid(int value);
const QueryResultsMode QueryResultsMode_MIN = STREAM_FULL;
const QueryResultsMode QueryResultsMode_MAX = STREAM_FULL;
const int QueryResultsMode_ARRAYSIZE = QueryResultsMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* QueryResultsMode_descriptor();
inline const ::std::string& QueryResultsMode_Name(QueryResultsMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    QueryResultsMode_descriptor(), value);
}
inline bool QueryResultsMode_Parse(
    const ::std::string& name, QueryResultsMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QueryResultsMode>(
    QueryResultsMode_descriptor(), name, value);
}
enum HandshakeStatus {
  SUCCESS = 1,
  RPC_VERSION_MISMATCH = 2,
  AUTH_FAILED = 3,
  UNKNOWN_FAILURE = 4,
  AUTH_REQUIRED = 5
};
bool HandshakeStatus_IsValid(int value);
const HandshakeStatus HandshakeStatus_MIN = SUCCESS;
const HandshakeStatus HandshakeStatus_MAX = AUTH_REQUIRED;
const int HandshakeStatus_ARRAYSIZE = HandshakeStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* HandshakeStatus_descriptor();
inline const ::std::string& HandshakeStatus_Name(HandshakeStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    HandshakeStatus_descriptor(), value);
}
inline bool HandshakeStatus_Parse(
    const ::std::string& name, HandshakeStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HandshakeStatus>(
    HandshakeStatus_descriptor(), name, value);
}
enum RequestStatus {
  UNKNOWN_STATUS = 0,
  OK = 1,
  FAILED = 2,
  TIMEOUT = 3
};
bool RequestStatus_IsValid(int value);
const RequestStatus RequestStatus_MIN = UNKNOWN_STATUS;
const RequestStatus RequestStatus_MAX = TIMEOUT;
const int RequestStatus_ARRAYSIZE = RequestStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* RequestStatus_descriptor();
inline const ::std::string& RequestStatus_Name(RequestStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    RequestStatus_descriptor(), value);
}
inline bool RequestStatus_Parse(
    const ::std::string& name, RequestStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestStatus>(
    RequestStatus_descriptor(), name, value);
}
enum ColumnSearchability {
  UNKNOWN_SEARCHABILITY = 0,
  NONE = 1,
  CHAR = 2,
  NUMBER = 3,
  ALL = 4
};
bool ColumnSearchability_IsValid(int value);
const ColumnSearchability ColumnSearchability_MIN = UNKNOWN_SEARCHABILITY;
const ColumnSearchability ColumnSearchability_MAX = ALL;
const int ColumnSearchability_ARRAYSIZE = ColumnSearchability_MAX + 1;

const ::google::protobuf::EnumDescriptor* ColumnSearchability_descriptor();
inline const ::std::string& ColumnSearchability_Name(ColumnSearchability value) {
  return ::google::protobuf::internal::NameOfEnum(
    ColumnSearchability_descriptor(), value);
}
inline bool ColumnSearchability_Parse(
    const ::std::string& name, ColumnSearchability* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ColumnSearchability>(
    ColumnSearchability_descriptor(), name, value);
}
enum ColumnUpdatability {
  UNKNOWN_UPDATABILITY = 0,
  READ_ONLY = 1,
  WRITABLE = 2
};
bool ColumnUpdatability_IsValid(int value);
const ColumnUpdatability ColumnUpdatability_MIN = UNKNOWN_UPDATABILITY;
const ColumnUpdatability ColumnUpdatability_MAX = WRITABLE;
const int ColumnUpdatability_ARRAYSIZE = ColumnUpdatability_MAX + 1;

const ::google::protobuf::EnumDescriptor* ColumnUpdatability_descriptor();
inline const ::std::string& ColumnUpdatability_Name(ColumnUpdatability value) {
  return ::google::protobuf::internal::NameOfEnum(
    ColumnUpdatability_descriptor(), value);
}
inline bool ColumnUpdatability_Parse(
    const ::std::string& name, ColumnUpdatability* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ColumnUpdatability>(
    ColumnUpdatability_descriptor(), name, value);
}
enum CollateSupport {
  CS_UNKNOWN = 0,
  CS_GROUP_BY = 1
};
bool CollateSupport_IsValid(int value);
const CollateSupport CollateSupport_MIN = CS_UNKNOWN;
const CollateSupport CollateSupport_MAX = CS_GROUP_BY;
const int CollateSupport_ARRAYSIZE = CollateSupport_MAX + 1;

const ::google::protobuf::EnumDescriptor* CollateSupport_descriptor();
inline const ::std::string& CollateSupport_Name(CollateSupport value) {
  return ::google::protobuf::internal::NameOfEnum(
    CollateSupport_descriptor(), value);
}
inline bool CollateSupport_Parse(
    const ::std::string& name, CollateSupport* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CollateSupport>(
    CollateSupport_descriptor(), name, value);
}
enum CorrelationNamesSupport {
  CN_NONE = 1,
  CN_DIFFERENT_NAMES = 2,
  CN_ANY = 3
};
bool CorrelationNamesSupport_IsValid(int value);
const CorrelationNamesSupport CorrelationNamesSupport_MIN = CN_NONE;
const CorrelationNamesSupport CorrelationNamesSupport_MAX = CN_ANY;
const int CorrelationNamesSupport_ARRAYSIZE = CorrelationNamesSupport_MAX + 1;

const ::google::protobuf::EnumDescriptor* CorrelationNamesSupport_descriptor();
inline const ::std::string& CorrelationNamesSupport_Name(CorrelationNamesSupport value) {
  return ::google::protobuf::internal::NameOfEnum(
    CorrelationNamesSupport_descriptor(), value);
}
inline bool CorrelationNamesSupport_Parse(
    const ::std::string& name, CorrelationNamesSupport* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CorrelationNamesSupport>(
    CorrelationNamesSupport_descriptor(), name, value);
}
enum DateTimeLiteralsSupport {
  DL_UNKNOWN = 0,
  DL_DATE = 1,
  DL_TIME = 2,
  DL_TIMESTAMP = 3,
  DL_INTERVAL_YEAR = 4,
  DL_INTERVAL_MONTH = 5,
  DL_INTERVAL_DAY = 6,
  DL_INTERVAL_HOUR = 7,
  DL_INTERVAL_MINUTE = 8,
  DL_INTERVAL_SECOND = 9,
  DL_INTERVAL_YEAR_TO_MONTH = 10,
  DL_INTERVAL_DAY_TO_HOUR = 11,
  DL_INTERVAL_DAY_TO_MINUTE = 12,
  DL_INTERVAL_DAY_TO_SECOND = 13,
  DL_INTERVAL_HOUR_TO_MINUTE = 14,
  DL_INTERVAL_HOUR_TO_SECOND = 15,
  DL_INTERVAL_MINUTE_TO_SECOND = 16
};
bool DateTimeLiteralsSupport_IsValid(int value);
const DateTimeLiteralsSupport DateTimeLiteralsSupport_MIN = DL_UNKNOWN;
const DateTimeLiteralsSupport DateTimeLiteralsSupport_MAX = DL_INTERVAL_MINUTE_TO_SECOND;
const int DateTimeLiteralsSupport_ARRAYSIZE = DateTimeLiteralsSupport_MAX + 1;

const ::google::protobuf::EnumDescriptor* DateTimeLiteralsSupport_descriptor();
inline const ::std::string& DateTimeLiteralsSupport_Name(DateTimeLiteralsSupport value) {
  return ::google::protobuf::internal::NameOfEnum(
    DateTimeLiteralsSupport_descriptor(), value);
}
inline bool DateTimeLiteralsSupport_Parse(
    const ::std::string& name, DateTimeLiteralsSupport* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DateTimeLiteralsSupport>(
    DateTimeLiteralsSupport_descriptor(), name, value);
}
enum GroupBySupport {
  GB_NONE = 1,
  GB_SELECT_ONLY = 2,
  GB_BEYOND_SELECT = 3,
  GB_UNRELATED = 4
};
bool GroupBySupport_IsValid(int value);
const GroupBySupport GroupBySupport_MIN = GB_NONE;
const GroupBySupport GroupBySupport_MAX = GB_UNRELATED;
const int GroupBySupport_ARRAYSIZE = GroupBySupport_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupBySupport_descriptor();
inline const ::std::string& GroupBySupport_Name(GroupBySupport value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupBySupport_descriptor(), value);
}
inline bool GroupBySupport_Parse(
    const ::std::string& name, GroupBySupport* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupBySupport>(
    GroupBySupport_descriptor(), name, value);
}
enum IdentifierCasing {
  IC_UNKNOWN = 0,
  IC_STORES_LOWER = 1,
  IC_STORES_MIXED = 2,
  IC_STORES_UPPER = 3,
  IC_SUPPORTS_MIXED = 4
};
bool IdentifierCasing_IsValid(int value);
const IdentifierCasing IdentifierCasing_MIN = IC_UNKNOWN;
const IdentifierCasing IdentifierCasing_MAX = IC_SUPPORTS_MIXED;
const int IdentifierCasing_ARRAYSIZE = IdentifierCasing_MAX + 1;

const ::google::protobuf::EnumDescriptor* IdentifierCasing_descriptor();
inline const ::std::string& IdentifierCasing_Name(IdentifierCasing value) {
  return ::google::protobuf::internal::NameOfEnum(
    IdentifierCasing_descriptor(), value);
}
inline bool IdentifierCasing_Parse(
    const ::std::string& name, IdentifierCasing* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IdentifierCasing>(
    IdentifierCasing_descriptor(), name, value);
}
enum NullCollation {
  NC_UNKNOWN = 0,
  NC_AT_START = 1,
  NC_AT_END = 2,
  NC_HIGH = 3,
  NC_LOW = 4
};
bool NullCollation_IsValid(int value);
const NullCollation NullCollation_MIN = NC_UNKNOWN;
const NullCollation NullCollation_MAX = NC_LOW;
const int NullCollation_ARRAYSIZE = NullCollation_MAX + 1;

const ::google::protobuf::EnumDescriptor* NullCollation_descriptor();
inline const ::std::string& NullCollation_Name(NullCollation value) {
  return ::google::protobuf::internal::NameOfEnum(
    NullCollation_descriptor(), value);
}
inline bool NullCollation_Parse(
    const ::std::string& name, NullCollation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NullCollation>(
    NullCollation_descriptor(), name, value);
}
enum OrderBySupport {
  OB_UNKNOWN = 0,
  OB_UNRELATED = 1,
  OB_EXPRESSION = 2
};
bool OrderBySupport_IsValid(int value);
const OrderBySupport OrderBySupport_MIN = OB_UNKNOWN;
const OrderBySupport OrderBySupport_MAX = OB_EXPRESSION;
const int OrderBySupport_ARRAYSIZE = OrderBySupport_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderBySupport_descriptor();
inline const ::std::string& OrderBySupport_Name(OrderBySupport value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderBySupport_descriptor(), value);
}
inline bool OrderBySupport_Parse(
    const ::std::string& name, OrderBySupport* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderBySupport>(
    OrderBySupport_descriptor(), name, value);
}
enum OuterJoinSupport {
  OJ_UNKNOWN = 0,
  OJ_LEFT = 1,
  OJ_RIGHT = 2,
  OJ_FULL = 3,
  OJ_NESTED = 4,
  OJ_NOT_ORDERED = 5,
  OJ_INNER = 6,
  OJ_ALL_COMPARISON_OPS = 7
};
bool OuterJoinSupport_IsValid(int value);
const OuterJoinSupport OuterJoinSupport_MIN = OJ_UNKNOWN;
const OuterJoinSupport OuterJoinSupport_MAX = OJ_ALL_COMPARISON_OPS;
const int OuterJoinSupport_ARRAYSIZE = OuterJoinSupport_MAX + 1;

const ::google::protobuf::EnumDescriptor* OuterJoinSupport_descriptor();
inline const ::std::string& OuterJoinSupport_Name(OuterJoinSupport value) {
  return ::google::protobuf::internal::NameOfEnum(
    OuterJoinSupport_descriptor(), value);
}
inline bool OuterJoinSupport_Parse(
    const ::std::string& name, OuterJoinSupport* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OuterJoinSupport>(
    OuterJoinSupport_descriptor(), name, value);
}
enum SubQuerySupport {
  SQ_UNKNOWN = 0,
  SQ_CORRELATED = 1,
  SQ_IN_COMPARISON = 2,
  SQ_IN_EXISTS = 3,
  SQ_IN_INSERT = 4,
  SQ_IN_QUANTIFIED = 5
};
bool SubQuerySupport_IsValid(int value);
const SubQuerySupport SubQuerySupport_MIN = SQ_UNKNOWN;
const SubQuerySupport SubQuerySupport_MAX = SQ_IN_QUANTIFIED;
const int SubQuerySupport_ARRAYSIZE = SubQuerySupport_MAX + 1;

const ::google::protobuf::EnumDescriptor* SubQuerySupport_descriptor();
inline const ::std::string& SubQuerySupport_Name(SubQuerySupport value) {
  return ::google::protobuf::internal::NameOfEnum(
    SubQuerySupport_descriptor(), value);
}
inline bool SubQuerySupport_Parse(
    const ::std::string& name, SubQuerySupport* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SubQuerySupport>(
    SubQuerySupport_descriptor(), name, value);
}
enum UnionSupport {
  U_UNKNOWN = 0,
  U_UNION = 1,
  U_UNION_ALL = 2
};
bool UnionSupport_IsValid(int value);
const UnionSupport UnionSupport_MIN = U_UNKNOWN;
const UnionSupport UnionSupport_MAX = U_UNION_ALL;
const int UnionSupport_ARRAYSIZE = UnionSupport_MAX + 1;

const ::google::protobuf::EnumDescriptor* UnionSupport_descriptor();
inline const ::std::string& UnionSupport_Name(UnionSupport value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnionSupport_descriptor(), value);
}
inline bool UnionSupport_Parse(
    const ::std::string& name, UnionSupport* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnionSupport>(
    UnionSupport_descriptor(), name, value);
}
// ===================================================================

class Property : public ::google::protobuf::Message {
 public:
  Property();
  virtual ~Property();

  Property(const Property& from);

  inline Property& operator=(const Property& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Property& default_instance();

  void Swap(Property* other);

  // implements Message ----------------------------------------------

  Property* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Property& from);
  void MergeFrom(const Property& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:exec.user.Property)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static Property* default_instance_;
};
// -------------------------------------------------------------------

class UserProperties : public ::google::protobuf::Message {
 public:
  UserProperties();
  virtual ~UserProperties();

  UserProperties(const UserProperties& from);

  inline UserProperties& operator=(const UserProperties& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserProperties& default_instance();

  void Swap(UserProperties* other);

  // implements Message ----------------------------------------------

  UserProperties* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserProperties& from);
  void MergeFrom(const UserProperties& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .exec.user.Property properties = 1;
  inline int properties_size() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 1;
  inline const ::exec::user::Property& properties(int index) const;
  inline ::exec::user::Property* mutable_properties(int index);
  inline ::exec::user::Property* add_properties();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::user::Property >&
      properties() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::user::Property >*
      mutable_properties();

  // @@protoc_insertion_point(class_scope:exec.user.UserProperties)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::exec::user::Property > properties_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static UserProperties* default_instance_;
};
// -------------------------------------------------------------------

class RpcEndpointInfos : public ::google::protobuf::Message {
 public:
  RpcEndpointInfos();
  virtual ~RpcEndpointInfos();

  RpcEndpointInfos(const RpcEndpointInfos& from);

  inline RpcEndpointInfos& operator=(const RpcEndpointInfos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpcEndpointInfos& default_instance();

  void Swap(RpcEndpointInfos* other);

  // implements Message ----------------------------------------------

  RpcEndpointInfos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpcEndpointInfos& from);
  void MergeFrom(const RpcEndpointInfos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional uint32 majorVersion = 3;
  inline bool has_majorversion() const;
  inline void clear_majorversion();
  static const int kMajorVersionFieldNumber = 3;
  inline ::google::protobuf::uint32 majorversion() const;
  inline void set_majorversion(::google::protobuf::uint32 value);

  // optional uint32 minorVersion = 4;
  inline bool has_minorversion() const;
  inline void clear_minorversion();
  static const int kMinorVersionFieldNumber = 4;
  inline ::google::protobuf::uint32 minorversion() const;
  inline void set_minorversion(::google::protobuf::uint32 value);

  // optional uint32 patchVersion = 5;
  inline bool has_patchversion() const;
  inline void clear_patchversion();
  static const int kPatchVersionFieldNumber = 5;
  inline ::google::protobuf::uint32 patchversion() const;
  inline void set_patchversion(::google::protobuf::uint32 value);

  // optional string application = 6;
  inline bool has_application() const;
  inline void clear_application();
  static const int kApplicationFieldNumber = 6;
  inline const ::std::string& application() const;
  inline void set_application(const ::std::string& value);
  inline void set_application(const char* value);
  inline void set_application(const char* value, size_t size);
  inline ::std::string* mutable_application();
  inline ::std::string* release_application();
  inline void set_allocated_application(::std::string* application);

  // optional uint32 buildNumber = 7;
  inline bool has_buildnumber() const;
  inline void clear_buildnumber();
  static const int kBuildNumberFieldNumber = 7;
  inline ::google::protobuf::uint32 buildnumber() const;
  inline void set_buildnumber(::google::protobuf::uint32 value);

  // optional string versionQualifier = 8;
  inline bool has_versionqualifier() const;
  inline void clear_versionqualifier();
  static const int kVersionQualifierFieldNumber = 8;
  inline const ::std::string& versionqualifier() const;
  inline void set_versionqualifier(const ::std::string& value);
  inline void set_versionqualifier(const char* value);
  inline void set_versionqualifier(const char* value, size_t size);
  inline ::std::string* mutable_versionqualifier();
  inline ::std::string* release_versionqualifier();
  inline void set_allocated_versionqualifier(::std::string* versionqualifier);

  // @@protoc_insertion_point(class_scope:exec.user.RpcEndpointInfos)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_majorversion();
  inline void clear_has_majorversion();
  inline void set_has_minorversion();
  inline void clear_has_minorversion();
  inline void set_has_patchversion();
  inline void clear_has_patchversion();
  inline void set_has_application();
  inline void clear_has_application();
  inline void set_has_buildnumber();
  inline void clear_has_buildnumber();
  inline void set_has_versionqualifier();
  inline void clear_has_versionqualifier();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* version_;
  ::google::protobuf::uint32 majorversion_;
  ::google::protobuf::uint32 minorversion_;
  ::std::string* application_;
  ::google::protobuf::uint32 patchversion_;
  ::google::protobuf::uint32 buildnumber_;
  ::std::string* versionqualifier_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static RpcEndpointInfos* default_instance_;
};
// -------------------------------------------------------------------

class UserToBitHandshake : public ::google::protobuf::Message {
 public:
  UserToBitHandshake();
  virtual ~UserToBitHandshake();

  UserToBitHandshake(const UserToBitHandshake& from);

  inline UserToBitHandshake& operator=(const UserToBitHandshake& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserToBitHandshake& default_instance();

  void Swap(UserToBitHandshake* other);

  // implements Message ----------------------------------------------

  UserToBitHandshake* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserToBitHandshake& from);
  void MergeFrom(const UserToBitHandshake& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.shared.RpcChannel channel = 1 [default = USER];
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 1;
  inline ::exec::shared::RpcChannel channel() const;
  inline void set_channel(::exec::shared::RpcChannel value);

  // optional bool support_listening = 2;
  inline bool has_support_listening() const;
  inline void clear_support_listening();
  static const int kSupportListeningFieldNumber = 2;
  inline bool support_listening() const;
  inline void set_support_listening(bool value);

  // optional int32 rpc_version = 3;
  inline bool has_rpc_version() const;
  inline void clear_rpc_version();
  static const int kRpcVersionFieldNumber = 3;
  inline ::google::protobuf::int32 rpc_version() const;
  inline void set_rpc_version(::google::protobuf::int32 value);

  // optional .exec.shared.UserCredentials credentials = 4;
  inline bool has_credentials() const;
  inline void clear_credentials();
  static const int kCredentialsFieldNumber = 4;
  inline const ::exec::shared::UserCredentials& credentials() const;
  inline ::exec::shared::UserCredentials* mutable_credentials();
  inline ::exec::shared::UserCredentials* release_credentials();
  inline void set_allocated_credentials(::exec::shared::UserCredentials* credentials);

  // optional .exec.user.UserProperties properties = 5;
  inline bool has_properties() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 5;
  inline const ::exec::user::UserProperties& properties() const;
  inline ::exec::user::UserProperties* mutable_properties();
  inline ::exec::user::UserProperties* release_properties();
  inline void set_allocated_properties(::exec::user::UserProperties* properties);

  // optional bool support_complex_types = 6 [default = false];
  inline bool has_support_complex_types() const;
  inline void clear_support_complex_types();
  static const int kSupportComplexTypesFieldNumber = 6;
  inline bool support_complex_types() const;
  inline void set_support_complex_types(bool value);

  // optional bool support_timeout = 7 [default = false];
  inline bool has_support_timeout() const;
  inline void clear_support_timeout();
  static const int kSupportTimeoutFieldNumber = 7;
  inline bool support_timeout() const;
  inline void set_support_timeout(bool value);

  // optional .exec.user.RpcEndpointInfos client_infos = 8;
  inline bool has_client_infos() const;
  inline void clear_client_infos();
  static const int kClientInfosFieldNumber = 8;
  inline const ::exec::user::RpcEndpointInfos& client_infos() const;
  inline ::exec::user::RpcEndpointInfos* mutable_client_infos();
  inline ::exec::user::RpcEndpointInfos* release_client_infos();
  inline void set_allocated_client_infos(::exec::user::RpcEndpointInfos* client_infos);

  // optional .exec.user.SaslSupport sasl_support = 9;
  inline bool has_sasl_support() const;
  inline void clear_sasl_support();
  static const int kSaslSupportFieldNumber = 9;
  inline ::exec::user::SaslSupport sasl_support() const;
  inline void set_sasl_support(::exec::user::SaslSupport value);

  // @@protoc_insertion_point(class_scope:exec.user.UserToBitHandshake)
 private:
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_support_listening();
  inline void clear_has_support_listening();
  inline void set_has_rpc_version();
  inline void clear_has_rpc_version();
  inline void set_has_credentials();
  inline void clear_has_credentials();
  inline void set_has_properties();
  inline void clear_has_properties();
  inline void set_has_support_complex_types();
  inline void clear_has_support_complex_types();
  inline void set_has_support_timeout();
  inline void clear_has_support_timeout();
  inline void set_has_client_infos();
  inline void clear_has_client_infos();
  inline void set_has_sasl_support();
  inline void clear_has_sasl_support();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int channel_;
  ::google::protobuf::int32 rpc_version_;
  ::exec::shared::UserCredentials* credentials_;
  ::exec::user::UserProperties* properties_;
  bool support_listening_;
  bool support_complex_types_;
  bool support_timeout_;
  int sasl_support_;
  ::exec::user::RpcEndpointInfos* client_infos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static UserToBitHandshake* default_instance_;
};
// -------------------------------------------------------------------

class RequestResults : public ::google::protobuf::Message {
 public:
  RequestResults();
  virtual ~RequestResults();

  RequestResults(const RequestResults& from);

  inline RequestResults& operator=(const RequestResults& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestResults& default_instance();

  void Swap(RequestResults* other);

  // implements Message ----------------------------------------------

  RequestResults* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestResults& from);
  void MergeFrom(const RequestResults& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.shared.QueryId query_id = 1;
  inline bool has_query_id() const;
  inline void clear_query_id();
  static const int kQueryIdFieldNumber = 1;
  inline const ::exec::shared::QueryId& query_id() const;
  inline ::exec::shared::QueryId* mutable_query_id();
  inline ::exec::shared::QueryId* release_query_id();
  inline void set_allocated_query_id(::exec::shared::QueryId* query_id);

  // optional int32 maximum_responses = 2;
  inline bool has_maximum_responses() const;
  inline void clear_maximum_responses();
  static const int kMaximumResponsesFieldNumber = 2;
  inline ::google::protobuf::int32 maximum_responses() const;
  inline void set_maximum_responses(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:exec.user.RequestResults)
 private:
  inline void set_has_query_id();
  inline void clear_has_query_id();
  inline void set_has_maximum_responses();
  inline void clear_has_maximum_responses();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::exec::shared::QueryId* query_id_;
  ::google::protobuf::int32 maximum_responses_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static RequestResults* default_instance_;
};
// -------------------------------------------------------------------

class GetQueryPlanFragments : public ::google::protobuf::Message {
 public:
  GetQueryPlanFragments();
  virtual ~GetQueryPlanFragments();

  GetQueryPlanFragments(const GetQueryPlanFragments& from);

  inline GetQueryPlanFragments& operator=(const GetQueryPlanFragments& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetQueryPlanFragments& default_instance();

  void Swap(GetQueryPlanFragments* other);

  // implements Message ----------------------------------------------

  GetQueryPlanFragments* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetQueryPlanFragments& from);
  void MergeFrom(const GetQueryPlanFragments& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string query = 1;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 1;
  inline const ::std::string& query() const;
  inline void set_query(const ::std::string& value);
  inline void set_query(const char* value);
  inline void set_query(const char* value, size_t size);
  inline ::std::string* mutable_query();
  inline ::std::string* release_query();
  inline void set_allocated_query(::std::string* query);

  // optional .exec.shared.QueryType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::exec::shared::QueryType type() const;
  inline void set_type(::exec::shared::QueryType value);

  // optional bool split_plan = 3 [default = false];
  inline bool has_split_plan() const;
  inline void clear_split_plan();
  static const int kSplitPlanFieldNumber = 3;
  inline bool split_plan() const;
  inline void set_split_plan(bool value);

  // @@protoc_insertion_point(class_scope:exec.user.GetQueryPlanFragments)
 private:
  inline void set_has_query();
  inline void clear_has_query();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_split_plan();
  inline void clear_has_split_plan();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* query_;
  int type_;
  bool split_plan_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static GetQueryPlanFragments* default_instance_;
};
// -------------------------------------------------------------------

class QueryPlanFragments : public ::google::protobuf::Message {
 public:
  QueryPlanFragments();
  virtual ~QueryPlanFragments();

  QueryPlanFragments(const QueryPlanFragments& from);

  inline QueryPlanFragments& operator=(const QueryPlanFragments& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryPlanFragments& default_instance();

  void Swap(QueryPlanFragments* other);

  // implements Message ----------------------------------------------

  QueryPlanFragments* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryPlanFragments& from);
  void MergeFrom(const QueryPlanFragments& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .exec.shared.QueryResult.QueryState status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::exec::shared::QueryResult_QueryState status() const;
  inline void set_status(::exec::shared::QueryResult_QueryState value);

  // optional .exec.shared.QueryId query_id = 2;
  inline bool has_query_id() const;
  inline void clear_query_id();
  static const int kQueryIdFieldNumber = 2;
  inline const ::exec::shared::QueryId& query_id() const;
  inline ::exec::shared::QueryId* mutable_query_id();
  inline ::exec::shared::QueryId* release_query_id();
  inline void set_allocated_query_id(::exec::shared::QueryId* query_id);

  // repeated .exec.bit.control.PlanFragment fragments = 3;
  inline int fragments_size() const;
  inline void clear_fragments();
  static const int kFragmentsFieldNumber = 3;
  inline const ::exec::bit::control::PlanFragment& fragments(int index) const;
  inline ::exec::bit::control::PlanFragment* mutable_fragments(int index);
  inline ::exec::bit::control::PlanFragment* add_fragments();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment >&
      fragments() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment >*
      mutable_fragments();

  // optional .exec.shared.DrillPBError error = 4;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 4;
  inline const ::exec::shared::DrillPBError& error() const;
  inline ::exec::shared::DrillPBError* mutable_error();
  inline ::exec::shared::DrillPBError* release_error();
  inline void set_allocated_error(::exec::shared::DrillPBError* error);

  // @@protoc_insertion_point(class_scope:exec.user.QueryPlanFragments)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_query_id();
  inline void clear_has_query_id();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::exec::shared::QueryId* query_id_;
  ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment > fragments_;
  ::exec::shared::DrillPBError* error_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static QueryPlanFragments* default_instance_;
};
// -------------------------------------------------------------------

class BitToUserHandshake : public ::google::protobuf::Message {
 public:
  BitToUserHandshake();
  virtual ~BitToUserHandshake();

  BitToUserHandshake(const BitToUserHandshake& from);

  inline BitToUserHandshake& operator=(const BitToUserHandshake& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BitToUserHandshake& default_instance();

  void Swap(BitToUserHandshake* other);

  // implements Message ----------------------------------------------

  BitToUserHandshake* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BitToUserHandshake& from);
  void MergeFrom(const BitToUserHandshake& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 rpc_version = 2;
  inline bool has_rpc_version() const;
  inline void clear_rpc_version();
  static const int kRpcVersionFieldNumber = 2;
  inline ::google::protobuf::int32 rpc_version() const;
  inline void set_rpc_version(::google::protobuf::int32 value);

  // optional .exec.user.HandshakeStatus status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::exec::user::HandshakeStatus status() const;
  inline void set_status(::exec::user::HandshakeStatus value);

  // optional string errorId = 4;
  inline bool has_errorid() const;
  inline void clear_errorid();
  static const int kErrorIdFieldNumber = 4;
  inline const ::std::string& errorid() const;
  inline void set_errorid(const ::std::string& value);
  inline void set_errorid(const char* value);
  inline void set_errorid(const char* value, size_t size);
  inline ::std::string* mutable_errorid();
  inline ::std::string* release_errorid();
  inline void set_allocated_errorid(::std::string* errorid);

  // optional string errorMessage = 5;
  inline bool has_errormessage() const;
  inline void clear_errormessage();
  static const int kErrorMessageFieldNumber = 5;
  inline const ::std::string& errormessage() const;
  inline void set_errormessage(const ::std::string& value);
  inline void set_errormessage(const char* value);
  inline void set_errormessage(const char* value, size_t size);
  inline ::std::string* mutable_errormessage();
  inline ::std::string* release_errormessage();
  inline void set_allocated_errormessage(::std::string* errormessage);

  // optional .exec.user.RpcEndpointInfos server_infos = 6;
  inline bool has_server_infos() const;
  inline void clear_server_infos();
  static const int kServerInfosFieldNumber = 6;
  inline const ::exec::user::RpcEndpointInfos& server_infos() const;
  inline ::exec::user::RpcEndpointInfos* mutable_server_infos();
  inline ::exec::user::RpcEndpointInfos* release_server_infos();
  inline void set_allocated_server_infos(::exec::user::RpcEndpointInfos* server_infos);

  // repeated string authenticationMechanisms = 7;
  inline int authenticationmechanisms_size() const;
  inline void clear_authenticationmechanisms();
  static const int kAuthenticationMechanismsFieldNumber = 7;
  inline const ::std::string& authenticationmechanisms(int index) const;
  inline ::std::string* mutable_authenticationmechanisms(int index);
  inline void set_authenticationmechanisms(int index, const ::std::string& value);
  inline void set_authenticationmechanisms(int index, const char* value);
  inline void set_authenticationmechanisms(int index, const char* value, size_t size);
  inline ::std::string* add_authenticationmechanisms();
  inline void add_authenticationmechanisms(const ::std::string& value);
  inline void add_authenticationmechanisms(const char* value);
  inline void add_authenticationmechanisms(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& authenticationmechanisms() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_authenticationmechanisms();

  // repeated .exec.user.RpcType supported_methods = 8;
  inline int supported_methods_size() const;
  inline void clear_supported_methods();
  static const int kSupportedMethodsFieldNumber = 8;
  inline ::exec::user::RpcType supported_methods(int index) const;
  inline void set_supported_methods(int index, ::exec::user::RpcType value);
  inline void add_supported_methods(::exec::user::RpcType value);
  inline const ::google::protobuf::RepeatedField<int>& supported_methods() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_supported_methods();

  // optional bool encrypted = 9;
  inline bool has_encrypted() const;
  inline void clear_encrypted();
  static const int kEncryptedFieldNumber = 9;
  inline bool encrypted() const;
  inline void set_encrypted(bool value);

  // optional int32 maxWrappedSize = 10;
  inline bool has_maxwrappedsize() const;
  inline void clear_maxwrappedsize();
  static const int kMaxWrappedSizeFieldNumber = 10;
  inline ::google::protobuf::int32 maxwrappedsize() const;
  inline void set_maxwrappedsize(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:exec.user.BitToUserHandshake)
 private:
  inline void set_has_rpc_version();
  inline void clear_has_rpc_version();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_errorid();
  inline void clear_has_errorid();
  inline void set_has_errormessage();
  inline void clear_has_errormessage();
  inline void set_has_server_infos();
  inline void clear_has_server_infos();
  inline void set_has_encrypted();
  inline void clear_has_encrypted();
  inline void set_has_maxwrappedsize();
  inline void clear_has_maxwrappedsize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 rpc_version_;
  int status_;
  ::std::string* errorid_;
  ::std::string* errormessage_;
  ::exec::user::RpcEndpointInfos* server_infos_;
  ::google::protobuf::RepeatedPtrField< ::std::string> authenticationmechanisms_;
  ::google::protobuf::RepeatedField<int> supported_methods_;
  bool encrypted_;
  ::google::protobuf::int32 maxwrappedsize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static BitToUserHandshake* default_instance_;
};
// -------------------------------------------------------------------

class LikeFilter : public ::google::protobuf::Message {
 public:
  LikeFilter();
  virtual ~LikeFilter();

  LikeFilter(const LikeFilter& from);

  inline LikeFilter& operator=(const LikeFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LikeFilter& default_instance();

  void Swap(LikeFilter* other);

  // implements Message ----------------------------------------------

  LikeFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LikeFilter& from);
  void MergeFrom(const LikeFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pattern = 1;
  inline bool has_pattern() const;
  inline void clear_pattern();
  static const int kPatternFieldNumber = 1;
  inline const ::std::string& pattern() const;
  inline void set_pattern(const ::std::string& value);
  inline void set_pattern(const char* value);
  inline void set_pattern(const char* value, size_t size);
  inline ::std::string* mutable_pattern();
  inline ::std::string* release_pattern();
  inline void set_allocated_pattern(::std::string* pattern);

  // optional string escape = 2;
  inline bool has_escape() const;
  inline void clear_escape();
  static const int kEscapeFieldNumber = 2;
  inline const ::std::string& escape() const;
  inline void set_escape(const ::std::string& value);
  inline void set_escape(const char* value);
  inline void set_escape(const char* value, size_t size);
  inline ::std::string* mutable_escape();
  inline ::std::string* release_escape();
  inline void set_allocated_escape(::std::string* escape);

  // @@protoc_insertion_point(class_scope:exec.user.LikeFilter)
 private:
  inline void set_has_pattern();
  inline void clear_has_pattern();
  inline void set_has_escape();
  inline void clear_has_escape();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pattern_;
  ::std::string* escape_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static LikeFilter* default_instance_;
};
// -------------------------------------------------------------------

class GetCatalogsReq : public ::google::protobuf::Message {
 public:
  GetCatalogsReq();
  virtual ~GetCatalogsReq();

  GetCatalogsReq(const GetCatalogsReq& from);

  inline GetCatalogsReq& operator=(const GetCatalogsReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCatalogsReq& default_instance();

  void Swap(GetCatalogsReq* other);

  // implements Message ----------------------------------------------

  GetCatalogsReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetCatalogsReq& from);
  void MergeFrom(const GetCatalogsReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.user.LikeFilter catalog_name_filter = 1;
  inline bool has_catalog_name_filter() const;
  inline void clear_catalog_name_filter();
  static const int kCatalogNameFilterFieldNumber = 1;
  inline const ::exec::user::LikeFilter& catalog_name_filter() const;
  inline ::exec::user::LikeFilter* mutable_catalog_name_filter();
  inline ::exec::user::LikeFilter* release_catalog_name_filter();
  inline void set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter);

  // @@protoc_insertion_point(class_scope:exec.user.GetCatalogsReq)
 private:
  inline void set_has_catalog_name_filter();
  inline void clear_has_catalog_name_filter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::exec::user::LikeFilter* catalog_name_filter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static GetCatalogsReq* default_instance_;
};
// -------------------------------------------------------------------

class CatalogMetadata : public ::google::protobuf::Message {
 public:
  CatalogMetadata();
  virtual ~CatalogMetadata();

  CatalogMetadata(const CatalogMetadata& from);

  inline CatalogMetadata& operator=(const CatalogMetadata& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CatalogMetadata& default_instance();

  void Swap(CatalogMetadata* other);

  // implements Message ----------------------------------------------

  CatalogMetadata* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CatalogMetadata& from);
  void MergeFrom(const CatalogMetadata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string catalog_name = 1;
  inline bool has_catalog_name() const;
  inline void clear_catalog_name();
  static const int kCatalogNameFieldNumber = 1;
  inline const ::std::string& catalog_name() const;
  inline void set_catalog_name(const ::std::string& value);
  inline void set_catalog_name(const char* value);
  inline void set_catalog_name(const char* value, size_t size);
  inline ::std::string* mutable_catalog_name();
  inline ::std::string* release_catalog_name();
  inline void set_allocated_catalog_name(::std::string* catalog_name);

  // optional string description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string connect = 3;
  inline bool has_connect() const;
  inline void clear_connect();
  static const int kConnectFieldNumber = 3;
  inline const ::std::string& connect() const;
  inline void set_connect(const ::std::string& value);
  inline void set_connect(const char* value);
  inline void set_connect(const char* value, size_t size);
  inline ::std::string* mutable_connect();
  inline ::std::string* release_connect();
  inline void set_allocated_connect(::std::string* connect);

  // @@protoc_insertion_point(class_scope:exec.user.CatalogMetadata)
 private:
  inline void set_has_catalog_name();
  inline void clear_has_catalog_name();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_connect();
  inline void clear_has_connect();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* catalog_name_;
  ::std::string* description_;
  ::std::string* connect_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static CatalogMetadata* default_instance_;
};
// -------------------------------------------------------------------

class GetCatalogsResp : public ::google::protobuf::Message {
 public:
  GetCatalogsResp();
  virtual ~GetCatalogsResp();

  GetCatalogsResp(const GetCatalogsResp& from);

  inline GetCatalogsResp& operator=(const GetCatalogsResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCatalogsResp& default_instance();

  void Swap(GetCatalogsResp* other);

  // implements Message ----------------------------------------------

  GetCatalogsResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetCatalogsResp& from);
  void MergeFrom(const GetCatalogsResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.user.RequestStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::exec::user::RequestStatus status() const;
  inline void set_status(::exec::user::RequestStatus value);

  // repeated .exec.user.CatalogMetadata catalogs = 2;
  inline int catalogs_size() const;
  inline void clear_catalogs();
  static const int kCatalogsFieldNumber = 2;
  inline const ::exec::user::CatalogMetadata& catalogs(int index) const;
  inline ::exec::user::CatalogMetadata* mutable_catalogs(int index);
  inline ::exec::user::CatalogMetadata* add_catalogs();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::user::CatalogMetadata >&
      catalogs() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::user::CatalogMetadata >*
      mutable_catalogs();

  // optional .exec.shared.DrillPBError error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::exec::shared::DrillPBError& error() const;
  inline ::exec::shared::DrillPBError* mutable_error();
  inline ::exec::shared::DrillPBError* release_error();
  inline void set_allocated_error(::exec::shared::DrillPBError* error);

  // @@protoc_insertion_point(class_scope:exec.user.GetCatalogsResp)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::exec::user::CatalogMetadata > catalogs_;
  ::exec::shared::DrillPBError* error_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static GetCatalogsResp* default_instance_;
};
// -------------------------------------------------------------------

class GetSchemasReq : public ::google::protobuf::Message {
 public:
  GetSchemasReq();
  virtual ~GetSchemasReq();

  GetSchemasReq(const GetSchemasReq& from);

  inline GetSchemasReq& operator=(const GetSchemasReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSchemasReq& default_instance();

  void Swap(GetSchemasReq* other);

  // implements Message ----------------------------------------------

  GetSchemasReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSchemasReq& from);
  void MergeFrom(const GetSchemasReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.user.LikeFilter catalog_name_filter = 1;
  inline bool has_catalog_name_filter() const;
  inline void clear_catalog_name_filter();
  static const int kCatalogNameFilterFieldNumber = 1;
  inline const ::exec::user::LikeFilter& catalog_name_filter() const;
  inline ::exec::user::LikeFilter* mutable_catalog_name_filter();
  inline ::exec::user::LikeFilter* release_catalog_name_filter();
  inline void set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter);

  // optional .exec.user.LikeFilter schema_name_filter = 2;
  inline bool has_schema_name_filter() const;
  inline void clear_schema_name_filter();
  static const int kSchemaNameFilterFieldNumber = 2;
  inline const ::exec::user::LikeFilter& schema_name_filter() const;
  inline ::exec::user::LikeFilter* mutable_schema_name_filter();
  inline ::exec::user::LikeFilter* release_schema_name_filter();
  inline void set_allocated_schema_name_filter(::exec::user::LikeFilter* schema_name_filter);

  // @@protoc_insertion_point(class_scope:exec.user.GetSchemasReq)
 private:
  inline void set_has_catalog_name_filter();
  inline void clear_has_catalog_name_filter();
  inline void set_has_schema_name_filter();
  inline void clear_has_schema_name_filter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::exec::user::LikeFilter* catalog_name_filter_;
  ::exec::user::LikeFilter* schema_name_filter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static GetSchemasReq* default_instance_;
};
// -------------------------------------------------------------------

class SchemaMetadata : public ::google::protobuf::Message {
 public:
  SchemaMetadata();
  virtual ~SchemaMetadata();

  SchemaMetadata(const SchemaMetadata& from);

  inline SchemaMetadata& operator=(const SchemaMetadata& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaMetadata& default_instance();

  void Swap(SchemaMetadata* other);

  // implements Message ----------------------------------------------

  SchemaMetadata* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaMetadata& from);
  void MergeFrom(const SchemaMetadata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string catalog_name = 1;
  inline bool has_catalog_name() const;
  inline void clear_catalog_name();
  static const int kCatalogNameFieldNumber = 1;
  inline const ::std::string& catalog_name() const;
  inline void set_catalog_name(const ::std::string& value);
  inline void set_catalog_name(const char* value);
  inline void set_catalog_name(const char* value, size_t size);
  inline ::std::string* mutable_catalog_name();
  inline ::std::string* release_catalog_name();
  inline void set_allocated_catalog_name(::std::string* catalog_name);

  // optional string schema_name = 2;
  inline bool has_schema_name() const;
  inline void clear_schema_name();
  static const int kSchemaNameFieldNumber = 2;
  inline const ::std::string& schema_name() const;
  inline void set_schema_name(const ::std::string& value);
  inline void set_schema_name(const char* value);
  inline void set_schema_name(const char* value, size_t size);
  inline ::std::string* mutable_schema_name();
  inline ::std::string* release_schema_name();
  inline void set_allocated_schema_name(::std::string* schema_name);

  // optional string owner = 3;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 3;
  inline const ::std::string& owner() const;
  inline void set_owner(const ::std::string& value);
  inline void set_owner(const char* value);
  inline void set_owner(const char* value, size_t size);
  inline ::std::string* mutable_owner();
  inline ::std::string* release_owner();
  inline void set_allocated_owner(::std::string* owner);

  // optional string type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string mutable = 5;
  inline bool has_mutable_() const;
  inline void clear_mutable_();
  static const int kMutableFieldNumber = 5;
  inline const ::std::string& mutable_() const;
  inline void set_mutable_(const ::std::string& value);
  inline void set_mutable_(const char* value);
  inline void set_mutable_(const char* value, size_t size);
  inline ::std::string* mutable_mutable_();
  inline ::std::string* release_mutable_();
  inline void set_allocated_mutable_(::std::string* mutable_);

  // @@protoc_insertion_point(class_scope:exec.user.SchemaMetadata)
 private:
  inline void set_has_catalog_name();
  inline void clear_has_catalog_name();
  inline void set_has_schema_name();
  inline void clear_has_schema_name();
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_mutable_();
  inline void clear_has_mutable_();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* catalog_name_;
  ::std::string* schema_name_;
  ::std::string* owner_;
  ::std::string* type_;
  ::std::string* mutable__;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static SchemaMetadata* default_instance_;
};
// -------------------------------------------------------------------

class GetSchemasResp : public ::google::protobuf::Message {
 public:
  GetSchemasResp();
  virtual ~GetSchemasResp();

  GetSchemasResp(const GetSchemasResp& from);

  inline GetSchemasResp& operator=(const GetSchemasResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSchemasResp& default_instance();

  void Swap(GetSchemasResp* other);

  // implements Message ----------------------------------------------

  GetSchemasResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSchemasResp& from);
  void MergeFrom(const GetSchemasResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.user.RequestStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::exec::user::RequestStatus status() const;
  inline void set_status(::exec::user::RequestStatus value);

  // repeated .exec.user.SchemaMetadata schemas = 2;
  inline int schemas_size() const;
  inline void clear_schemas();
  static const int kSchemasFieldNumber = 2;
  inline const ::exec::user::SchemaMetadata& schemas(int index) const;
  inline ::exec::user::SchemaMetadata* mutable_schemas(int index);
  inline ::exec::user::SchemaMetadata* add_schemas();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::user::SchemaMetadata >&
      schemas() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::user::SchemaMetadata >*
      mutable_schemas();

  // optional .exec.shared.DrillPBError error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::exec::shared::DrillPBError& error() const;
  inline ::exec::shared::DrillPBError* mutable_error();
  inline ::exec::shared::DrillPBError* release_error();
  inline void set_allocated_error(::exec::shared::DrillPBError* error);

  // @@protoc_insertion_point(class_scope:exec.user.GetSchemasResp)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::exec::user::SchemaMetadata > schemas_;
  ::exec::shared::DrillPBError* error_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static GetSchemasResp* default_instance_;
};
// -------------------------------------------------------------------

class GetTablesReq : public ::google::protobuf::Message {
 public:
  GetTablesReq();
  virtual ~GetTablesReq();

  GetTablesReq(const GetTablesReq& from);

  inline GetTablesReq& operator=(const GetTablesReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTablesReq& default_instance();

  void Swap(GetTablesReq* other);

  // implements Message ----------------------------------------------

  GetTablesReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTablesReq& from);
  void MergeFrom(const GetTablesReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.user.LikeFilter catalog_name_filter = 1;
  inline bool has_catalog_name_filter() const;
  inline void clear_catalog_name_filter();
  static const int kCatalogNameFilterFieldNumber = 1;
  inline const ::exec::user::LikeFilter& catalog_name_filter() const;
  inline ::exec::user::LikeFilter* mutable_catalog_name_filter();
  inline ::exec::user::LikeFilter* release_catalog_name_filter();
  inline void set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter);

  // optional .exec.user.LikeFilter schema_name_filter = 2;
  inline bool has_schema_name_filter() const;
  inline void clear_schema_name_filter();
  static const int kSchemaNameFilterFieldNumber = 2;
  inline const ::exec::user::LikeFilter& schema_name_filter() const;
  inline ::exec::user::LikeFilter* mutable_schema_name_filter();
  inline ::exec::user::LikeFilter* release_schema_name_filter();
  inline void set_allocated_schema_name_filter(::exec::user::LikeFilter* schema_name_filter);

  // optional .exec.user.LikeFilter table_name_filter = 3;
  inline bool has_table_name_filter() const;
  inline void clear_table_name_filter();
  static const int kTableNameFilterFieldNumber = 3;
  inline const ::exec::user::LikeFilter& table_name_filter() const;
  inline ::exec::user::LikeFilter* mutable_table_name_filter();
  inline ::exec::user::LikeFilter* release_table_name_filter();
  inline void set_allocated_table_name_filter(::exec::user::LikeFilter* table_name_filter);

  // repeated string table_type_filter = 4;
  inline int table_type_filter_size() const;
  inline void clear_table_type_filter();
  static const int kTableTypeFilterFieldNumber = 4;
  inline const ::std::string& table_type_filter(int index) const;
  inline ::std::string* mutable_table_type_filter(int index);
  inline void set_table_type_filter(int index, const ::std::string& value);
  inline void set_table_type_filter(int index, const char* value);
  inline void set_table_type_filter(int index, const char* value, size_t size);
  inline ::std::string* add_table_type_filter();
  inline void add_table_type_filter(const ::std::string& value);
  inline void add_table_type_filter(const char* value);
  inline void add_table_type_filter(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& table_type_filter() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_table_type_filter();

  // @@protoc_insertion_point(class_scope:exec.user.GetTablesReq)
 private:
  inline void set_has_catalog_name_filter();
  inline void clear_has_catalog_name_filter();
  inline void set_has_schema_name_filter();
  inline void clear_has_schema_name_filter();
  inline void set_has_table_name_filter();
  inline void clear_has_table_name_filter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::exec::user::LikeFilter* catalog_name_filter_;
  ::exec::user::LikeFilter* schema_name_filter_;
  ::exec::user::LikeFilter* table_name_filter_;
  ::google::protobuf::RepeatedPtrField< ::std::string> table_type_filter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static GetTablesReq* default_instance_;
};
// -------------------------------------------------------------------

class TableMetadata : public ::google::protobuf::Message {
 public:
  TableMetadata();
  virtual ~TableMetadata();

  TableMetadata(const TableMetadata& from);

  inline TableMetadata& operator=(const TableMetadata& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableMetadata& default_instance();

  void Swap(TableMetadata* other);

  // implements Message ----------------------------------------------

  TableMetadata* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableMetadata& from);
  void MergeFrom(const TableMetadata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string catalog_name = 1;
  inline bool has_catalog_name() const;
  inline void clear_catalog_name();
  static const int kCatalogNameFieldNumber = 1;
  inline const ::std::string& catalog_name() const;
  inline void set_catalog_name(const ::std::string& value);
  inline void set_catalog_name(const char* value);
  inline void set_catalog_name(const char* value, size_t size);
  inline ::std::string* mutable_catalog_name();
  inline ::std::string* release_catalog_name();
  inline void set_allocated_catalog_name(::std::string* catalog_name);

  // optional string schema_name = 2;
  inline bool has_schema_name() const;
  inline void clear_schema_name();
  static const int kSchemaNameFieldNumber = 2;
  inline const ::std::string& schema_name() const;
  inline void set_schema_name(const ::std::string& value);
  inline void set_schema_name(const char* value);
  inline void set_schema_name(const char* value, size_t size);
  inline ::std::string* mutable_schema_name();
  inline ::std::string* release_schema_name();
  inline void set_allocated_schema_name(::std::string* schema_name);

  // optional string table_name = 3;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 3;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const char* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  inline void set_allocated_table_name(::std::string* table_name);

  // optional string type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:exec.user.TableMetadata)
 private:
  inline void set_has_catalog_name();
  inline void clear_has_catalog_name();
  inline void set_has_schema_name();
  inline void clear_has_schema_name();
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* catalog_name_;
  ::std::string* schema_name_;
  ::std::string* table_name_;
  ::std::string* type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static TableMetadata* default_instance_;
};
// -------------------------------------------------------------------

class GetTablesResp : public ::google::protobuf::Message {
 public:
  GetTablesResp();
  virtual ~GetTablesResp();

  GetTablesResp(const GetTablesResp& from);

  inline GetTablesResp& operator=(const GetTablesResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTablesResp& default_instance();

  void Swap(GetTablesResp* other);

  // implements Message ----------------------------------------------

  GetTablesResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTablesResp& from);
  void MergeFrom(const GetTablesResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.user.RequestStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::exec::user::RequestStatus status() const;
  inline void set_status(::exec::user::RequestStatus value);

  // repeated .exec.user.TableMetadata tables = 2;
  inline int tables_size() const;
  inline void clear_tables();
  static const int kTablesFieldNumber = 2;
  inline const ::exec::user::TableMetadata& tables(int index) const;
  inline ::exec::user::TableMetadata* mutable_tables(int index);
  inline ::exec::user::TableMetadata* add_tables();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::user::TableMetadata >&
      tables() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::user::TableMetadata >*
      mutable_tables();

  // optional .exec.shared.DrillPBError error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::exec::shared::DrillPBError& error() const;
  inline ::exec::shared::DrillPBError* mutable_error();
  inline ::exec::shared::DrillPBError* release_error();
  inline void set_allocated_error(::exec::shared::DrillPBError* error);

  // @@protoc_insertion_point(class_scope:exec.user.GetTablesResp)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::exec::user::TableMetadata > tables_;
  ::exec::shared::DrillPBError* error_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static GetTablesResp* default_instance_;
};
// -------------------------------------------------------------------

class GetColumnsReq : public ::google::protobuf::Message {
 public:
  GetColumnsReq();
  virtual ~GetColumnsReq();

  GetColumnsReq(const GetColumnsReq& from);

  inline GetColumnsReq& operator=(const GetColumnsReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetColumnsReq& default_instance();

  void Swap(GetColumnsReq* other);

  // implements Message ----------------------------------------------

  GetColumnsReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetColumnsReq& from);
  void MergeFrom(const GetColumnsReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.user.LikeFilter catalog_name_filter = 1;
  inline bool has_catalog_name_filter() const;
  inline void clear_catalog_name_filter();
  static const int kCatalogNameFilterFieldNumber = 1;
  inline const ::exec::user::LikeFilter& catalog_name_filter() const;
  inline ::exec::user::LikeFilter* mutable_catalog_name_filter();
  inline ::exec::user::LikeFilter* release_catalog_name_filter();
  inline void set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter);

  // optional .exec.user.LikeFilter schema_name_filter = 2;
  inline bool has_schema_name_filter() const;
  inline void clear_schema_name_filter();
  static const int kSchemaNameFilterFieldNumber = 2;
  inline const ::exec::user::LikeFilter& schema_name_filter() const;
  inline ::exec::user::LikeFilter* mutable_schema_name_filter();
  inline ::exec::user::LikeFilter* release_schema_name_filter();
  inline void set_allocated_schema_name_filter(::exec::user::LikeFilter* schema_name_filter);

  // optional .exec.user.LikeFilter table_name_filter = 3;
  inline bool has_table_name_filter() const;
  inline void clear_table_name_filter();
  static const int kTableNameFilterFieldNumber = 3;
  inline const ::exec::user::LikeFilter& table_name_filter() const;
  inline ::exec::user::LikeFilter* mutable_table_name_filter();
  inline ::exec::user::LikeFilter* release_table_name_filter();
  inline void set_allocated_table_name_filter(::exec::user::LikeFilter* table_name_filter);

  // optional .exec.user.LikeFilter column_name_filter = 4;
  inline bool has_column_name_filter() const;
  inline void clear_column_name_filter();
  static const int kColumnNameFilterFieldNumber = 4;
  inline const ::exec::user::LikeFilter& column_name_filter() const;
  inline ::exec::user::LikeFilter* mutable_column_name_filter();
  inline ::exec::user::LikeFilter* release_column_name_filter();
  inline void set_allocated_column_name_filter(::exec::user::LikeFilter* column_name_filter);

  // @@protoc_insertion_point(class_scope:exec.user.GetColumnsReq)
 private:
  inline void set_has_catalog_name_filter();
  inline void clear_has_catalog_name_filter();
  inline void set_has_schema_name_filter();
  inline void clear_has_schema_name_filter();
  inline void set_has_table_name_filter();
  inline void clear_has_table_name_filter();
  inline void set_has_column_name_filter();
  inline void clear_has_column_name_filter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::exec::user::LikeFilter* catalog_name_filter_;
  ::exec::user::LikeFilter* schema_name_filter_;
  ::exec::user::LikeFilter* table_name_filter_;
  ::exec::user::LikeFilter* column_name_filter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static GetColumnsReq* default_instance_;
};
// -------------------------------------------------------------------

class ColumnMetadata : public ::google::protobuf::Message {
 public:
  ColumnMetadata();
  virtual ~ColumnMetadata();

  ColumnMetadata(const ColumnMetadata& from);

  inline ColumnMetadata& operator=(const ColumnMetadata& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnMetadata& default_instance();

  void Swap(ColumnMetadata* other);

  // implements Message ----------------------------------------------

  ColumnMetadata* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColumnMetadata& from);
  void MergeFrom(const ColumnMetadata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string catalog_name = 1;
  inline bool has_catalog_name() const;
  inline void clear_catalog_name();
  static const int kCatalogNameFieldNumber = 1;
  inline const ::std::string& catalog_name() const;
  inline void set_catalog_name(const ::std::string& value);
  inline void set_catalog_name(const char* value);
  inline void set_catalog_name(const char* value, size_t size);
  inline ::std::string* mutable_catalog_name();
  inline ::std::string* release_catalog_name();
  inline void set_allocated_catalog_name(::std::string* catalog_name);

  // optional string schema_name = 2;
  inline bool has_schema_name() const;
  inline void clear_schema_name();
  static const int kSchemaNameFieldNumber = 2;
  inline const ::std::string& schema_name() const;
  inline void set_schema_name(const ::std::string& value);
  inline void set_schema_name(const char* value);
  inline void set_schema_name(const char* value, size_t size);
  inline ::std::string* mutable_schema_name();
  inline ::std::string* release_schema_name();
  inline void set_allocated_schema_name(::std::string* schema_name);

  // optional string table_name = 3;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 3;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const char* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  inline void set_allocated_table_name(::std::string* table_name);

  // optional string column_name = 4;
  inline bool has_column_name() const;
  inline void clear_column_name();
  static const int kColumnNameFieldNumber = 4;
  inline const ::std::string& column_name() const;
  inline void set_column_name(const ::std::string& value);
  inline void set_column_name(const char* value);
  inline void set_column_name(const char* value, size_t size);
  inline ::std::string* mutable_column_name();
  inline ::std::string* release_column_name();
  inline void set_allocated_column_name(::std::string* column_name);

  // optional int32 ordinal_position = 5;
  inline bool has_ordinal_position() const;
  inline void clear_ordinal_position();
  static const int kOrdinalPositionFieldNumber = 5;
  inline ::google::protobuf::int32 ordinal_position() const;
  inline void set_ordinal_position(::google::protobuf::int32 value);

  // optional string default_value = 6;
  inline bool has_default_value() const;
  inline void clear_default_value();
  static const int kDefaultValueFieldNumber = 6;
  inline const ::std::string& default_value() const;
  inline void set_default_value(const ::std::string& value);
  inline void set_default_value(const char* value);
  inline void set_default_value(const char* value, size_t size);
  inline ::std::string* mutable_default_value();
  inline ::std::string* release_default_value();
  inline void set_allocated_default_value(::std::string* default_value);

  // optional bool is_nullable = 7;
  inline bool has_is_nullable() const;
  inline void clear_is_nullable();
  static const int kIsNullableFieldNumber = 7;
  inline bool is_nullable() const;
  inline void set_is_nullable(bool value);

  // optional string data_type = 8;
  inline bool has_data_type() const;
  inline void clear_data_type();
  static const int kDataTypeFieldNumber = 8;
  inline const ::std::string& data_type() const;
  inline void set_data_type(const ::std::string& value);
  inline void set_data_type(const char* value);
  inline void set_data_type(const char* value, size_t size);
  inline ::std::string* mutable_data_type();
  inline ::std::string* release_data_type();
  inline void set_allocated_data_type(::std::string* data_type);

  // optional int32 char_max_length = 9;
  inline bool has_char_max_length() const;
  inline void clear_char_max_length();
  static const int kCharMaxLengthFieldNumber = 9;
  inline ::google::protobuf::int32 char_max_length() const;
  inline void set_char_max_length(::google::protobuf::int32 value);

  // optional int32 char_octet_length = 10;
  inline bool has_char_octet_length() const;
  inline void clear_char_octet_length();
  static const int kCharOctetLengthFieldNumber = 10;
  inline ::google::protobuf::int32 char_octet_length() const;
  inline void set_char_octet_length(::google::protobuf::int32 value);

  // optional int32 numeric_precision = 11;
  inline bool has_numeric_precision() const;
  inline void clear_numeric_precision();
  static const int kNumericPrecisionFieldNumber = 11;
  inline ::google::protobuf::int32 numeric_precision() const;
  inline void set_numeric_precision(::google::protobuf::int32 value);

  // optional int32 numeric_precision_radix = 12;
  inline bool has_numeric_precision_radix() const;
  inline void clear_numeric_precision_radix();
  static const int kNumericPrecisionRadixFieldNumber = 12;
  inline ::google::protobuf::int32 numeric_precision_radix() const;
  inline void set_numeric_precision_radix(::google::protobuf::int32 value);

  // optional int32 numeric_scale = 13;
  inline bool has_numeric_scale() const;
  inline void clear_numeric_scale();
  static const int kNumericScaleFieldNumber = 13;
  inline ::google::protobuf::int32 numeric_scale() const;
  inline void set_numeric_scale(::google::protobuf::int32 value);

  // optional int32 date_time_precision = 14;
  inline bool has_date_time_precision() const;
  inline void clear_date_time_precision();
  static const int kDateTimePrecisionFieldNumber = 14;
  inline ::google::protobuf::int32 date_time_precision() const;
  inline void set_date_time_precision(::google::protobuf::int32 value);

  // optional string interval_type = 15;
  inline bool has_interval_type() const;
  inline void clear_interval_type();
  static const int kIntervalTypeFieldNumber = 15;
  inline const ::std::string& interval_type() const;
  inline void set_interval_type(const ::std::string& value);
  inline void set_interval_type(const char* value);
  inline void set_interval_type(const char* value, size_t size);
  inline ::std::string* mutable_interval_type();
  inline ::std::string* release_interval_type();
  inline void set_allocated_interval_type(::std::string* interval_type);

  // optional int32 interval_precision = 16;
  inline bool has_interval_precision() const;
  inline void clear_interval_precision();
  static const int kIntervalPrecisionFieldNumber = 16;
  inline ::google::protobuf::int32 interval_precision() const;
  inline void set_interval_precision(::google::protobuf::int32 value);

  // optional int32 column_size = 17;
  inline bool has_column_size() const;
  inline void clear_column_size();
  static const int kColumnSizeFieldNumber = 17;
  inline ::google::protobuf::int32 column_size() const;
  inline void set_column_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:exec.user.ColumnMetadata)
 private:
  inline void set_has_catalog_name();
  inline void clear_has_catalog_name();
  inline void set_has_schema_name();
  inline void clear_has_schema_name();
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_column_name();
  inline void clear_has_column_name();
  inline void set_has_ordinal_position();
  inline void clear_has_ordinal_position();
  inline void set_has_default_value();
  inline void clear_has_default_value();
  inline void set_has_is_nullable();
  inline void clear_has_is_nullable();
  inline void set_has_data_type();
  inline void clear_has_data_type();
  inline void set_has_char_max_length();
  inline void clear_has_char_max_length();
  inline void set_has_char_octet_length();
  inline void clear_has_char_octet_length();
  inline void set_has_numeric_precision();
  inline void clear_has_numeric_precision();
  inline void set_has_numeric_precision_radix();
  inline void clear_has_numeric_precision_radix();
  inline void set_has_numeric_scale();
  inline void clear_has_numeric_scale();
  inline void set_has_date_time_precision();
  inline void clear_has_date_time_precision();
  inline void set_has_interval_type();
  inline void clear_has_interval_type();
  inline void set_has_interval_precision();
  inline void clear_has_interval_precision();
  inline void set_has_column_size();
  inline void clear_has_column_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* catalog_name_;
  ::std::string* schema_name_;
  ::std::string* table_name_;
  ::std::string* column_name_;
  ::std::string* default_value_;
  ::google::protobuf::int32 ordinal_position_;
  bool is_nullable_;
  ::std::string* data_type_;
  ::google::protobuf::int32 char_max_length_;
  ::google::protobuf::int32 char_octet_length_;
  ::google::protobuf::int32 numeric_precision_;
  ::google::protobuf::int32 numeric_precision_radix_;
  ::google::protobuf::int32 numeric_scale_;
  ::google::protobuf::int32 date_time_precision_;
  ::std::string* interval_type_;
  ::google::protobuf::int32 interval_precision_;
  ::google::protobuf::int32 column_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static ColumnMetadata* default_instance_;
};
// -------------------------------------------------------------------

class GetColumnsResp : public ::google::protobuf::Message {
 public:
  GetColumnsResp();
  virtual ~GetColumnsResp();

  GetColumnsResp(const GetColumnsResp& from);

  inline GetColumnsResp& operator=(const GetColumnsResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetColumnsResp& default_instance();

  void Swap(GetColumnsResp* other);

  // implements Message ----------------------------------------------

  GetColumnsResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetColumnsResp& from);
  void MergeFrom(const GetColumnsResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.user.RequestStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::exec::user::RequestStatus status() const;
  inline void set_status(::exec::user::RequestStatus value);

  // repeated .exec.user.ColumnMetadata columns = 2;
  inline int columns_size() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 2;
  inline const ::exec::user::ColumnMetadata& columns(int index) const;
  inline ::exec::user::ColumnMetadata* mutable_columns(int index);
  inline ::exec::user::ColumnMetadata* add_columns();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::user::ColumnMetadata >&
      columns() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::user::ColumnMetadata >*
      mutable_columns();

  // optional .exec.shared.DrillPBError error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::exec::shared::DrillPBError& error() const;
  inline ::exec::shared::DrillPBError* mutable_error();
  inline ::exec::shared::DrillPBError* release_error();
  inline void set_allocated_error(::exec::shared::DrillPBError* error);

  // @@protoc_insertion_point(class_scope:exec.user.GetColumnsResp)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::exec::user::ColumnMetadata > columns_;
  ::exec::shared::DrillPBError* error_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static GetColumnsResp* default_instance_;
};
// -------------------------------------------------------------------

class CreatePreparedStatementReq : public ::google::protobuf::Message {
 public:
  CreatePreparedStatementReq();
  virtual ~CreatePreparedStatementReq();

  CreatePreparedStatementReq(const CreatePreparedStatementReq& from);

  inline CreatePreparedStatementReq& operator=(const CreatePreparedStatementReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreatePreparedStatementReq& default_instance();

  void Swap(CreatePreparedStatementReq* other);

  // implements Message ----------------------------------------------

  CreatePreparedStatementReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreatePreparedStatementReq& from);
  void MergeFrom(const CreatePreparedStatementReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sql_query = 1;
  inline bool has_sql_query() const;
  inline void clear_sql_query();
  static const int kSqlQueryFieldNumber = 1;
  inline const ::std::string& sql_query() const;
  inline void set_sql_query(const ::std::string& value);
  inline void set_sql_query(const char* value);
  inline void set_sql_query(const char* value, size_t size);
  inline ::std::string* mutable_sql_query();
  inline ::std::string* release_sql_query();
  inline void set_allocated_sql_query(::std::string* sql_query);

  // @@protoc_insertion_point(class_scope:exec.user.CreatePreparedStatementReq)
 private:
  inline void set_has_sql_query();
  inline void clear_has_sql_query();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sql_query_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static CreatePreparedStatementReq* default_instance_;
};
// -------------------------------------------------------------------

class ResultColumnMetadata : public ::google::protobuf::Message {
 public:
  ResultColumnMetadata();
  virtual ~ResultColumnMetadata();

  ResultColumnMetadata(const ResultColumnMetadata& from);

  inline ResultColumnMetadata& operator=(const ResultColumnMetadata& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultColumnMetadata& default_instance();

  void Swap(ResultColumnMetadata* other);

  // implements Message ----------------------------------------------

  ResultColumnMetadata* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResultColumnMetadata& from);
  void MergeFrom(const ResultColumnMetadata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string catalog_name = 1;
  inline bool has_catalog_name() const;
  inline void clear_catalog_name();
  static const int kCatalogNameFieldNumber = 1;
  inline const ::std::string& catalog_name() const;
  inline void set_catalog_name(const ::std::string& value);
  inline void set_catalog_name(const char* value);
  inline void set_catalog_name(const char* value, size_t size);
  inline ::std::string* mutable_catalog_name();
  inline ::std::string* release_catalog_name();
  inline void set_allocated_catalog_name(::std::string* catalog_name);

  // optional string schema_name = 2;
  inline bool has_schema_name() const;
  inline void clear_schema_name();
  static const int kSchemaNameFieldNumber = 2;
  inline const ::std::string& schema_name() const;
  inline void set_schema_name(const ::std::string& value);
  inline void set_schema_name(const char* value);
  inline void set_schema_name(const char* value, size_t size);
  inline ::std::string* mutable_schema_name();
  inline ::std::string* release_schema_name();
  inline void set_allocated_schema_name(::std::string* schema_name);

  // optional string table_name = 3;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 3;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const char* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  inline void set_allocated_table_name(::std::string* table_name);

  // optional string column_name = 4;
  inline bool has_column_name() const;
  inline void clear_column_name();
  static const int kColumnNameFieldNumber = 4;
  inline const ::std::string& column_name() const;
  inline void set_column_name(const ::std::string& value);
  inline void set_column_name(const char* value);
  inline void set_column_name(const char* value, size_t size);
  inline ::std::string* mutable_column_name();
  inline ::std::string* release_column_name();
  inline void set_allocated_column_name(::std::string* column_name);

  // optional string label = 5;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 5;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // optional string data_type = 6;
  inline bool has_data_type() const;
  inline void clear_data_type();
  static const int kDataTypeFieldNumber = 6;
  inline const ::std::string& data_type() const;
  inline void set_data_type(const ::std::string& value);
  inline void set_data_type(const char* value);
  inline void set_data_type(const char* value, size_t size);
  inline ::std::string* mutable_data_type();
  inline ::std::string* release_data_type();
  inline void set_allocated_data_type(::std::string* data_type);

  // optional bool is_nullable = 7;
  inline bool has_is_nullable() const;
  inline void clear_is_nullable();
  static const int kIsNullableFieldNumber = 7;
  inline bool is_nullable() const;
  inline void set_is_nullable(bool value);

  // optional int32 precision = 8;
  inline bool has_precision() const;
  inline void clear_precision();
  static const int kPrecisionFieldNumber = 8;
  inline ::google::protobuf::int32 precision() const;
  inline void set_precision(::google::protobuf::int32 value);

  // optional int32 scale = 9;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 9;
  inline ::google::protobuf::int32 scale() const;
  inline void set_scale(::google::protobuf::int32 value);

  // optional bool signed = 10;
  inline bool has_signed_() const;
  inline void clear_signed_();
  static const int kSignedFieldNumber = 10;
  inline bool signed_() const;
  inline void set_signed_(bool value);

  // optional int32 display_size = 11;
  inline bool has_display_size() const;
  inline void clear_display_size();
  static const int kDisplaySizeFieldNumber = 11;
  inline ::google::protobuf::int32 display_size() const;
  inline void set_display_size(::google::protobuf::int32 value);

  // optional bool is_aliased = 12;
  inline bool has_is_aliased() const;
  inline void clear_is_aliased();
  static const int kIsAliasedFieldNumber = 12;
  inline bool is_aliased() const;
  inline void set_is_aliased(bool value);

  // optional .exec.user.ColumnSearchability searchability = 13;
  inline bool has_searchability() const;
  inline void clear_searchability();
  static const int kSearchabilityFieldNumber = 13;
  inline ::exec::user::ColumnSearchability searchability() const;
  inline void set_searchability(::exec::user::ColumnSearchability value);

  // optional .exec.user.ColumnUpdatability updatability = 14;
  inline bool has_updatability() const;
  inline void clear_updatability();
  static const int kUpdatabilityFieldNumber = 14;
  inline ::exec::user::ColumnUpdatability updatability() const;
  inline void set_updatability(::exec::user::ColumnUpdatability value);

  // optional bool auto_increment = 15;
  inline bool has_auto_increment() const;
  inline void clear_auto_increment();
  static const int kAutoIncrementFieldNumber = 15;
  inline bool auto_increment() const;
  inline void set_auto_increment(bool value);

  // optional bool case_sensitivity = 16;
  inline bool has_case_sensitivity() const;
  inline void clear_case_sensitivity();
  static const int kCaseSensitivityFieldNumber = 16;
  inline bool case_sensitivity() const;
  inline void set_case_sensitivity(bool value);

  // optional bool sortable = 17;
  inline bool has_sortable() const;
  inline void clear_sortable();
  static const int kSortableFieldNumber = 17;
  inline bool sortable() const;
  inline void set_sortable(bool value);

  // optional string class_name = 18;
  inline bool has_class_name() const;
  inline void clear_class_name();
  static const int kClassNameFieldNumber = 18;
  inline const ::std::string& class_name() const;
  inline void set_class_name(const ::std::string& value);
  inline void set_class_name(const char* value);
  inline void set_class_name(const char* value, size_t size);
  inline ::std::string* mutable_class_name();
  inline ::std::string* release_class_name();
  inline void set_allocated_class_name(::std::string* class_name);

  // optional bool is_currency = 20;
  inline bool has_is_currency() const;
  inline void clear_is_currency();
  static const int kIsCurrencyFieldNumber = 20;
  inline bool is_currency() const;
  inline void set_is_currency(bool value);

  // @@protoc_insertion_point(class_scope:exec.user.ResultColumnMetadata)
 private:
  inline void set_has_catalog_name();
  inline void clear_has_catalog_name();
  inline void set_has_schema_name();
  inline void clear_has_schema_name();
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_column_name();
  inline void clear_has_column_name();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_data_type();
  inline void clear_has_data_type();
  inline void set_has_is_nullable();
  inline void clear_has_is_nullable();
  inline void set_has_precision();
  inline void clear_has_precision();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_signed_();
  inline void clear_has_signed_();
  inline void set_has_display_size();
  inline void clear_has_display_size();
  inline void set_has_is_aliased();
  inline void clear_has_is_aliased();
  inline void set_has_searchability();
  inline void clear_has_searchability();
  inline void set_has_updatability();
  inline void clear_has_updatability();
  inline void set_has_auto_increment();
  inline void clear_has_auto_increment();
  inline void set_has_case_sensitivity();
  inline void clear_has_case_sensitivity();
  inline void set_has_sortable();
  inline void clear_has_sortable();
  inline void set_has_class_name();
  inline void clear_has_class_name();
  inline void set_has_is_currency();
  inline void clear_has_is_currency();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* catalog_name_;
  ::std::string* schema_name_;
  ::std::string* table_name_;
  ::std::string* column_name_;
  ::std::string* label_;
  ::std::string* data_type_;
  ::google::protobuf::int32 precision_;
  ::google::protobuf::int32 scale_;
  ::google::protobuf::int32 display_size_;
  bool is_nullable_;
  bool signed__;
  bool is_aliased_;
  bool auto_increment_;
  int searchability_;
  int updatability_;
  ::std::string* class_name_;
  bool case_sensitivity_;
  bool sortable_;
  bool is_currency_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static ResultColumnMetadata* default_instance_;
};
// -------------------------------------------------------------------

class PreparedStatementHandle : public ::google::protobuf::Message {
 public:
  PreparedStatementHandle();
  virtual ~PreparedStatementHandle();

  PreparedStatementHandle(const PreparedStatementHandle& from);

  inline PreparedStatementHandle& operator=(const PreparedStatementHandle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PreparedStatementHandle& default_instance();

  void Swap(PreparedStatementHandle* other);

  // implements Message ----------------------------------------------

  PreparedStatementHandle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PreparedStatementHandle& from);
  void MergeFrom(const PreparedStatementHandle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes server_info = 1;
  inline bool has_server_info() const;
  inline void clear_server_info();
  static const int kServerInfoFieldNumber = 1;
  inline const ::std::string& server_info() const;
  inline void set_server_info(const ::std::string& value);
  inline void set_server_info(const char* value);
  inline void set_server_info(const void* value, size_t size);
  inline ::std::string* mutable_server_info();
  inline ::std::string* release_server_info();
  inline void set_allocated_server_info(::std::string* server_info);

  // @@protoc_insertion_point(class_scope:exec.user.PreparedStatementHandle)
 private:
  inline void set_has_server_info();
  inline void clear_has_server_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* server_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static PreparedStatementHandle* default_instance_;
};
// -------------------------------------------------------------------

class PreparedStatement : public ::google::protobuf::Message {
 public:
  PreparedStatement();
  virtual ~PreparedStatement();

  PreparedStatement(const PreparedStatement& from);

  inline PreparedStatement& operator=(const PreparedStatement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PreparedStatement& default_instance();

  void Swap(PreparedStatement* other);

  // implements Message ----------------------------------------------

  PreparedStatement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PreparedStatement& from);
  void MergeFrom(const PreparedStatement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .exec.user.ResultColumnMetadata columns = 1;
  inline int columns_size() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 1;
  inline const ::exec::user::ResultColumnMetadata& columns(int index) const;
  inline ::exec::user::ResultColumnMetadata* mutable_columns(int index);
  inline ::exec::user::ResultColumnMetadata* add_columns();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::user::ResultColumnMetadata >&
      columns() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::user::ResultColumnMetadata >*
      mutable_columns();

  // optional .exec.user.PreparedStatementHandle server_handle = 2;
  inline bool has_server_handle() const;
  inline void clear_server_handle();
  static const int kServerHandleFieldNumber = 2;
  inline const ::exec::user::PreparedStatementHandle& server_handle() const;
  inline ::exec::user::PreparedStatementHandle* mutable_server_handle();
  inline ::exec::user::PreparedStatementHandle* release_server_handle();
  inline void set_allocated_server_handle(::exec::user::PreparedStatementHandle* server_handle);

  // @@protoc_insertion_point(class_scope:exec.user.PreparedStatement)
 private:
  inline void set_has_server_handle();
  inline void clear_has_server_handle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::exec::user::ResultColumnMetadata > columns_;
  ::exec::user::PreparedStatementHandle* server_handle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static PreparedStatement* default_instance_;
};
// -------------------------------------------------------------------

class CreatePreparedStatementResp : public ::google::protobuf::Message {
 public:
  CreatePreparedStatementResp();
  virtual ~CreatePreparedStatementResp();

  CreatePreparedStatementResp(const CreatePreparedStatementResp& from);

  inline CreatePreparedStatementResp& operator=(const CreatePreparedStatementResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreatePreparedStatementResp& default_instance();

  void Swap(CreatePreparedStatementResp* other);

  // implements Message ----------------------------------------------

  CreatePreparedStatementResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreatePreparedStatementResp& from);
  void MergeFrom(const CreatePreparedStatementResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.user.RequestStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::exec::user::RequestStatus status() const;
  inline void set_status(::exec::user::RequestStatus value);

  // optional .exec.user.PreparedStatement prepared_statement = 2;
  inline bool has_prepared_statement() const;
  inline void clear_prepared_statement();
  static const int kPreparedStatementFieldNumber = 2;
  inline const ::exec::user::PreparedStatement& prepared_statement() const;
  inline ::exec::user::PreparedStatement* mutable_prepared_statement();
  inline ::exec::user::PreparedStatement* release_prepared_statement();
  inline void set_allocated_prepared_statement(::exec::user::PreparedStatement* prepared_statement);

  // optional .exec.shared.DrillPBError error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::exec::shared::DrillPBError& error() const;
  inline ::exec::shared::DrillPBError* mutable_error();
  inline ::exec::shared::DrillPBError* release_error();
  inline void set_allocated_error(::exec::shared::DrillPBError* error);

  // @@protoc_insertion_point(class_scope:exec.user.CreatePreparedStatementResp)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_prepared_statement();
  inline void clear_has_prepared_statement();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::exec::user::PreparedStatement* prepared_statement_;
  ::exec::shared::DrillPBError* error_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static CreatePreparedStatementResp* default_instance_;
};
// -------------------------------------------------------------------

class GetServerMetaReq : public ::google::protobuf::Message {
 public:
  GetServerMetaReq();
  virtual ~GetServerMetaReq();

  GetServerMetaReq(const GetServerMetaReq& from);

  inline GetServerMetaReq& operator=(const GetServerMetaReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetServerMetaReq& default_instance();

  void Swap(GetServerMetaReq* other);

  // implements Message ----------------------------------------------

  GetServerMetaReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetServerMetaReq& from);
  void MergeFrom(const GetServerMetaReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:exec.user.GetServerMetaReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static GetServerMetaReq* default_instance_;
};
// -------------------------------------------------------------------

class ConvertSupport : public ::google::protobuf::Message {
 public:
  ConvertSupport();
  virtual ~ConvertSupport();

  ConvertSupport(const ConvertSupport& from);

  inline ConvertSupport& operator=(const ConvertSupport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConvertSupport& default_instance();

  void Swap(ConvertSupport* other);

  // implements Message ----------------------------------------------

  ConvertSupport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConvertSupport& from);
  void MergeFrom(const ConvertSupport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.MinorType from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline ::common::MinorType from() const;
  inline void set_from(::common::MinorType value);

  // required .common.MinorType to = 2;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 2;
  inline ::common::MinorType to() const;
  inline void set_to(::common::MinorType value);

  // @@protoc_insertion_point(class_scope:exec.user.ConvertSupport)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int from_;
  int to_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static ConvertSupport* default_instance_;
};
// -------------------------------------------------------------------

class GetServerMetaResp : public ::google::protobuf::Message {
 public:
  GetServerMetaResp();
  virtual ~GetServerMetaResp();

  GetServerMetaResp(const GetServerMetaResp& from);

  inline GetServerMetaResp& operator=(const GetServerMetaResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetServerMetaResp& default_instance();

  void Swap(GetServerMetaResp* other);

  // implements Message ----------------------------------------------

  GetServerMetaResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetServerMetaResp& from);
  void MergeFrom(const GetServerMetaResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.user.RequestStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::exec::user::RequestStatus status() const;
  inline void set_status(::exec::user::RequestStatus value);

  // optional .exec.user.ServerMeta server_meta = 2;
  inline bool has_server_meta() const;
  inline void clear_server_meta();
  static const int kServerMetaFieldNumber = 2;
  inline const ::exec::user::ServerMeta& server_meta() const;
  inline ::exec::user::ServerMeta* mutable_server_meta();
  inline ::exec::user::ServerMeta* release_server_meta();
  inline void set_allocated_server_meta(::exec::user::ServerMeta* server_meta);

  // optional .exec.shared.DrillPBError error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::exec::shared::DrillPBError& error() const;
  inline ::exec::shared::DrillPBError* mutable_error();
  inline ::exec::shared::DrillPBError* release_error();
  inline void set_allocated_error(::exec::shared::DrillPBError* error);

  // @@protoc_insertion_point(class_scope:exec.user.GetServerMetaResp)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_server_meta();
  inline void clear_has_server_meta();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::exec::user::ServerMeta* server_meta_;
  ::exec::shared::DrillPBError* error_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static GetServerMetaResp* default_instance_;
};
// -------------------------------------------------------------------

class ServerMeta : public ::google::protobuf::Message {
 public:
  ServerMeta();
  virtual ~ServerMeta();

  ServerMeta(const ServerMeta& from);

  inline ServerMeta& operator=(const ServerMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerMeta& default_instance();

  void Swap(ServerMeta* other);

  // implements Message ----------------------------------------------

  ServerMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerMeta& from);
  void MergeFrom(const ServerMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool all_tables_selectable = 1;
  inline bool has_all_tables_selectable() const;
  inline void clear_all_tables_selectable();
  static const int kAllTablesSelectableFieldNumber = 1;
  inline bool all_tables_selectable() const;
  inline void set_all_tables_selectable(bool value);

  // optional bool blob_included_in_max_row_size = 2;
  inline bool has_blob_included_in_max_row_size() const;
  inline void clear_blob_included_in_max_row_size();
  static const int kBlobIncludedInMaxRowSizeFieldNumber = 2;
  inline bool blob_included_in_max_row_size() const;
  inline void set_blob_included_in_max_row_size(bool value);

  // optional bool catalog_at_start = 3;
  inline bool has_catalog_at_start() const;
  inline void clear_catalog_at_start();
  static const int kCatalogAtStartFieldNumber = 3;
  inline bool catalog_at_start() const;
  inline void set_catalog_at_start(bool value);

  // optional string catalog_separator = 4;
  inline bool has_catalog_separator() const;
  inline void clear_catalog_separator();
  static const int kCatalogSeparatorFieldNumber = 4;
  inline const ::std::string& catalog_separator() const;
  inline void set_catalog_separator(const ::std::string& value);
  inline void set_catalog_separator(const char* value);
  inline void set_catalog_separator(const char* value, size_t size);
  inline ::std::string* mutable_catalog_separator();
  inline ::std::string* release_catalog_separator();
  inline void set_allocated_catalog_separator(::std::string* catalog_separator);

  // optional string catalog_term = 5;
  inline bool has_catalog_term() const;
  inline void clear_catalog_term();
  static const int kCatalogTermFieldNumber = 5;
  inline const ::std::string& catalog_term() const;
  inline void set_catalog_term(const ::std::string& value);
  inline void set_catalog_term(const char* value);
  inline void set_catalog_term(const char* value, size_t size);
  inline ::std::string* mutable_catalog_term();
  inline ::std::string* release_catalog_term();
  inline void set_allocated_catalog_term(::std::string* catalog_term);

  // repeated .exec.user.CollateSupport collate_support = 6;
  inline int collate_support_size() const;
  inline void clear_collate_support();
  static const int kCollateSupportFieldNumber = 6;
  inline ::exec::user::CollateSupport collate_support(int index) const;
  inline void set_collate_support(int index, ::exec::user::CollateSupport value);
  inline void add_collate_support(::exec::user::CollateSupport value);
  inline const ::google::protobuf::RepeatedField<int>& collate_support() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_collate_support();

  // optional bool column_aliasing_supported = 7;
  inline bool has_column_aliasing_supported() const;
  inline void clear_column_aliasing_supported();
  static const int kColumnAliasingSupportedFieldNumber = 7;
  inline bool column_aliasing_supported() const;
  inline void set_column_aliasing_supported(bool value);

  // repeated .exec.user.ConvertSupport convert_support = 8;
  inline int convert_support_size() const;
  inline void clear_convert_support();
  static const int kConvertSupportFieldNumber = 8;
  inline const ::exec::user::ConvertSupport& convert_support(int index) const;
  inline ::exec::user::ConvertSupport* mutable_convert_support(int index);
  inline ::exec::user::ConvertSupport* add_convert_support();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::user::ConvertSupport >&
      convert_support() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::user::ConvertSupport >*
      mutable_convert_support();

  // optional .exec.user.CorrelationNamesSupport correlation_names_support = 9;
  inline bool has_correlation_names_support() const;
  inline void clear_correlation_names_support();
  static const int kCorrelationNamesSupportFieldNumber = 9;
  inline ::exec::user::CorrelationNamesSupport correlation_names_support() const;
  inline void set_correlation_names_support(::exec::user::CorrelationNamesSupport value);

  // repeated string date_time_functions = 10;
  inline int date_time_functions_size() const;
  inline void clear_date_time_functions();
  static const int kDateTimeFunctionsFieldNumber = 10;
  inline const ::std::string& date_time_functions(int index) const;
  inline ::std::string* mutable_date_time_functions(int index);
  inline void set_date_time_functions(int index, const ::std::string& value);
  inline void set_date_time_functions(int index, const char* value);
  inline void set_date_time_functions(int index, const char* value, size_t size);
  inline ::std::string* add_date_time_functions();
  inline void add_date_time_functions(const ::std::string& value);
  inline void add_date_time_functions(const char* value);
  inline void add_date_time_functions(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& date_time_functions() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_date_time_functions();

  // repeated .exec.user.DateTimeLiteralsSupport date_time_literals_support = 11;
  inline int date_time_literals_support_size() const;
  inline void clear_date_time_literals_support();
  static const int kDateTimeLiteralsSupportFieldNumber = 11;
  inline ::exec::user::DateTimeLiteralsSupport date_time_literals_support(int index) const;
  inline void set_date_time_literals_support(int index, ::exec::user::DateTimeLiteralsSupport value);
  inline void add_date_time_literals_support(::exec::user::DateTimeLiteralsSupport value);
  inline const ::google::protobuf::RepeatedField<int>& date_time_literals_support() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_date_time_literals_support();

  // optional .exec.user.GroupBySupport group_by_support = 12;
  inline bool has_group_by_support() const;
  inline void clear_group_by_support();
  static const int kGroupBySupportFieldNumber = 12;
  inline ::exec::user::GroupBySupport group_by_support() const;
  inline void set_group_by_support(::exec::user::GroupBySupport value);

  // optional .exec.user.IdentifierCasing identifier_casing = 13;
  inline bool has_identifier_casing() const;
  inline void clear_identifier_casing();
  static const int kIdentifierCasingFieldNumber = 13;
  inline ::exec::user::IdentifierCasing identifier_casing() const;
  inline void set_identifier_casing(::exec::user::IdentifierCasing value);

  // optional string identifier_quote_string = 14;
  inline bool has_identifier_quote_string() const;
  inline void clear_identifier_quote_string();
  static const int kIdentifierQuoteStringFieldNumber = 14;
  inline const ::std::string& identifier_quote_string() const;
  inline void set_identifier_quote_string(const ::std::string& value);
  inline void set_identifier_quote_string(const char* value);
  inline void set_identifier_quote_string(const char* value, size_t size);
  inline ::std::string* mutable_identifier_quote_string();
  inline ::std::string* release_identifier_quote_string();
  inline void set_allocated_identifier_quote_string(::std::string* identifier_quote_string);

  // optional bool like_escape_clause_supported = 15;
  inline bool has_like_escape_clause_supported() const;
  inline void clear_like_escape_clause_supported();
  static const int kLikeEscapeClauseSupportedFieldNumber = 15;
  inline bool like_escape_clause_supported() const;
  inline void set_like_escape_clause_supported(bool value);

  // optional uint32 max_binary_literal_length = 16;
  inline bool has_max_binary_literal_length() const;
  inline void clear_max_binary_literal_length();
  static const int kMaxBinaryLiteralLengthFieldNumber = 16;
  inline ::google::protobuf::uint32 max_binary_literal_length() const;
  inline void set_max_binary_literal_length(::google::protobuf::uint32 value);

  // optional uint32 max_catalog_name_length = 17;
  inline bool has_max_catalog_name_length() const;
  inline void clear_max_catalog_name_length();
  static const int kMaxCatalogNameLengthFieldNumber = 17;
  inline ::google::protobuf::uint32 max_catalog_name_length() const;
  inline void set_max_catalog_name_length(::google::protobuf::uint32 value);

  // optional uint32 max_char_literal_length = 18;
  inline bool has_max_char_literal_length() const;
  inline void clear_max_char_literal_length();
  static const int kMaxCharLiteralLengthFieldNumber = 18;
  inline ::google::protobuf::uint32 max_char_literal_length() const;
  inline void set_max_char_literal_length(::google::protobuf::uint32 value);

  // optional uint32 max_column_name_length = 19;
  inline bool has_max_column_name_length() const;
  inline void clear_max_column_name_length();
  static const int kMaxColumnNameLengthFieldNumber = 19;
  inline ::google::protobuf::uint32 max_column_name_length() const;
  inline void set_max_column_name_length(::google::protobuf::uint32 value);

  // optional uint32 max_columns_in_group_by = 20;
  inline bool has_max_columns_in_group_by() const;
  inline void clear_max_columns_in_group_by();
  static const int kMaxColumnsInGroupByFieldNumber = 20;
  inline ::google::protobuf::uint32 max_columns_in_group_by() const;
  inline void set_max_columns_in_group_by(::google::protobuf::uint32 value);

  // optional uint32 max_columns_in_order_by = 21;
  inline bool has_max_columns_in_order_by() const;
  inline void clear_max_columns_in_order_by();
  static const int kMaxColumnsInOrderByFieldNumber = 21;
  inline ::google::protobuf::uint32 max_columns_in_order_by() const;
  inline void set_max_columns_in_order_by(::google::protobuf::uint32 value);

  // optional uint32 max_columns_in_select = 22;
  inline bool has_max_columns_in_select() const;
  inline void clear_max_columns_in_select();
  static const int kMaxColumnsInSelectFieldNumber = 22;
  inline ::google::protobuf::uint32 max_columns_in_select() const;
  inline void set_max_columns_in_select(::google::protobuf::uint32 value);

  // optional uint32 max_cursor_name_length = 23;
  inline bool has_max_cursor_name_length() const;
  inline void clear_max_cursor_name_length();
  static const int kMaxCursorNameLengthFieldNumber = 23;
  inline ::google::protobuf::uint32 max_cursor_name_length() const;
  inline void set_max_cursor_name_length(::google::protobuf::uint32 value);

  // optional uint32 max_logical_lob_size = 24;
  inline bool has_max_logical_lob_size() const;
  inline void clear_max_logical_lob_size();
  static const int kMaxLogicalLobSizeFieldNumber = 24;
  inline ::google::protobuf::uint32 max_logical_lob_size() const;
  inline void set_max_logical_lob_size(::google::protobuf::uint32 value);

  // optional uint32 max_row_size = 25;
  inline bool has_max_row_size() const;
  inline void clear_max_row_size();
  static const int kMaxRowSizeFieldNumber = 25;
  inline ::google::protobuf::uint32 max_row_size() const;
  inline void set_max_row_size(::google::protobuf::uint32 value);

  // optional uint32 max_schema_name_length = 26;
  inline bool has_max_schema_name_length() const;
  inline void clear_max_schema_name_length();
  static const int kMaxSchemaNameLengthFieldNumber = 26;
  inline ::google::protobuf::uint32 max_schema_name_length() const;
  inline void set_max_schema_name_length(::google::protobuf::uint32 value);

  // optional uint32 max_statement_length = 27;
  inline bool has_max_statement_length() const;
  inline void clear_max_statement_length();
  static const int kMaxStatementLengthFieldNumber = 27;
  inline ::google::protobuf::uint32 max_statement_length() const;
  inline void set_max_statement_length(::google::protobuf::uint32 value);

  // optional uint32 max_statements = 28;
  inline bool has_max_statements() const;
  inline void clear_max_statements();
  static const int kMaxStatementsFieldNumber = 28;
  inline ::google::protobuf::uint32 max_statements() const;
  inline void set_max_statements(::google::protobuf::uint32 value);

  // optional uint32 max_table_name_length = 29;
  inline bool has_max_table_name_length() const;
  inline void clear_max_table_name_length();
  static const int kMaxTableNameLengthFieldNumber = 29;
  inline ::google::protobuf::uint32 max_table_name_length() const;
  inline void set_max_table_name_length(::google::protobuf::uint32 value);

  // optional uint32 max_tables_in_select = 30;
  inline bool has_max_tables_in_select() const;
  inline void clear_max_tables_in_select();
  static const int kMaxTablesInSelectFieldNumber = 30;
  inline ::google::protobuf::uint32 max_tables_in_select() const;
  inline void set_max_tables_in_select(::google::protobuf::uint32 value);

  // optional uint32 max_user_name_length = 31;
  inline bool has_max_user_name_length() const;
  inline void clear_max_user_name_length();
  static const int kMaxUserNameLengthFieldNumber = 31;
  inline ::google::protobuf::uint32 max_user_name_length() const;
  inline void set_max_user_name_length(::google::protobuf::uint32 value);

  // optional .exec.user.NullCollation null_collation = 32;
  inline bool has_null_collation() const;
  inline void clear_null_collation();
  static const int kNullCollationFieldNumber = 32;
  inline ::exec::user::NullCollation null_collation() const;
  inline void set_null_collation(::exec::user::NullCollation value);

  // optional bool null_plus_non_null_equals_null = 33;
  inline bool has_null_plus_non_null_equals_null() const;
  inline void clear_null_plus_non_null_equals_null();
  static const int kNullPlusNonNullEqualsNullFieldNumber = 33;
  inline bool null_plus_non_null_equals_null() const;
  inline void set_null_plus_non_null_equals_null(bool value);

  // repeated string numeric_functions = 34;
  inline int numeric_functions_size() const;
  inline void clear_numeric_functions();
  static const int kNumericFunctionsFieldNumber = 34;
  inline const ::std::string& numeric_functions(int index) const;
  inline ::std::string* mutable_numeric_functions(int index);
  inline void set_numeric_functions(int index, const ::std::string& value);
  inline void set_numeric_functions(int index, const char* value);
  inline void set_numeric_functions(int index, const char* value, size_t size);
  inline ::std::string* add_numeric_functions();
  inline void add_numeric_functions(const ::std::string& value);
  inline void add_numeric_functions(const char* value);
  inline void add_numeric_functions(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& numeric_functions() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_numeric_functions();

  // repeated .exec.user.OrderBySupport order_by_support = 35;
  inline int order_by_support_size() const;
  inline void clear_order_by_support();
  static const int kOrderBySupportFieldNumber = 35;
  inline ::exec::user::OrderBySupport order_by_support(int index) const;
  inline void set_order_by_support(int index, ::exec::user::OrderBySupport value);
  inline void add_order_by_support(::exec::user::OrderBySupport value);
  inline const ::google::protobuf::RepeatedField<int>& order_by_support() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_order_by_support();

  // repeated .exec.user.OuterJoinSupport outer_join_support = 36;
  inline int outer_join_support_size() const;
  inline void clear_outer_join_support();
  static const int kOuterJoinSupportFieldNumber = 36;
  inline ::exec::user::OuterJoinSupport outer_join_support(int index) const;
  inline void set_outer_join_support(int index, ::exec::user::OuterJoinSupport value);
  inline void add_outer_join_support(::exec::user::OuterJoinSupport value);
  inline const ::google::protobuf::RepeatedField<int>& outer_join_support() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_outer_join_support();

  // optional .exec.user.IdentifierCasing quoted_identifier_casing = 37;
  inline bool has_quoted_identifier_casing() const;
  inline void clear_quoted_identifier_casing();
  static const int kQuotedIdentifierCasingFieldNumber = 37;
  inline ::exec::user::IdentifierCasing quoted_identifier_casing() const;
  inline void set_quoted_identifier_casing(::exec::user::IdentifierCasing value);

  // optional bool read_only = 38;
  inline bool has_read_only() const;
  inline void clear_read_only();
  static const int kReadOnlyFieldNumber = 38;
  inline bool read_only() const;
  inline void set_read_only(bool value);

  // optional string schema_term = 39;
  inline bool has_schema_term() const;
  inline void clear_schema_term();
  static const int kSchemaTermFieldNumber = 39;
  inline const ::std::string& schema_term() const;
  inline void set_schema_term(const ::std::string& value);
  inline void set_schema_term(const char* value);
  inline void set_schema_term(const char* value, size_t size);
  inline ::std::string* mutable_schema_term();
  inline ::std::string* release_schema_term();
  inline void set_allocated_schema_term(::std::string* schema_term);

  // optional string search_escape_string = 40;
  inline bool has_search_escape_string() const;
  inline void clear_search_escape_string();
  static const int kSearchEscapeStringFieldNumber = 40;
  inline const ::std::string& search_escape_string() const;
  inline void set_search_escape_string(const ::std::string& value);
  inline void set_search_escape_string(const char* value);
  inline void set_search_escape_string(const char* value, size_t size);
  inline ::std::string* mutable_search_escape_string();
  inline ::std::string* release_search_escape_string();
  inline void set_allocated_search_escape_string(::std::string* search_escape_string);

  // optional bool select_for_update_supported = 41;
  inline bool has_select_for_update_supported() const;
  inline void clear_select_for_update_supported();
  static const int kSelectForUpdateSupportedFieldNumber = 41;
  inline bool select_for_update_supported() const;
  inline void set_select_for_update_supported(bool value);

  // optional string special_characters = 42;
  inline bool has_special_characters() const;
  inline void clear_special_characters();
  static const int kSpecialCharactersFieldNumber = 42;
  inline const ::std::string& special_characters() const;
  inline void set_special_characters(const ::std::string& value);
  inline void set_special_characters(const char* value);
  inline void set_special_characters(const char* value, size_t size);
  inline ::std::string* mutable_special_characters();
  inline ::std::string* release_special_characters();
  inline void set_allocated_special_characters(::std::string* special_characters);

  // repeated string sql_keywords = 43;
  inline int sql_keywords_size() const;
  inline void clear_sql_keywords();
  static const int kSqlKeywordsFieldNumber = 43;
  inline const ::std::string& sql_keywords(int index) const;
  inline ::std::string* mutable_sql_keywords(int index);
  inline void set_sql_keywords(int index, const ::std::string& value);
  inline void set_sql_keywords(int index, const char* value);
  inline void set_sql_keywords(int index, const char* value, size_t size);
  inline ::std::string* add_sql_keywords();
  inline void add_sql_keywords(const ::std::string& value);
  inline void add_sql_keywords(const char* value);
  inline void add_sql_keywords(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& sql_keywords() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sql_keywords();

  // repeated string string_functions = 44;
  inline int string_functions_size() const;
  inline void clear_string_functions();
  static const int kStringFunctionsFieldNumber = 44;
  inline const ::std::string& string_functions(int index) const;
  inline ::std::string* mutable_string_functions(int index);
  inline void set_string_functions(int index, const ::std::string& value);
  inline void set_string_functions(int index, const char* value);
  inline void set_string_functions(int index, const char* value, size_t size);
  inline ::std::string* add_string_functions();
  inline void add_string_functions(const ::std::string& value);
  inline void add_string_functions(const char* value);
  inline void add_string_functions(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& string_functions() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_string_functions();

  // repeated .exec.user.SubQuerySupport subquery_support = 45;
  inline int subquery_support_size() const;
  inline void clear_subquery_support();
  static const int kSubquerySupportFieldNumber = 45;
  inline ::exec::user::SubQuerySupport subquery_support(int index) const;
  inline void set_subquery_support(int index, ::exec::user::SubQuerySupport value);
  inline void add_subquery_support(::exec::user::SubQuerySupport value);
  inline const ::google::protobuf::RepeatedField<int>& subquery_support() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_subquery_support();

  // repeated string system_functions = 46;
  inline int system_functions_size() const;
  inline void clear_system_functions();
  static const int kSystemFunctionsFieldNumber = 46;
  inline const ::std::string& system_functions(int index) const;
  inline ::std::string* mutable_system_functions(int index);
  inline void set_system_functions(int index, const ::std::string& value);
  inline void set_system_functions(int index, const char* value);
  inline void set_system_functions(int index, const char* value, size_t size);
  inline ::std::string* add_system_functions();
  inline void add_system_functions(const ::std::string& value);
  inline void add_system_functions(const char* value);
  inline void add_system_functions(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& system_functions() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_system_functions();

  // optional string table_term = 47;
  inline bool has_table_term() const;
  inline void clear_table_term();
  static const int kTableTermFieldNumber = 47;
  inline const ::std::string& table_term() const;
  inline void set_table_term(const ::std::string& value);
  inline void set_table_term(const char* value);
  inline void set_table_term(const char* value, size_t size);
  inline ::std::string* mutable_table_term();
  inline ::std::string* release_table_term();
  inline void set_allocated_table_term(::std::string* table_term);

  // optional bool transaction_supported = 48;
  inline bool has_transaction_supported() const;
  inline void clear_transaction_supported();
  static const int kTransactionSupportedFieldNumber = 48;
  inline bool transaction_supported() const;
  inline void set_transaction_supported(bool value);

  // repeated .exec.user.UnionSupport union_support = 49;
  inline int union_support_size() const;
  inline void clear_union_support();
  static const int kUnionSupportFieldNumber = 49;
  inline ::exec::user::UnionSupport union_support(int index) const;
  inline void set_union_support(int index, ::exec::user::UnionSupport value);
  inline void add_union_support(::exec::user::UnionSupport value);
  inline const ::google::protobuf::RepeatedField<int>& union_support() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_union_support();

  // optional string current_schema = 50;
  inline bool has_current_schema() const;
  inline void clear_current_schema();
  static const int kCurrentSchemaFieldNumber = 50;
  inline const ::std::string& current_schema() const;
  inline void set_current_schema(const ::std::string& value);
  inline void set_current_schema(const char* value);
  inline void set_current_schema(const char* value, size_t size);
  inline ::std::string* mutable_current_schema();
  inline ::std::string* release_current_schema();
  inline void set_allocated_current_schema(::std::string* current_schema);

  // @@protoc_insertion_point(class_scope:exec.user.ServerMeta)
 private:
  inline void set_has_all_tables_selectable();
  inline void clear_has_all_tables_selectable();
  inline void set_has_blob_included_in_max_row_size();
  inline void clear_has_blob_included_in_max_row_size();
  inline void set_has_catalog_at_start();
  inline void clear_has_catalog_at_start();
  inline void set_has_catalog_separator();
  inline void clear_has_catalog_separator();
  inline void set_has_catalog_term();
  inline void clear_has_catalog_term();
  inline void set_has_column_aliasing_supported();
  inline void clear_has_column_aliasing_supported();
  inline void set_has_correlation_names_support();
  inline void clear_has_correlation_names_support();
  inline void set_has_group_by_support();
  inline void clear_has_group_by_support();
  inline void set_has_identifier_casing();
  inline void clear_has_identifier_casing();
  inline void set_has_identifier_quote_string();
  inline void clear_has_identifier_quote_string();
  inline void set_has_like_escape_clause_supported();
  inline void clear_has_like_escape_clause_supported();
  inline void set_has_max_binary_literal_length();
  inline void clear_has_max_binary_literal_length();
  inline void set_has_max_catalog_name_length();
  inline void clear_has_max_catalog_name_length();
  inline void set_has_max_char_literal_length();
  inline void clear_has_max_char_literal_length();
  inline void set_has_max_column_name_length();
  inline void clear_has_max_column_name_length();
  inline void set_has_max_columns_in_group_by();
  inline void clear_has_max_columns_in_group_by();
  inline void set_has_max_columns_in_order_by();
  inline void clear_has_max_columns_in_order_by();
  inline void set_has_max_columns_in_select();
  inline void clear_has_max_columns_in_select();
  inline void set_has_max_cursor_name_length();
  inline void clear_has_max_cursor_name_length();
  inline void set_has_max_logical_lob_size();
  inline void clear_has_max_logical_lob_size();
  inline void set_has_max_row_size();
  inline void clear_has_max_row_size();
  inline void set_has_max_schema_name_length();
  inline void clear_has_max_schema_name_length();
  inline void set_has_max_statement_length();
  inline void clear_has_max_statement_length();
  inline void set_has_max_statements();
  inline void clear_has_max_statements();
  inline void set_has_max_table_name_length();
  inline void clear_has_max_table_name_length();
  inline void set_has_max_tables_in_select();
  inline void clear_has_max_tables_in_select();
  inline void set_has_max_user_name_length();
  inline void clear_has_max_user_name_length();
  inline void set_has_null_collation();
  inline void clear_has_null_collation();
  inline void set_has_null_plus_non_null_equals_null();
  inline void clear_has_null_plus_non_null_equals_null();
  inline void set_has_quoted_identifier_casing();
  inline void clear_has_quoted_identifier_casing();
  inline void set_has_read_only();
  inline void clear_has_read_only();
  inline void set_has_schema_term();
  inline void clear_has_schema_term();
  inline void set_has_search_escape_string();
  inline void clear_has_search_escape_string();
  inline void set_has_select_for_update_supported();
  inline void clear_has_select_for_update_supported();
  inline void set_has_special_characters();
  inline void clear_has_special_characters();
  inline void set_has_table_term();
  inline void clear_has_table_term();
  inline void set_has_transaction_supported();
  inline void clear_has_transaction_supported();
  inline void set_has_current_schema();
  inline void clear_has_current_schema();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* catalog_separator_;
  bool all_tables_selectable_;
  bool blob_included_in_max_row_size_;
  bool catalog_at_start_;
  bool column_aliasing_supported_;
  int correlation_names_support_;
  ::std::string* catalog_term_;
  ::google::protobuf::RepeatedField<int> collate_support_;
  ::google::protobuf::RepeatedPtrField< ::exec::user::ConvertSupport > convert_support_;
  ::google::protobuf::RepeatedPtrField< ::std::string> date_time_functions_;
  ::google::protobuf::RepeatedField<int> date_time_literals_support_;
  int group_by_support_;
  int identifier_casing_;
  ::std::string* identifier_quote_string_;
  ::google::protobuf::uint32 max_binary_literal_length_;
  ::google::protobuf::uint32 max_catalog_name_length_;
  ::google::protobuf::uint32 max_char_literal_length_;
  ::google::protobuf::uint32 max_column_name_length_;
  ::google::protobuf::uint32 max_columns_in_group_by_;
  ::google::protobuf::uint32 max_columns_in_order_by_;
  ::google::protobuf::uint32 max_columns_in_select_;
  ::google::protobuf::uint32 max_cursor_name_length_;
  ::google::protobuf::uint32 max_logical_lob_size_;
  ::google::protobuf::uint32 max_row_size_;
  ::google::protobuf::uint32 max_schema_name_length_;
  ::google::protobuf::uint32 max_statement_length_;
  ::google::protobuf::uint32 max_statements_;
  ::google::protobuf::uint32 max_table_name_length_;
  ::google::protobuf::uint32 max_tables_in_select_;
  ::google::protobuf::uint32 max_user_name_length_;
  bool like_escape_clause_supported_;
  bool null_plus_non_null_equals_null_;
  bool read_only_;
  bool select_for_update_supported_;
  int null_collation_;
  ::google::protobuf::RepeatedPtrField< ::std::string> numeric_functions_;
  ::google::protobuf::RepeatedField<int> order_by_support_;
  ::google::protobuf::RepeatedField<int> outer_join_support_;
  ::std::string* schema_term_;
  ::std::string* search_escape_string_;
  ::std::string* special_characters_;
  int quoted_identifier_casing_;
  bool transaction_supported_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sql_keywords_;
  ::google::protobuf::RepeatedPtrField< ::std::string> string_functions_;
  ::google::protobuf::RepeatedField<int> subquery_support_;
  ::google::protobuf::RepeatedPtrField< ::std::string> system_functions_;
  ::std::string* table_term_;
  ::google::protobuf::RepeatedField<int> union_support_;
  ::std::string* current_schema_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(50 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static ServerMeta* default_instance_;
};
// -------------------------------------------------------------------

class RunQuery : public ::google::protobuf::Message {
 public:
  RunQuery();
  virtual ~RunQuery();

  RunQuery(const RunQuery& from);

  inline RunQuery& operator=(const RunQuery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RunQuery& default_instance();

  void Swap(RunQuery* other);

  // implements Message ----------------------------------------------

  RunQuery* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RunQuery& from);
  void MergeFrom(const RunQuery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.user.QueryResultsMode results_mode = 1;
  inline bool has_results_mode() const;
  inline void clear_results_mode();
  static const int kResultsModeFieldNumber = 1;
  inline ::exec::user::QueryResultsMode results_mode() const;
  inline void set_results_mode(::exec::user::QueryResultsMode value);

  // optional .exec.shared.QueryType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::exec::shared::QueryType type() const;
  inline void set_type(::exec::shared::QueryType value);

  // optional string plan = 3;
  inline bool has_plan() const;
  inline void clear_plan();
  static const int kPlanFieldNumber = 3;
  inline const ::std::string& plan() const;
  inline void set_plan(const ::std::string& value);
  inline void set_plan(const char* value);
  inline void set_plan(const char* value, size_t size);
  inline ::std::string* mutable_plan();
  inline ::std::string* release_plan();
  inline void set_allocated_plan(::std::string* plan);

  // repeated .exec.bit.control.PlanFragment fragments = 4;
  inline int fragments_size() const;
  inline void clear_fragments();
  static const int kFragmentsFieldNumber = 4;
  inline const ::exec::bit::control::PlanFragment& fragments(int index) const;
  inline ::exec::bit::control::PlanFragment* mutable_fragments(int index);
  inline ::exec::bit::control::PlanFragment* add_fragments();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment >&
      fragments() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment >*
      mutable_fragments();

  // optional .exec.user.PreparedStatementHandle prepared_statement_handle = 5;
  inline bool has_prepared_statement_handle() const;
  inline void clear_prepared_statement_handle();
  static const int kPreparedStatementHandleFieldNumber = 5;
  inline const ::exec::user::PreparedStatementHandle& prepared_statement_handle() const;
  inline ::exec::user::PreparedStatementHandle* mutable_prepared_statement_handle();
  inline ::exec::user::PreparedStatementHandle* release_prepared_statement_handle();
  inline void set_allocated_prepared_statement_handle(::exec::user::PreparedStatementHandle* prepared_statement_handle);

  // @@protoc_insertion_point(class_scope:exec.user.RunQuery)
 private:
  inline void set_has_results_mode();
  inline void clear_has_results_mode();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_plan();
  inline void clear_has_plan();
  inline void set_has_prepared_statement_handle();
  inline void clear_has_prepared_statement_handle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int results_mode_;
  int type_;
  ::std::string* plan_;
  ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment > fragments_;
  ::exec::user::PreparedStatementHandle* prepared_statement_handle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_User_2eproto();
  friend void protobuf_AssignDesc_User_2eproto();
  friend void protobuf_ShutdownFile_User_2eproto();

  void InitAsDefaultInstance();
  static RunQuery* default_instance_;
};
// ===================================================================


// ===================================================================

// Property

// required string key = 1;
inline bool Property::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Property::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Property::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Property::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Property::key() const {
  return *key_;
}
inline void Property::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Property::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Property::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Property::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Property::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Property::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool Property::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Property::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Property::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Property::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Property::value() const {
  return *value_;
}
inline void Property::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Property::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Property::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Property::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Property::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Property::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserProperties

// repeated .exec.user.Property properties = 1;
inline int UserProperties::properties_size() const {
  return properties_.size();
}
inline void UserProperties::clear_properties() {
  properties_.Clear();
}
inline const ::exec::user::Property& UserProperties::properties(int index) const {
  return properties_.Get(index);
}
inline ::exec::user::Property* UserProperties::mutable_properties(int index) {
  return properties_.Mutable(index);
}
inline ::exec::user::Property* UserProperties::add_properties() {
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::user::Property >&
UserProperties::properties() const {
  return properties_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::user::Property >*
UserProperties::mutable_properties() {
  return &properties_;
}

// -------------------------------------------------------------------

// RpcEndpointInfos

// optional string name = 1;
inline bool RpcEndpointInfos::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpcEndpointInfos::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpcEndpointInfos::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpcEndpointInfos::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RpcEndpointInfos::name() const {
  return *name_;
}
inline void RpcEndpointInfos::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RpcEndpointInfos::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RpcEndpointInfos::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpcEndpointInfos::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RpcEndpointInfos::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RpcEndpointInfos::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 2;
inline bool RpcEndpointInfos::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpcEndpointInfos::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpcEndpointInfos::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpcEndpointInfos::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& RpcEndpointInfos::version() const {
  return *version_;
}
inline void RpcEndpointInfos::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void RpcEndpointInfos::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void RpcEndpointInfos::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpcEndpointInfos::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* RpcEndpointInfos::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RpcEndpointInfos::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 majorVersion = 3;
inline bool RpcEndpointInfos::has_majorversion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpcEndpointInfos::set_has_majorversion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpcEndpointInfos::clear_has_majorversion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpcEndpointInfos::clear_majorversion() {
  majorversion_ = 0u;
  clear_has_majorversion();
}
inline ::google::protobuf::uint32 RpcEndpointInfos::majorversion() const {
  return majorversion_;
}
inline void RpcEndpointInfos::set_majorversion(::google::protobuf::uint32 value) {
  set_has_majorversion();
  majorversion_ = value;
}

// optional uint32 minorVersion = 4;
inline bool RpcEndpointInfos::has_minorversion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpcEndpointInfos::set_has_minorversion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpcEndpointInfos::clear_has_minorversion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpcEndpointInfos::clear_minorversion() {
  minorversion_ = 0u;
  clear_has_minorversion();
}
inline ::google::protobuf::uint32 RpcEndpointInfos::minorversion() const {
  return minorversion_;
}
inline void RpcEndpointInfos::set_minorversion(::google::protobuf::uint32 value) {
  set_has_minorversion();
  minorversion_ = value;
}

// optional uint32 patchVersion = 5;
inline bool RpcEndpointInfos::has_patchversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpcEndpointInfos::set_has_patchversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpcEndpointInfos::clear_has_patchversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpcEndpointInfos::clear_patchversion() {
  patchversion_ = 0u;
  clear_has_patchversion();
}
inline ::google::protobuf::uint32 RpcEndpointInfos::patchversion() const {
  return patchversion_;
}
inline void RpcEndpointInfos::set_patchversion(::google::protobuf::uint32 value) {
  set_has_patchversion();
  patchversion_ = value;
}

// optional string application = 6;
inline bool RpcEndpointInfos::has_application() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpcEndpointInfos::set_has_application() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpcEndpointInfos::clear_has_application() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpcEndpointInfos::clear_application() {
  if (application_ != &::google::protobuf::internal::kEmptyString) {
    application_->clear();
  }
  clear_has_application();
}
inline const ::std::string& RpcEndpointInfos::application() const {
  return *application_;
}
inline void RpcEndpointInfos::set_application(const ::std::string& value) {
  set_has_application();
  if (application_ == &::google::protobuf::internal::kEmptyString) {
    application_ = new ::std::string;
  }
  application_->assign(value);
}
inline void RpcEndpointInfos::set_application(const char* value) {
  set_has_application();
  if (application_ == &::google::protobuf::internal::kEmptyString) {
    application_ = new ::std::string;
  }
  application_->assign(value);
}
inline void RpcEndpointInfos::set_application(const char* value, size_t size) {
  set_has_application();
  if (application_ == &::google::protobuf::internal::kEmptyString) {
    application_ = new ::std::string;
  }
  application_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpcEndpointInfos::mutable_application() {
  set_has_application();
  if (application_ == &::google::protobuf::internal::kEmptyString) {
    application_ = new ::std::string;
  }
  return application_;
}
inline ::std::string* RpcEndpointInfos::release_application() {
  clear_has_application();
  if (application_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = application_;
    application_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RpcEndpointInfos::set_allocated_application(::std::string* application) {
  if (application_ != &::google::protobuf::internal::kEmptyString) {
    delete application_;
  }
  if (application) {
    set_has_application();
    application_ = application;
  } else {
    clear_has_application();
    application_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 buildNumber = 7;
inline bool RpcEndpointInfos::has_buildnumber() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpcEndpointInfos::set_has_buildnumber() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpcEndpointInfos::clear_has_buildnumber() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpcEndpointInfos::clear_buildnumber() {
  buildnumber_ = 0u;
  clear_has_buildnumber();
}
inline ::google::protobuf::uint32 RpcEndpointInfos::buildnumber() const {
  return buildnumber_;
}
inline void RpcEndpointInfos::set_buildnumber(::google::protobuf::uint32 value) {
  set_has_buildnumber();
  buildnumber_ = value;
}

// optional string versionQualifier = 8;
inline bool RpcEndpointInfos::has_versionqualifier() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpcEndpointInfos::set_has_versionqualifier() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpcEndpointInfos::clear_has_versionqualifier() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpcEndpointInfos::clear_versionqualifier() {
  if (versionqualifier_ != &::google::protobuf::internal::kEmptyString) {
    versionqualifier_->clear();
  }
  clear_has_versionqualifier();
}
inline const ::std::string& RpcEndpointInfos::versionqualifier() const {
  return *versionqualifier_;
}
inline void RpcEndpointInfos::set_versionqualifier(const ::std::string& value) {
  set_has_versionqualifier();
  if (versionqualifier_ == &::google::protobuf::internal::kEmptyString) {
    versionqualifier_ = new ::std::string;
  }
  versionqualifier_->assign(value);
}
inline void RpcEndpointInfos::set_versionqualifier(const char* value) {
  set_has_versionqualifier();
  if (versionqualifier_ == &::google::protobuf::internal::kEmptyString) {
    versionqualifier_ = new ::std::string;
  }
  versionqualifier_->assign(value);
}
inline void RpcEndpointInfos::set_versionqualifier(const char* value, size_t size) {
  set_has_versionqualifier();
  if (versionqualifier_ == &::google::protobuf::internal::kEmptyString) {
    versionqualifier_ = new ::std::string;
  }
  versionqualifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpcEndpointInfos::mutable_versionqualifier() {
  set_has_versionqualifier();
  if (versionqualifier_ == &::google::protobuf::internal::kEmptyString) {
    versionqualifier_ = new ::std::string;
  }
  return versionqualifier_;
}
inline ::std::string* RpcEndpointInfos::release_versionqualifier() {
  clear_has_versionqualifier();
  if (versionqualifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = versionqualifier_;
    versionqualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RpcEndpointInfos::set_allocated_versionqualifier(::std::string* versionqualifier) {
  if (versionqualifier_ != &::google::protobuf::internal::kEmptyString) {
    delete versionqualifier_;
  }
  if (versionqualifier) {
    set_has_versionqualifier();
    versionqualifier_ = versionqualifier;
  } else {
    clear_has_versionqualifier();
    versionqualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserToBitHandshake

// optional .exec.shared.RpcChannel channel = 1 [default = USER];
inline bool UserToBitHandshake::has_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserToBitHandshake::set_has_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserToBitHandshake::clear_has_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserToBitHandshake::clear_channel() {
  channel_ = 2;
  clear_has_channel();
}
inline ::exec::shared::RpcChannel UserToBitHandshake::channel() const {
  return static_cast< ::exec::shared::RpcChannel >(channel_);
}
inline void UserToBitHandshake::set_channel(::exec::shared::RpcChannel value) {
  assert(::exec::shared::RpcChannel_IsValid(value));
  set_has_channel();
  channel_ = value;
}

// optional bool support_listening = 2;
inline bool UserToBitHandshake::has_support_listening() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserToBitHandshake::set_has_support_listening() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserToBitHandshake::clear_has_support_listening() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserToBitHandshake::clear_support_listening() {
  support_listening_ = false;
  clear_has_support_listening();
}
inline bool UserToBitHandshake::support_listening() const {
  return support_listening_;
}
inline void UserToBitHandshake::set_support_listening(bool value) {
  set_has_support_listening();
  support_listening_ = value;
}

// optional int32 rpc_version = 3;
inline bool UserToBitHandshake::has_rpc_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserToBitHandshake::set_has_rpc_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserToBitHandshake::clear_has_rpc_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserToBitHandshake::clear_rpc_version() {
  rpc_version_ = 0;
  clear_has_rpc_version();
}
inline ::google::protobuf::int32 UserToBitHandshake::rpc_version() const {
  return rpc_version_;
}
inline void UserToBitHandshake::set_rpc_version(::google::protobuf::int32 value) {
  set_has_rpc_version();
  rpc_version_ = value;
}

// optional .exec.shared.UserCredentials credentials = 4;
inline bool UserToBitHandshake::has_credentials() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserToBitHandshake::set_has_credentials() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserToBitHandshake::clear_has_credentials() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserToBitHandshake::clear_credentials() {
  if (credentials_ != NULL) credentials_->::exec::shared::UserCredentials::Clear();
  clear_has_credentials();
}
inline const ::exec::shared::UserCredentials& UserToBitHandshake::credentials() const {
  return credentials_ != NULL ? *credentials_ : *default_instance_->credentials_;
}
inline ::exec::shared::UserCredentials* UserToBitHandshake::mutable_credentials() {
  set_has_credentials();
  if (credentials_ == NULL) credentials_ = new ::exec::shared::UserCredentials;
  return credentials_;
}
inline ::exec::shared::UserCredentials* UserToBitHandshake::release_credentials() {
  clear_has_credentials();
  ::exec::shared::UserCredentials* temp = credentials_;
  credentials_ = NULL;
  return temp;
}
inline void UserToBitHandshake::set_allocated_credentials(::exec::shared::UserCredentials* credentials) {
  delete credentials_;
  credentials_ = credentials;
  if (credentials) {
    set_has_credentials();
  } else {
    clear_has_credentials();
  }
}

// optional .exec.user.UserProperties properties = 5;
inline bool UserToBitHandshake::has_properties() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserToBitHandshake::set_has_properties() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserToBitHandshake::clear_has_properties() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserToBitHandshake::clear_properties() {
  if (properties_ != NULL) properties_->::exec::user::UserProperties::Clear();
  clear_has_properties();
}
inline const ::exec::user::UserProperties& UserToBitHandshake::properties() const {
  return properties_ != NULL ? *properties_ : *default_instance_->properties_;
}
inline ::exec::user::UserProperties* UserToBitHandshake::mutable_properties() {
  set_has_properties();
  if (properties_ == NULL) properties_ = new ::exec::user::UserProperties;
  return properties_;
}
inline ::exec::user::UserProperties* UserToBitHandshake::release_properties() {
  clear_has_properties();
  ::exec::user::UserProperties* temp = properties_;
  properties_ = NULL;
  return temp;
}
inline void UserToBitHandshake::set_allocated_properties(::exec::user::UserProperties* properties) {
  delete properties_;
  properties_ = properties;
  if (properties) {
    set_has_properties();
  } else {
    clear_has_properties();
  }
}

// optional bool support_complex_types = 6 [default = false];
inline bool UserToBitHandshake::has_support_complex_types() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserToBitHandshake::set_has_support_complex_types() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserToBitHandshake::clear_has_support_complex_types() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserToBitHandshake::clear_support_complex_types() {
  support_complex_types_ = false;
  clear_has_support_complex_types();
}
inline bool UserToBitHandshake::support_complex_types() const {
  return support_complex_types_;
}
inline void UserToBitHandshake::set_support_complex_types(bool value) {
  set_has_support_complex_types();
  support_complex_types_ = value;
}

// optional bool support_timeout = 7 [default = false];
inline bool UserToBitHandshake::has_support_timeout() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserToBitHandshake::set_has_support_timeout() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserToBitHandshake::clear_has_support_timeout() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserToBitHandshake::clear_support_timeout() {
  support_timeout_ = false;
  clear_has_support_timeout();
}
inline bool UserToBitHandshake::support_timeout() const {
  return support_timeout_;
}
inline void UserToBitHandshake::set_support_timeout(bool value) {
  set_has_support_timeout();
  support_timeout_ = value;
}

// optional .exec.user.RpcEndpointInfos client_infos = 8;
inline bool UserToBitHandshake::has_client_infos() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserToBitHandshake::set_has_client_infos() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserToBitHandshake::clear_has_client_infos() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserToBitHandshake::clear_client_infos() {
  if (client_infos_ != NULL) client_infos_->::exec::user::RpcEndpointInfos::Clear();
  clear_has_client_infos();
}
inline const ::exec::user::RpcEndpointInfos& UserToBitHandshake::client_infos() const {
  return client_infos_ != NULL ? *client_infos_ : *default_instance_->client_infos_;
}
inline ::exec::user::RpcEndpointInfos* UserToBitHandshake::mutable_client_infos() {
  set_has_client_infos();
  if (client_infos_ == NULL) client_infos_ = new ::exec::user::RpcEndpointInfos;
  return client_infos_;
}
inline ::exec::user::RpcEndpointInfos* UserToBitHandshake::release_client_infos() {
  clear_has_client_infos();
  ::exec::user::RpcEndpointInfos* temp = client_infos_;
  client_infos_ = NULL;
  return temp;
}
inline void UserToBitHandshake::set_allocated_client_infos(::exec::user::RpcEndpointInfos* client_infos) {
  delete client_infos_;
  client_infos_ = client_infos;
  if (client_infos) {
    set_has_client_infos();
  } else {
    clear_has_client_infos();
  }
}

// optional .exec.user.SaslSupport sasl_support = 9;
inline bool UserToBitHandshake::has_sasl_support() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserToBitHandshake::set_has_sasl_support() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserToBitHandshake::clear_has_sasl_support() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserToBitHandshake::clear_sasl_support() {
  sasl_support_ = 0;
  clear_has_sasl_support();
}
inline ::exec::user::SaslSupport UserToBitHandshake::sasl_support() const {
  return static_cast< ::exec::user::SaslSupport >(sasl_support_);
}
inline void UserToBitHandshake::set_sasl_support(::exec::user::SaslSupport value) {
  assert(::exec::user::SaslSupport_IsValid(value));
  set_has_sasl_support();
  sasl_support_ = value;
}

// -------------------------------------------------------------------

// RequestResults

// optional .exec.shared.QueryId query_id = 1;
inline bool RequestResults::has_query_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestResults::set_has_query_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestResults::clear_has_query_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestResults::clear_query_id() {
  if (query_id_ != NULL) query_id_->::exec::shared::QueryId::Clear();
  clear_has_query_id();
}
inline const ::exec::shared::QueryId& RequestResults::query_id() const {
  return query_id_ != NULL ? *query_id_ : *default_instance_->query_id_;
}
inline ::exec::shared::QueryId* RequestResults::mutable_query_id() {
  set_has_query_id();
  if (query_id_ == NULL) query_id_ = new ::exec::shared::QueryId;
  return query_id_;
}
inline ::exec::shared::QueryId* RequestResults::release_query_id() {
  clear_has_query_id();
  ::exec::shared::QueryId* temp = query_id_;
  query_id_ = NULL;
  return temp;
}
inline void RequestResults::set_allocated_query_id(::exec::shared::QueryId* query_id) {
  delete query_id_;
  query_id_ = query_id;
  if (query_id) {
    set_has_query_id();
  } else {
    clear_has_query_id();
  }
}

// optional int32 maximum_responses = 2;
inline bool RequestResults::has_maximum_responses() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestResults::set_has_maximum_responses() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestResults::clear_has_maximum_responses() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestResults::clear_maximum_responses() {
  maximum_responses_ = 0;
  clear_has_maximum_responses();
}
inline ::google::protobuf::int32 RequestResults::maximum_responses() const {
  return maximum_responses_;
}
inline void RequestResults::set_maximum_responses(::google::protobuf::int32 value) {
  set_has_maximum_responses();
  maximum_responses_ = value;
}

// -------------------------------------------------------------------

// GetQueryPlanFragments

// required string query = 1;
inline bool GetQueryPlanFragments::has_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetQueryPlanFragments::set_has_query() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetQueryPlanFragments::clear_has_query() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetQueryPlanFragments::clear_query() {
  if (query_ != &::google::protobuf::internal::kEmptyString) {
    query_->clear();
  }
  clear_has_query();
}
inline const ::std::string& GetQueryPlanFragments::query() const {
  return *query_;
}
inline void GetQueryPlanFragments::set_query(const ::std::string& value) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(value);
}
inline void GetQueryPlanFragments::set_query(const char* value) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(value);
}
inline void GetQueryPlanFragments::set_query(const char* value, size_t size) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetQueryPlanFragments::mutable_query() {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  return query_;
}
inline ::std::string* GetQueryPlanFragments::release_query() {
  clear_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = query_;
    query_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetQueryPlanFragments::set_allocated_query(::std::string* query) {
  if (query_ != &::google::protobuf::internal::kEmptyString) {
    delete query_;
  }
  if (query) {
    set_has_query();
    query_ = query;
  } else {
    clear_has_query();
    query_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .exec.shared.QueryType type = 2;
inline bool GetQueryPlanFragments::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetQueryPlanFragments::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetQueryPlanFragments::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetQueryPlanFragments::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::exec::shared::QueryType GetQueryPlanFragments::type() const {
  return static_cast< ::exec::shared::QueryType >(type_);
}
inline void GetQueryPlanFragments::set_type(::exec::shared::QueryType value) {
  assert(::exec::shared::QueryType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bool split_plan = 3 [default = false];
inline bool GetQueryPlanFragments::has_split_plan() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetQueryPlanFragments::set_has_split_plan() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetQueryPlanFragments::clear_has_split_plan() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetQueryPlanFragments::clear_split_plan() {
  split_plan_ = false;
  clear_has_split_plan();
}
inline bool GetQueryPlanFragments::split_plan() const {
  return split_plan_;
}
inline void GetQueryPlanFragments::set_split_plan(bool value) {
  set_has_split_plan();
  split_plan_ = value;
}

// -------------------------------------------------------------------

// QueryPlanFragments

// required .exec.shared.QueryResult.QueryState status = 1;
inline bool QueryPlanFragments::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryPlanFragments::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryPlanFragments::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryPlanFragments::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::exec::shared::QueryResult_QueryState QueryPlanFragments::status() const {
  return static_cast< ::exec::shared::QueryResult_QueryState >(status_);
}
inline void QueryPlanFragments::set_status(::exec::shared::QueryResult_QueryState value) {
  assert(::exec::shared::QueryResult_QueryState_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .exec.shared.QueryId query_id = 2;
inline bool QueryPlanFragments::has_query_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryPlanFragments::set_has_query_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryPlanFragments::clear_has_query_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryPlanFragments::clear_query_id() {
  if (query_id_ != NULL) query_id_->::exec::shared::QueryId::Clear();
  clear_has_query_id();
}
inline const ::exec::shared::QueryId& QueryPlanFragments::query_id() const {
  return query_id_ != NULL ? *query_id_ : *default_instance_->query_id_;
}
inline ::exec::shared::QueryId* QueryPlanFragments::mutable_query_id() {
  set_has_query_id();
  if (query_id_ == NULL) query_id_ = new ::exec::shared::QueryId;
  return query_id_;
}
inline ::exec::shared::QueryId* QueryPlanFragments::release_query_id() {
  clear_has_query_id();
  ::exec::shared::QueryId* temp = query_id_;
  query_id_ = NULL;
  return temp;
}
inline void QueryPlanFragments::set_allocated_query_id(::exec::shared::QueryId* query_id) {
  delete query_id_;
  query_id_ = query_id;
  if (query_id) {
    set_has_query_id();
  } else {
    clear_has_query_id();
  }
}

// repeated .exec.bit.control.PlanFragment fragments = 3;
inline int QueryPlanFragments::fragments_size() const {
  return fragments_.size();
}
inline void QueryPlanFragments::clear_fragments() {
  fragments_.Clear();
}
inline const ::exec::bit::control::PlanFragment& QueryPlanFragments::fragments(int index) const {
  return fragments_.Get(index);
}
inline ::exec::bit::control::PlanFragment* QueryPlanFragments::mutable_fragments(int index) {
  return fragments_.Mutable(index);
}
inline ::exec::bit::control::PlanFragment* QueryPlanFragments::add_fragments() {
  return fragments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment >&
QueryPlanFragments::fragments() const {
  return fragments_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment >*
QueryPlanFragments::mutable_fragments() {
  return &fragments_;
}

// optional .exec.shared.DrillPBError error = 4;
inline bool QueryPlanFragments::has_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QueryPlanFragments::set_has_error() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QueryPlanFragments::clear_has_error() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QueryPlanFragments::clear_error() {
  if (error_ != NULL) error_->::exec::shared::DrillPBError::Clear();
  clear_has_error();
}
inline const ::exec::shared::DrillPBError& QueryPlanFragments::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::exec::shared::DrillPBError* QueryPlanFragments::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::exec::shared::DrillPBError;
  return error_;
}
inline ::exec::shared::DrillPBError* QueryPlanFragments::release_error() {
  clear_has_error();
  ::exec::shared::DrillPBError* temp = error_;
  error_ = NULL;
  return temp;
}
inline void QueryPlanFragments::set_allocated_error(::exec::shared::DrillPBError* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
}

// -------------------------------------------------------------------

// BitToUserHandshake

// optional int32 rpc_version = 2;
inline bool BitToUserHandshake::has_rpc_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BitToUserHandshake::set_has_rpc_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BitToUserHandshake::clear_has_rpc_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BitToUserHandshake::clear_rpc_version() {
  rpc_version_ = 0;
  clear_has_rpc_version();
}
inline ::google::protobuf::int32 BitToUserHandshake::rpc_version() const {
  return rpc_version_;
}
inline void BitToUserHandshake::set_rpc_version(::google::protobuf::int32 value) {
  set_has_rpc_version();
  rpc_version_ = value;
}

// optional .exec.user.HandshakeStatus status = 3;
inline bool BitToUserHandshake::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BitToUserHandshake::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BitToUserHandshake::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BitToUserHandshake::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::exec::user::HandshakeStatus BitToUserHandshake::status() const {
  return static_cast< ::exec::user::HandshakeStatus >(status_);
}
inline void BitToUserHandshake::set_status(::exec::user::HandshakeStatus value) {
  assert(::exec::user::HandshakeStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional string errorId = 4;
inline bool BitToUserHandshake::has_errorid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BitToUserHandshake::set_has_errorid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BitToUserHandshake::clear_has_errorid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BitToUserHandshake::clear_errorid() {
  if (errorid_ != &::google::protobuf::internal::kEmptyString) {
    errorid_->clear();
  }
  clear_has_errorid();
}
inline const ::std::string& BitToUserHandshake::errorid() const {
  return *errorid_;
}
inline void BitToUserHandshake::set_errorid(const ::std::string& value) {
  set_has_errorid();
  if (errorid_ == &::google::protobuf::internal::kEmptyString) {
    errorid_ = new ::std::string;
  }
  errorid_->assign(value);
}
inline void BitToUserHandshake::set_errorid(const char* value) {
  set_has_errorid();
  if (errorid_ == &::google::protobuf::internal::kEmptyString) {
    errorid_ = new ::std::string;
  }
  errorid_->assign(value);
}
inline void BitToUserHandshake::set_errorid(const char* value, size_t size) {
  set_has_errorid();
  if (errorid_ == &::google::protobuf::internal::kEmptyString) {
    errorid_ = new ::std::string;
  }
  errorid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BitToUserHandshake::mutable_errorid() {
  set_has_errorid();
  if (errorid_ == &::google::protobuf::internal::kEmptyString) {
    errorid_ = new ::std::string;
  }
  return errorid_;
}
inline ::std::string* BitToUserHandshake::release_errorid() {
  clear_has_errorid();
  if (errorid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errorid_;
    errorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BitToUserHandshake::set_allocated_errorid(::std::string* errorid) {
  if (errorid_ != &::google::protobuf::internal::kEmptyString) {
    delete errorid_;
  }
  if (errorid) {
    set_has_errorid();
    errorid_ = errorid;
  } else {
    clear_has_errorid();
    errorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string errorMessage = 5;
inline bool BitToUserHandshake::has_errormessage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BitToUserHandshake::set_has_errormessage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BitToUserHandshake::clear_has_errormessage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BitToUserHandshake::clear_errormessage() {
  if (errormessage_ != &::google::protobuf::internal::kEmptyString) {
    errormessage_->clear();
  }
  clear_has_errormessage();
}
inline const ::std::string& BitToUserHandshake::errormessage() const {
  return *errormessage_;
}
inline void BitToUserHandshake::set_errormessage(const ::std::string& value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
}
inline void BitToUserHandshake::set_errormessage(const char* value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
}
inline void BitToUserHandshake::set_errormessage(const char* value, size_t size) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BitToUserHandshake::mutable_errormessage() {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  return errormessage_;
}
inline ::std::string* BitToUserHandshake::release_errormessage() {
  clear_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errormessage_;
    errormessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BitToUserHandshake::set_allocated_errormessage(::std::string* errormessage) {
  if (errormessage_ != &::google::protobuf::internal::kEmptyString) {
    delete errormessage_;
  }
  if (errormessage) {
    set_has_errormessage();
    errormessage_ = errormessage;
  } else {
    clear_has_errormessage();
    errormessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .exec.user.RpcEndpointInfos server_infos = 6;
inline bool BitToUserHandshake::has_server_infos() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BitToUserHandshake::set_has_server_infos() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BitToUserHandshake::clear_has_server_infos() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BitToUserHandshake::clear_server_infos() {
  if (server_infos_ != NULL) server_infos_->::exec::user::RpcEndpointInfos::Clear();
  clear_has_server_infos();
}
inline const ::exec::user::RpcEndpointInfos& BitToUserHandshake::server_infos() const {
  return server_infos_ != NULL ? *server_infos_ : *default_instance_->server_infos_;
}
inline ::exec::user::RpcEndpointInfos* BitToUserHandshake::mutable_server_infos() {
  set_has_server_infos();
  if (server_infos_ == NULL) server_infos_ = new ::exec::user::RpcEndpointInfos;
  return server_infos_;
}
inline ::exec::user::RpcEndpointInfos* BitToUserHandshake::release_server_infos() {
  clear_has_server_infos();
  ::exec::user::RpcEndpointInfos* temp = server_infos_;
  server_infos_ = NULL;
  return temp;
}
inline void BitToUserHandshake::set_allocated_server_infos(::exec::user::RpcEndpointInfos* server_infos) {
  delete server_infos_;
  server_infos_ = server_infos;
  if (server_infos) {
    set_has_server_infos();
  } else {
    clear_has_server_infos();
  }
}

// repeated string authenticationMechanisms = 7;
inline int BitToUserHandshake::authenticationmechanisms_size() const {
  return authenticationmechanisms_.size();
}
inline void BitToUserHandshake::clear_authenticationmechanisms() {
  authenticationmechanisms_.Clear();
}
inline const ::std::string& BitToUserHandshake::authenticationmechanisms(int index) const {
  return authenticationmechanisms_.Get(index);
}
inline ::std::string* BitToUserHandshake::mutable_authenticationmechanisms(int index) {
  return authenticationmechanisms_.Mutable(index);
}
inline void BitToUserHandshake::set_authenticationmechanisms(int index, const ::std::string& value) {
  authenticationmechanisms_.Mutable(index)->assign(value);
}
inline void BitToUserHandshake::set_authenticationmechanisms(int index, const char* value) {
  authenticationmechanisms_.Mutable(index)->assign(value);
}
inline void BitToUserHandshake::set_authenticationmechanisms(int index, const char* value, size_t size) {
  authenticationmechanisms_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BitToUserHandshake::add_authenticationmechanisms() {
  return authenticationmechanisms_.Add();
}
inline void BitToUserHandshake::add_authenticationmechanisms(const ::std::string& value) {
  authenticationmechanisms_.Add()->assign(value);
}
inline void BitToUserHandshake::add_authenticationmechanisms(const char* value) {
  authenticationmechanisms_.Add()->assign(value);
}
inline void BitToUserHandshake::add_authenticationmechanisms(const char* value, size_t size) {
  authenticationmechanisms_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BitToUserHandshake::authenticationmechanisms() const {
  return authenticationmechanisms_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BitToUserHandshake::mutable_authenticationmechanisms() {
  return &authenticationmechanisms_;
}

// repeated .exec.user.RpcType supported_methods = 8;
inline int BitToUserHandshake::supported_methods_size() const {
  return supported_methods_.size();
}
inline void BitToUserHandshake::clear_supported_methods() {
  supported_methods_.Clear();
}
inline ::exec::user::RpcType BitToUserHandshake::supported_methods(int index) const {
  return static_cast< ::exec::user::RpcType >(supported_methods_.Get(index));
}
inline void BitToUserHandshake::set_supported_methods(int index, ::exec::user::RpcType value) {
  assert(::exec::user::RpcType_IsValid(value));
  supported_methods_.Set(index, value);
}
inline void BitToUserHandshake::add_supported_methods(::exec::user::RpcType value) {
  assert(::exec::user::RpcType_IsValid(value));
  supported_methods_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
BitToUserHandshake::supported_methods() const {
  return supported_methods_;
}
inline ::google::protobuf::RepeatedField<int>*
BitToUserHandshake::mutable_supported_methods() {
  return &supported_methods_;
}

// optional bool encrypted = 9;
inline bool BitToUserHandshake::has_encrypted() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BitToUserHandshake::set_has_encrypted() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BitToUserHandshake::clear_has_encrypted() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BitToUserHandshake::clear_encrypted() {
  encrypted_ = false;
  clear_has_encrypted();
}
inline bool BitToUserHandshake::encrypted() const {
  return encrypted_;
}
inline void BitToUserHandshake::set_encrypted(bool value) {
  set_has_encrypted();
  encrypted_ = value;
}

// optional int32 maxWrappedSize = 10;
inline bool BitToUserHandshake::has_maxwrappedsize() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BitToUserHandshake::set_has_maxwrappedsize() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BitToUserHandshake::clear_has_maxwrappedsize() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BitToUserHandshake::clear_maxwrappedsize() {
  maxwrappedsize_ = 0;
  clear_has_maxwrappedsize();
}
inline ::google::protobuf::int32 BitToUserHandshake::maxwrappedsize() const {
  return maxwrappedsize_;
}
inline void BitToUserHandshake::set_maxwrappedsize(::google::protobuf::int32 value) {
  set_has_maxwrappedsize();
  maxwrappedsize_ = value;
}

// -------------------------------------------------------------------

// LikeFilter

// optional string pattern = 1;
inline bool LikeFilter::has_pattern() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LikeFilter::set_has_pattern() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LikeFilter::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LikeFilter::clear_pattern() {
  if (pattern_ != &::google::protobuf::internal::kEmptyString) {
    pattern_->clear();
  }
  clear_has_pattern();
}
inline const ::std::string& LikeFilter::pattern() const {
  return *pattern_;
}
inline void LikeFilter::set_pattern(const ::std::string& value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::kEmptyString) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
}
inline void LikeFilter::set_pattern(const char* value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::kEmptyString) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
}
inline void LikeFilter::set_pattern(const char* value, size_t size) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::kEmptyString) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LikeFilter::mutable_pattern() {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::kEmptyString) {
    pattern_ = new ::std::string;
  }
  return pattern_;
}
inline ::std::string* LikeFilter::release_pattern() {
  clear_has_pattern();
  if (pattern_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pattern_;
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LikeFilter::set_allocated_pattern(::std::string* pattern) {
  if (pattern_ != &::google::protobuf::internal::kEmptyString) {
    delete pattern_;
  }
  if (pattern) {
    set_has_pattern();
    pattern_ = pattern;
  } else {
    clear_has_pattern();
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string escape = 2;
inline bool LikeFilter::has_escape() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LikeFilter::set_has_escape() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LikeFilter::clear_has_escape() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LikeFilter::clear_escape() {
  if (escape_ != &::google::protobuf::internal::kEmptyString) {
    escape_->clear();
  }
  clear_has_escape();
}
inline const ::std::string& LikeFilter::escape() const {
  return *escape_;
}
inline void LikeFilter::set_escape(const ::std::string& value) {
  set_has_escape();
  if (escape_ == &::google::protobuf::internal::kEmptyString) {
    escape_ = new ::std::string;
  }
  escape_->assign(value);
}
inline void LikeFilter::set_escape(const char* value) {
  set_has_escape();
  if (escape_ == &::google::protobuf::internal::kEmptyString) {
    escape_ = new ::std::string;
  }
  escape_->assign(value);
}
inline void LikeFilter::set_escape(const char* value, size_t size) {
  set_has_escape();
  if (escape_ == &::google::protobuf::internal::kEmptyString) {
    escape_ = new ::std::string;
  }
  escape_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LikeFilter::mutable_escape() {
  set_has_escape();
  if (escape_ == &::google::protobuf::internal::kEmptyString) {
    escape_ = new ::std::string;
  }
  return escape_;
}
inline ::std::string* LikeFilter::release_escape() {
  clear_has_escape();
  if (escape_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = escape_;
    escape_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LikeFilter::set_allocated_escape(::std::string* escape) {
  if (escape_ != &::google::protobuf::internal::kEmptyString) {
    delete escape_;
  }
  if (escape) {
    set_has_escape();
    escape_ = escape;
  } else {
    clear_has_escape();
    escape_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetCatalogsReq

// optional .exec.user.LikeFilter catalog_name_filter = 1;
inline bool GetCatalogsReq::has_catalog_name_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCatalogsReq::set_has_catalog_name_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCatalogsReq::clear_has_catalog_name_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCatalogsReq::clear_catalog_name_filter() {
  if (catalog_name_filter_ != NULL) catalog_name_filter_->::exec::user::LikeFilter::Clear();
  clear_has_catalog_name_filter();
}
inline const ::exec::user::LikeFilter& GetCatalogsReq::catalog_name_filter() const {
  return catalog_name_filter_ != NULL ? *catalog_name_filter_ : *default_instance_->catalog_name_filter_;
}
inline ::exec::user::LikeFilter* GetCatalogsReq::mutable_catalog_name_filter() {
  set_has_catalog_name_filter();
  if (catalog_name_filter_ == NULL) catalog_name_filter_ = new ::exec::user::LikeFilter;
  return catalog_name_filter_;
}
inline ::exec::user::LikeFilter* GetCatalogsReq::release_catalog_name_filter() {
  clear_has_catalog_name_filter();
  ::exec::user::LikeFilter* temp = catalog_name_filter_;
  catalog_name_filter_ = NULL;
  return temp;
}
inline void GetCatalogsReq::set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter) {
  delete catalog_name_filter_;
  catalog_name_filter_ = catalog_name_filter;
  if (catalog_name_filter) {
    set_has_catalog_name_filter();
  } else {
    clear_has_catalog_name_filter();
  }
}

// -------------------------------------------------------------------

// CatalogMetadata

// optional string catalog_name = 1;
inline bool CatalogMetadata::has_catalog_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CatalogMetadata::set_has_catalog_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CatalogMetadata::clear_has_catalog_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CatalogMetadata::clear_catalog_name() {
  if (catalog_name_ != &::google::protobuf::internal::kEmptyString) {
    catalog_name_->clear();
  }
  clear_has_catalog_name();
}
inline const ::std::string& CatalogMetadata::catalog_name() const {
  return *catalog_name_;
}
inline void CatalogMetadata::set_catalog_name(const ::std::string& value) {
  set_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    catalog_name_ = new ::std::string;
  }
  catalog_name_->assign(value);
}
inline void CatalogMetadata::set_catalog_name(const char* value) {
  set_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    catalog_name_ = new ::std::string;
  }
  catalog_name_->assign(value);
}
inline void CatalogMetadata::set_catalog_name(const char* value, size_t size) {
  set_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    catalog_name_ = new ::std::string;
  }
  catalog_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CatalogMetadata::mutable_catalog_name() {
  set_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    catalog_name_ = new ::std::string;
  }
  return catalog_name_;
}
inline ::std::string* CatalogMetadata::release_catalog_name() {
  clear_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = catalog_name_;
    catalog_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CatalogMetadata::set_allocated_catalog_name(::std::string* catalog_name) {
  if (catalog_name_ != &::google::protobuf::internal::kEmptyString) {
    delete catalog_name_;
  }
  if (catalog_name) {
    set_has_catalog_name();
    catalog_name_ = catalog_name;
  } else {
    clear_has_catalog_name();
    catalog_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string description = 2;
inline bool CatalogMetadata::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CatalogMetadata::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CatalogMetadata::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CatalogMetadata::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& CatalogMetadata::description() const {
  return *description_;
}
inline void CatalogMetadata::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CatalogMetadata::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CatalogMetadata::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CatalogMetadata::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* CatalogMetadata::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CatalogMetadata::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string connect = 3;
inline bool CatalogMetadata::has_connect() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CatalogMetadata::set_has_connect() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CatalogMetadata::clear_has_connect() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CatalogMetadata::clear_connect() {
  if (connect_ != &::google::protobuf::internal::kEmptyString) {
    connect_->clear();
  }
  clear_has_connect();
}
inline const ::std::string& CatalogMetadata::connect() const {
  return *connect_;
}
inline void CatalogMetadata::set_connect(const ::std::string& value) {
  set_has_connect();
  if (connect_ == &::google::protobuf::internal::kEmptyString) {
    connect_ = new ::std::string;
  }
  connect_->assign(value);
}
inline void CatalogMetadata::set_connect(const char* value) {
  set_has_connect();
  if (connect_ == &::google::protobuf::internal::kEmptyString) {
    connect_ = new ::std::string;
  }
  connect_->assign(value);
}
inline void CatalogMetadata::set_connect(const char* value, size_t size) {
  set_has_connect();
  if (connect_ == &::google::protobuf::internal::kEmptyString) {
    connect_ = new ::std::string;
  }
  connect_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CatalogMetadata::mutable_connect() {
  set_has_connect();
  if (connect_ == &::google::protobuf::internal::kEmptyString) {
    connect_ = new ::std::string;
  }
  return connect_;
}
inline ::std::string* CatalogMetadata::release_connect() {
  clear_has_connect();
  if (connect_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = connect_;
    connect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CatalogMetadata::set_allocated_connect(::std::string* connect) {
  if (connect_ != &::google::protobuf::internal::kEmptyString) {
    delete connect_;
  }
  if (connect) {
    set_has_connect();
    connect_ = connect;
  } else {
    clear_has_connect();
    connect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetCatalogsResp

// optional .exec.user.RequestStatus status = 1;
inline bool GetCatalogsResp::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCatalogsResp::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCatalogsResp::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCatalogsResp::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::exec::user::RequestStatus GetCatalogsResp::status() const {
  return static_cast< ::exec::user::RequestStatus >(status_);
}
inline void GetCatalogsResp::set_status(::exec::user::RequestStatus value) {
  assert(::exec::user::RequestStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// repeated .exec.user.CatalogMetadata catalogs = 2;
inline int GetCatalogsResp::catalogs_size() const {
  return catalogs_.size();
}
inline void GetCatalogsResp::clear_catalogs() {
  catalogs_.Clear();
}
inline const ::exec::user::CatalogMetadata& GetCatalogsResp::catalogs(int index) const {
  return catalogs_.Get(index);
}
inline ::exec::user::CatalogMetadata* GetCatalogsResp::mutable_catalogs(int index) {
  return catalogs_.Mutable(index);
}
inline ::exec::user::CatalogMetadata* GetCatalogsResp::add_catalogs() {
  return catalogs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::user::CatalogMetadata >&
GetCatalogsResp::catalogs() const {
  return catalogs_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::user::CatalogMetadata >*
GetCatalogsResp::mutable_catalogs() {
  return &catalogs_;
}

// optional .exec.shared.DrillPBError error = 3;
inline bool GetCatalogsResp::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetCatalogsResp::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetCatalogsResp::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetCatalogsResp::clear_error() {
  if (error_ != NULL) error_->::exec::shared::DrillPBError::Clear();
  clear_has_error();
}
inline const ::exec::shared::DrillPBError& GetCatalogsResp::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::exec::shared::DrillPBError* GetCatalogsResp::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::exec::shared::DrillPBError;
  return error_;
}
inline ::exec::shared::DrillPBError* GetCatalogsResp::release_error() {
  clear_has_error();
  ::exec::shared::DrillPBError* temp = error_;
  error_ = NULL;
  return temp;
}
inline void GetCatalogsResp::set_allocated_error(::exec::shared::DrillPBError* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
}

// -------------------------------------------------------------------

// GetSchemasReq

// optional .exec.user.LikeFilter catalog_name_filter = 1;
inline bool GetSchemasReq::has_catalog_name_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSchemasReq::set_has_catalog_name_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSchemasReq::clear_has_catalog_name_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSchemasReq::clear_catalog_name_filter() {
  if (catalog_name_filter_ != NULL) catalog_name_filter_->::exec::user::LikeFilter::Clear();
  clear_has_catalog_name_filter();
}
inline const ::exec::user::LikeFilter& GetSchemasReq::catalog_name_filter() const {
  return catalog_name_filter_ != NULL ? *catalog_name_filter_ : *default_instance_->catalog_name_filter_;
}
inline ::exec::user::LikeFilter* GetSchemasReq::mutable_catalog_name_filter() {
  set_has_catalog_name_filter();
  if (catalog_name_filter_ == NULL) catalog_name_filter_ = new ::exec::user::LikeFilter;
  return catalog_name_filter_;
}
inline ::exec::user::LikeFilter* GetSchemasReq::release_catalog_name_filter() {
  clear_has_catalog_name_filter();
  ::exec::user::LikeFilter* temp = catalog_name_filter_;
  catalog_name_filter_ = NULL;
  return temp;
}
inline void GetSchemasReq::set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter) {
  delete catalog_name_filter_;
  catalog_name_filter_ = catalog_name_filter;
  if (catalog_name_filter) {
    set_has_catalog_name_filter();
  } else {
    clear_has_catalog_name_filter();
  }
}

// optional .exec.user.LikeFilter schema_name_filter = 2;
inline bool GetSchemasReq::has_schema_name_filter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSchemasReq::set_has_schema_name_filter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetSchemasReq::clear_has_schema_name_filter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetSchemasReq::clear_schema_name_filter() {
  if (schema_name_filter_ != NULL) schema_name_filter_->::exec::user::LikeFilter::Clear();
  clear_has_schema_name_filter();
}
inline const ::exec::user::LikeFilter& GetSchemasReq::schema_name_filter() const {
  return schema_name_filter_ != NULL ? *schema_name_filter_ : *default_instance_->schema_name_filter_;
}
inline ::exec::user::LikeFilter* GetSchemasReq::mutable_schema_name_filter() {
  set_has_schema_name_filter();
  if (schema_name_filter_ == NULL) schema_name_filter_ = new ::exec::user::LikeFilter;
  return schema_name_filter_;
}
inline ::exec::user::LikeFilter* GetSchemasReq::release_schema_name_filter() {
  clear_has_schema_name_filter();
  ::exec::user::LikeFilter* temp = schema_name_filter_;
  schema_name_filter_ = NULL;
  return temp;
}
inline void GetSchemasReq::set_allocated_schema_name_filter(::exec::user::LikeFilter* schema_name_filter) {
  delete schema_name_filter_;
  schema_name_filter_ = schema_name_filter;
  if (schema_name_filter) {
    set_has_schema_name_filter();
  } else {
    clear_has_schema_name_filter();
  }
}

// -------------------------------------------------------------------

// SchemaMetadata

// optional string catalog_name = 1;
inline bool SchemaMetadata::has_catalog_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaMetadata::set_has_catalog_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaMetadata::clear_has_catalog_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaMetadata::clear_catalog_name() {
  if (catalog_name_ != &::google::protobuf::internal::kEmptyString) {
    catalog_name_->clear();
  }
  clear_has_catalog_name();
}
inline const ::std::string& SchemaMetadata::catalog_name() const {
  return *catalog_name_;
}
inline void SchemaMetadata::set_catalog_name(const ::std::string& value) {
  set_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    catalog_name_ = new ::std::string;
  }
  catalog_name_->assign(value);
}
inline void SchemaMetadata::set_catalog_name(const char* value) {
  set_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    catalog_name_ = new ::std::string;
  }
  catalog_name_->assign(value);
}
inline void SchemaMetadata::set_catalog_name(const char* value, size_t size) {
  set_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    catalog_name_ = new ::std::string;
  }
  catalog_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaMetadata::mutable_catalog_name() {
  set_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    catalog_name_ = new ::std::string;
  }
  return catalog_name_;
}
inline ::std::string* SchemaMetadata::release_catalog_name() {
  clear_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = catalog_name_;
    catalog_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaMetadata::set_allocated_catalog_name(::std::string* catalog_name) {
  if (catalog_name_ != &::google::protobuf::internal::kEmptyString) {
    delete catalog_name_;
  }
  if (catalog_name) {
    set_has_catalog_name();
    catalog_name_ = catalog_name;
  } else {
    clear_has_catalog_name();
    catalog_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string schema_name = 2;
inline bool SchemaMetadata::has_schema_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaMetadata::set_has_schema_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaMetadata::clear_has_schema_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaMetadata::clear_schema_name() {
  if (schema_name_ != &::google::protobuf::internal::kEmptyString) {
    schema_name_->clear();
  }
  clear_has_schema_name();
}
inline const ::std::string& SchemaMetadata::schema_name() const {
  return *schema_name_;
}
inline void SchemaMetadata::set_schema_name(const ::std::string& value) {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::kEmptyString) {
    schema_name_ = new ::std::string;
  }
  schema_name_->assign(value);
}
inline void SchemaMetadata::set_schema_name(const char* value) {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::kEmptyString) {
    schema_name_ = new ::std::string;
  }
  schema_name_->assign(value);
}
inline void SchemaMetadata::set_schema_name(const char* value, size_t size) {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::kEmptyString) {
    schema_name_ = new ::std::string;
  }
  schema_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaMetadata::mutable_schema_name() {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::kEmptyString) {
    schema_name_ = new ::std::string;
  }
  return schema_name_;
}
inline ::std::string* SchemaMetadata::release_schema_name() {
  clear_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = schema_name_;
    schema_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaMetadata::set_allocated_schema_name(::std::string* schema_name) {
  if (schema_name_ != &::google::protobuf::internal::kEmptyString) {
    delete schema_name_;
  }
  if (schema_name) {
    set_has_schema_name();
    schema_name_ = schema_name;
  } else {
    clear_has_schema_name();
    schema_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string owner = 3;
inline bool SchemaMetadata::has_owner() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaMetadata::set_has_owner() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaMetadata::clear_has_owner() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaMetadata::clear_owner() {
  if (owner_ != &::google::protobuf::internal::kEmptyString) {
    owner_->clear();
  }
  clear_has_owner();
}
inline const ::std::string& SchemaMetadata::owner() const {
  return *owner_;
}
inline void SchemaMetadata::set_owner(const ::std::string& value) {
  set_has_owner();
  if (owner_ == &::google::protobuf::internal::kEmptyString) {
    owner_ = new ::std::string;
  }
  owner_->assign(value);
}
inline void SchemaMetadata::set_owner(const char* value) {
  set_has_owner();
  if (owner_ == &::google::protobuf::internal::kEmptyString) {
    owner_ = new ::std::string;
  }
  owner_->assign(value);
}
inline void SchemaMetadata::set_owner(const char* value, size_t size) {
  set_has_owner();
  if (owner_ == &::google::protobuf::internal::kEmptyString) {
    owner_ = new ::std::string;
  }
  owner_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaMetadata::mutable_owner() {
  set_has_owner();
  if (owner_ == &::google::protobuf::internal::kEmptyString) {
    owner_ = new ::std::string;
  }
  return owner_;
}
inline ::std::string* SchemaMetadata::release_owner() {
  clear_has_owner();
  if (owner_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = owner_;
    owner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaMetadata::set_allocated_owner(::std::string* owner) {
  if (owner_ != &::google::protobuf::internal::kEmptyString) {
    delete owner_;
  }
  if (owner) {
    set_has_owner();
    owner_ = owner;
  } else {
    clear_has_owner();
    owner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 4;
inline bool SchemaMetadata::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemaMetadata::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SchemaMetadata::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SchemaMetadata::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& SchemaMetadata::type() const {
  return *type_;
}
inline void SchemaMetadata::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void SchemaMetadata::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void SchemaMetadata::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaMetadata::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* SchemaMetadata::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaMetadata::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mutable = 5;
inline bool SchemaMetadata::has_mutable_() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchemaMetadata::set_has_mutable_() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SchemaMetadata::clear_has_mutable_() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SchemaMetadata::clear_mutable_() {
  if (mutable__ != &::google::protobuf::internal::kEmptyString) {
    mutable__->clear();
  }
  clear_has_mutable_();
}
inline const ::std::string& SchemaMetadata::mutable_() const {
  return *mutable__;
}
inline void SchemaMetadata::set_mutable_(const ::std::string& value) {
  set_has_mutable_();
  if (mutable__ == &::google::protobuf::internal::kEmptyString) {
    mutable__ = new ::std::string;
  }
  mutable__->assign(value);
}
inline void SchemaMetadata::set_mutable_(const char* value) {
  set_has_mutable_();
  if (mutable__ == &::google::protobuf::internal::kEmptyString) {
    mutable__ = new ::std::string;
  }
  mutable__->assign(value);
}
inline void SchemaMetadata::set_mutable_(const char* value, size_t size) {
  set_has_mutable_();
  if (mutable__ == &::google::protobuf::internal::kEmptyString) {
    mutable__ = new ::std::string;
  }
  mutable__->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaMetadata::mutable_mutable_() {
  set_has_mutable_();
  if (mutable__ == &::google::protobuf::internal::kEmptyString) {
    mutable__ = new ::std::string;
  }
  return mutable__;
}
inline ::std::string* SchemaMetadata::release_mutable_() {
  clear_has_mutable_();
  if (mutable__ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mutable__;
    mutable__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaMetadata::set_allocated_mutable_(::std::string* mutable_) {
  if (mutable__ != &::google::protobuf::internal::kEmptyString) {
    delete mutable__;
  }
  if (mutable_) {
    set_has_mutable_();
    mutable__ = mutable_;
  } else {
    clear_has_mutable_();
    mutable__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetSchemasResp

// optional .exec.user.RequestStatus status = 1;
inline bool GetSchemasResp::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSchemasResp::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSchemasResp::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSchemasResp::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::exec::user::RequestStatus GetSchemasResp::status() const {
  return static_cast< ::exec::user::RequestStatus >(status_);
}
inline void GetSchemasResp::set_status(::exec::user::RequestStatus value) {
  assert(::exec::user::RequestStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// repeated .exec.user.SchemaMetadata schemas = 2;
inline int GetSchemasResp::schemas_size() const {
  return schemas_.size();
}
inline void GetSchemasResp::clear_schemas() {
  schemas_.Clear();
}
inline const ::exec::user::SchemaMetadata& GetSchemasResp::schemas(int index) const {
  return schemas_.Get(index);
}
inline ::exec::user::SchemaMetadata* GetSchemasResp::mutable_schemas(int index) {
  return schemas_.Mutable(index);
}
inline ::exec::user::SchemaMetadata* GetSchemasResp::add_schemas() {
  return schemas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::user::SchemaMetadata >&
GetSchemasResp::schemas() const {
  return schemas_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::user::SchemaMetadata >*
GetSchemasResp::mutable_schemas() {
  return &schemas_;
}

// optional .exec.shared.DrillPBError error = 3;
inline bool GetSchemasResp::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetSchemasResp::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetSchemasResp::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetSchemasResp::clear_error() {
  if (error_ != NULL) error_->::exec::shared::DrillPBError::Clear();
  clear_has_error();
}
inline const ::exec::shared::DrillPBError& GetSchemasResp::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::exec::shared::DrillPBError* GetSchemasResp::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::exec::shared::DrillPBError;
  return error_;
}
inline ::exec::shared::DrillPBError* GetSchemasResp::release_error() {
  clear_has_error();
  ::exec::shared::DrillPBError* temp = error_;
  error_ = NULL;
  return temp;
}
inline void GetSchemasResp::set_allocated_error(::exec::shared::DrillPBError* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
}

// -------------------------------------------------------------------

// GetTablesReq

// optional .exec.user.LikeFilter catalog_name_filter = 1;
inline bool GetTablesReq::has_catalog_name_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTablesReq::set_has_catalog_name_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTablesReq::clear_has_catalog_name_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTablesReq::clear_catalog_name_filter() {
  if (catalog_name_filter_ != NULL) catalog_name_filter_->::exec::user::LikeFilter::Clear();
  clear_has_catalog_name_filter();
}
inline const ::exec::user::LikeFilter& GetTablesReq::catalog_name_filter() const {
  return catalog_name_filter_ != NULL ? *catalog_name_filter_ : *default_instance_->catalog_name_filter_;
}
inline ::exec::user::LikeFilter* GetTablesReq::mutable_catalog_name_filter() {
  set_has_catalog_name_filter();
  if (catalog_name_filter_ == NULL) catalog_name_filter_ = new ::exec::user::LikeFilter;
  return catalog_name_filter_;
}
inline ::exec::user::LikeFilter* GetTablesReq::release_catalog_name_filter() {
  clear_has_catalog_name_filter();
  ::exec::user::LikeFilter* temp = catalog_name_filter_;
  catalog_name_filter_ = NULL;
  return temp;
}
inline void GetTablesReq::set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter) {
  delete catalog_name_filter_;
  catalog_name_filter_ = catalog_name_filter;
  if (catalog_name_filter) {
    set_has_catalog_name_filter();
  } else {
    clear_has_catalog_name_filter();
  }
}

// optional .exec.user.LikeFilter schema_name_filter = 2;
inline bool GetTablesReq::has_schema_name_filter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTablesReq::set_has_schema_name_filter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTablesReq::clear_has_schema_name_filter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTablesReq::clear_schema_name_filter() {
  if (schema_name_filter_ != NULL) schema_name_filter_->::exec::user::LikeFilter::Clear();
  clear_has_schema_name_filter();
}
inline const ::exec::user::LikeFilter& GetTablesReq::schema_name_filter() const {
  return schema_name_filter_ != NULL ? *schema_name_filter_ : *default_instance_->schema_name_filter_;
}
inline ::exec::user::LikeFilter* GetTablesReq::mutable_schema_name_filter() {
  set_has_schema_name_filter();
  if (schema_name_filter_ == NULL) schema_name_filter_ = new ::exec::user::LikeFilter;
  return schema_name_filter_;
}
inline ::exec::user::LikeFilter* GetTablesReq::release_schema_name_filter() {
  clear_has_schema_name_filter();
  ::exec::user::LikeFilter* temp = schema_name_filter_;
  schema_name_filter_ = NULL;
  return temp;
}
inline void GetTablesReq::set_allocated_schema_name_filter(::exec::user::LikeFilter* schema_name_filter) {
  delete schema_name_filter_;
  schema_name_filter_ = schema_name_filter;
  if (schema_name_filter) {
    set_has_schema_name_filter();
  } else {
    clear_has_schema_name_filter();
  }
}

// optional .exec.user.LikeFilter table_name_filter = 3;
inline bool GetTablesReq::has_table_name_filter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetTablesReq::set_has_table_name_filter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetTablesReq::clear_has_table_name_filter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetTablesReq::clear_table_name_filter() {
  if (table_name_filter_ != NULL) table_name_filter_->::exec::user::LikeFilter::Clear();
  clear_has_table_name_filter();
}
inline const ::exec::user::LikeFilter& GetTablesReq::table_name_filter() const {
  return table_name_filter_ != NULL ? *table_name_filter_ : *default_instance_->table_name_filter_;
}
inline ::exec::user::LikeFilter* GetTablesReq::mutable_table_name_filter() {
  set_has_table_name_filter();
  if (table_name_filter_ == NULL) table_name_filter_ = new ::exec::user::LikeFilter;
  return table_name_filter_;
}
inline ::exec::user::LikeFilter* GetTablesReq::release_table_name_filter() {
  clear_has_table_name_filter();
  ::exec::user::LikeFilter* temp = table_name_filter_;
  table_name_filter_ = NULL;
  return temp;
}
inline void GetTablesReq::set_allocated_table_name_filter(::exec::user::LikeFilter* table_name_filter) {
  delete table_name_filter_;
  table_name_filter_ = table_name_filter;
  if (table_name_filter) {
    set_has_table_name_filter();
  } else {
    clear_has_table_name_filter();
  }
}

// repeated string table_type_filter = 4;
inline int GetTablesReq::table_type_filter_size() const {
  return table_type_filter_.size();
}
inline void GetTablesReq::clear_table_type_filter() {
  table_type_filter_.Clear();
}
inline const ::std::string& GetTablesReq::table_type_filter(int index) const {
  return table_type_filter_.Get(index);
}
inline ::std::string* GetTablesReq::mutable_table_type_filter(int index) {
  return table_type_filter_.Mutable(index);
}
inline void GetTablesReq::set_table_type_filter(int index, const ::std::string& value) {
  table_type_filter_.Mutable(index)->assign(value);
}
inline void GetTablesReq::set_table_type_filter(int index, const char* value) {
  table_type_filter_.Mutable(index)->assign(value);
}
inline void GetTablesReq::set_table_type_filter(int index, const char* value, size_t size) {
  table_type_filter_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetTablesReq::add_table_type_filter() {
  return table_type_filter_.Add();
}
inline void GetTablesReq::add_table_type_filter(const ::std::string& value) {
  table_type_filter_.Add()->assign(value);
}
inline void GetTablesReq::add_table_type_filter(const char* value) {
  table_type_filter_.Add()->assign(value);
}
inline void GetTablesReq::add_table_type_filter(const char* value, size_t size) {
  table_type_filter_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetTablesReq::table_type_filter() const {
  return table_type_filter_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetTablesReq::mutable_table_type_filter() {
  return &table_type_filter_;
}

// -------------------------------------------------------------------

// TableMetadata

// optional string catalog_name = 1;
inline bool TableMetadata::has_catalog_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableMetadata::set_has_catalog_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableMetadata::clear_has_catalog_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableMetadata::clear_catalog_name() {
  if (catalog_name_ != &::google::protobuf::internal::kEmptyString) {
    catalog_name_->clear();
  }
  clear_has_catalog_name();
}
inline const ::std::string& TableMetadata::catalog_name() const {
  return *catalog_name_;
}
inline void TableMetadata::set_catalog_name(const ::std::string& value) {
  set_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    catalog_name_ = new ::std::string;
  }
  catalog_name_->assign(value);
}
inline void TableMetadata::set_catalog_name(const char* value) {
  set_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    catalog_name_ = new ::std::string;
  }
  catalog_name_->assign(value);
}
inline void TableMetadata::set_catalog_name(const char* value, size_t size) {
  set_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    catalog_name_ = new ::std::string;
  }
  catalog_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TableMetadata::mutable_catalog_name() {
  set_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    catalog_name_ = new ::std::string;
  }
  return catalog_name_;
}
inline ::std::string* TableMetadata::release_catalog_name() {
  clear_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = catalog_name_;
    catalog_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TableMetadata::set_allocated_catalog_name(::std::string* catalog_name) {
  if (catalog_name_ != &::google::protobuf::internal::kEmptyString) {
    delete catalog_name_;
  }
  if (catalog_name) {
    set_has_catalog_name();
    catalog_name_ = catalog_name;
  } else {
    clear_has_catalog_name();
    catalog_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string schema_name = 2;
inline bool TableMetadata::has_schema_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableMetadata::set_has_schema_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableMetadata::clear_has_schema_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableMetadata::clear_schema_name() {
  if (schema_name_ != &::google::protobuf::internal::kEmptyString) {
    schema_name_->clear();
  }
  clear_has_schema_name();
}
inline const ::std::string& TableMetadata::schema_name() const {
  return *schema_name_;
}
inline void TableMetadata::set_schema_name(const ::std::string& value) {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::kEmptyString) {
    schema_name_ = new ::std::string;
  }
  schema_name_->assign(value);
}
inline void TableMetadata::set_schema_name(const char* value) {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::kEmptyString) {
    schema_name_ = new ::std::string;
  }
  schema_name_->assign(value);
}
inline void TableMetadata::set_schema_name(const char* value, size_t size) {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::kEmptyString) {
    schema_name_ = new ::std::string;
  }
  schema_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TableMetadata::mutable_schema_name() {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::kEmptyString) {
    schema_name_ = new ::std::string;
  }
  return schema_name_;
}
inline ::std::string* TableMetadata::release_schema_name() {
  clear_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = schema_name_;
    schema_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TableMetadata::set_allocated_schema_name(::std::string* schema_name) {
  if (schema_name_ != &::google::protobuf::internal::kEmptyString) {
    delete schema_name_;
  }
  if (schema_name) {
    set_has_schema_name();
    schema_name_ = schema_name;
  } else {
    clear_has_schema_name();
    schema_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string table_name = 3;
inline bool TableMetadata::has_table_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TableMetadata::set_has_table_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TableMetadata::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TableMetadata::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& TableMetadata::table_name() const {
  return *table_name_;
}
inline void TableMetadata::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void TableMetadata::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void TableMetadata::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TableMetadata::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  return table_name_;
}
inline ::std::string* TableMetadata::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TableMetadata::set_allocated_table_name(::std::string* table_name) {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    delete table_name_;
  }
  if (table_name) {
    set_has_table_name();
    table_name_ = table_name;
  } else {
    clear_has_table_name();
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 4;
inline bool TableMetadata::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TableMetadata::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TableMetadata::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TableMetadata::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& TableMetadata::type() const {
  return *type_;
}
inline void TableMetadata::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void TableMetadata::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void TableMetadata::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TableMetadata::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* TableMetadata::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TableMetadata::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetTablesResp

// optional .exec.user.RequestStatus status = 1;
inline bool GetTablesResp::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTablesResp::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTablesResp::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTablesResp::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::exec::user::RequestStatus GetTablesResp::status() const {
  return static_cast< ::exec::user::RequestStatus >(status_);
}
inline void GetTablesResp::set_status(::exec::user::RequestStatus value) {
  assert(::exec::user::RequestStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// repeated .exec.user.TableMetadata tables = 2;
inline int GetTablesResp::tables_size() const {
  return tables_.size();
}
inline void GetTablesResp::clear_tables() {
  tables_.Clear();
}
inline const ::exec::user::TableMetadata& GetTablesResp::tables(int index) const {
  return tables_.Get(index);
}
inline ::exec::user::TableMetadata* GetTablesResp::mutable_tables(int index) {
  return tables_.Mutable(index);
}
inline ::exec::user::TableMetadata* GetTablesResp::add_tables() {
  return tables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::user::TableMetadata >&
GetTablesResp::tables() const {
  return tables_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::user::TableMetadata >*
GetTablesResp::mutable_tables() {
  return &tables_;
}

// optional .exec.shared.DrillPBError error = 3;
inline bool GetTablesResp::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetTablesResp::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetTablesResp::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetTablesResp::clear_error() {
  if (error_ != NULL) error_->::exec::shared::DrillPBError::Clear();
  clear_has_error();
}
inline const ::exec::shared::DrillPBError& GetTablesResp::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::exec::shared::DrillPBError* GetTablesResp::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::exec::shared::DrillPBError;
  return error_;
}
inline ::exec::shared::DrillPBError* GetTablesResp::release_error() {
  clear_has_error();
  ::exec::shared::DrillPBError* temp = error_;
  error_ = NULL;
  return temp;
}
inline void GetTablesResp::set_allocated_error(::exec::shared::DrillPBError* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
}

// -------------------------------------------------------------------

// GetColumnsReq

// optional .exec.user.LikeFilter catalog_name_filter = 1;
inline bool GetColumnsReq::has_catalog_name_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetColumnsReq::set_has_catalog_name_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetColumnsReq::clear_has_catalog_name_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetColumnsReq::clear_catalog_name_filter() {
  if (catalog_name_filter_ != NULL) catalog_name_filter_->::exec::user::LikeFilter::Clear();
  clear_has_catalog_name_filter();
}
inline const ::exec::user::LikeFilter& GetColumnsReq::catalog_name_filter() const {
  return catalog_name_filter_ != NULL ? *catalog_name_filter_ : *default_instance_->catalog_name_filter_;
}
inline ::exec::user::LikeFilter* GetColumnsReq::mutable_catalog_name_filter() {
  set_has_catalog_name_filter();
  if (catalog_name_filter_ == NULL) catalog_name_filter_ = new ::exec::user::LikeFilter;
  return catalog_name_filter_;
}
inline ::exec::user::LikeFilter* GetColumnsReq::release_catalog_name_filter() {
  clear_has_catalog_name_filter();
  ::exec::user::LikeFilter* temp = catalog_name_filter_;
  catalog_name_filter_ = NULL;
  return temp;
}
inline void GetColumnsReq::set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter) {
  delete catalog_name_filter_;
  catalog_name_filter_ = catalog_name_filter;
  if (catalog_name_filter) {
    set_has_catalog_name_filter();
  } else {
    clear_has_catalog_name_filter();
  }
}

// optional .exec.user.LikeFilter schema_name_filter = 2;
inline bool GetColumnsReq::has_schema_name_filter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetColumnsReq::set_has_schema_name_filter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetColumnsReq::clear_has_schema_name_filter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetColumnsReq::clear_schema_name_filter() {
  if (schema_name_filter_ != NULL) schema_name_filter_->::exec::user::LikeFilter::Clear();
  clear_has_schema_name_filter();
}
inline const ::exec::user::LikeFilter& GetColumnsReq::schema_name_filter() const {
  return schema_name_filter_ != NULL ? *schema_name_filter_ : *default_instance_->schema_name_filter_;
}
inline ::exec::user::LikeFilter* GetColumnsReq::mutable_schema_name_filter() {
  set_has_schema_name_filter();
  if (schema_name_filter_ == NULL) schema_name_filter_ = new ::exec::user::LikeFilter;
  return schema_name_filter_;
}
inline ::exec::user::LikeFilter* GetColumnsReq::release_schema_name_filter() {
  clear_has_schema_name_filter();
  ::exec::user::LikeFilter* temp = schema_name_filter_;
  schema_name_filter_ = NULL;
  return temp;
}
inline void GetColumnsReq::set_allocated_schema_name_filter(::exec::user::LikeFilter* schema_name_filter) {
  delete schema_name_filter_;
  schema_name_filter_ = schema_name_filter;
  if (schema_name_filter) {
    set_has_schema_name_filter();
  } else {
    clear_has_schema_name_filter();
  }
}

// optional .exec.user.LikeFilter table_name_filter = 3;
inline bool GetColumnsReq::has_table_name_filter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetColumnsReq::set_has_table_name_filter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetColumnsReq::clear_has_table_name_filter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetColumnsReq::clear_table_name_filter() {
  if (table_name_filter_ != NULL) table_name_filter_->::exec::user::LikeFilter::Clear();
  clear_has_table_name_filter();
}
inline const ::exec::user::LikeFilter& GetColumnsReq::table_name_filter() const {
  return table_name_filter_ != NULL ? *table_name_filter_ : *default_instance_->table_name_filter_;
}
inline ::exec::user::LikeFilter* GetColumnsReq::mutable_table_name_filter() {
  set_has_table_name_filter();
  if (table_name_filter_ == NULL) table_name_filter_ = new ::exec::user::LikeFilter;
  return table_name_filter_;
}
inline ::exec::user::LikeFilter* GetColumnsReq::release_table_name_filter() {
  clear_has_table_name_filter();
  ::exec::user::LikeFilter* temp = table_name_filter_;
  table_name_filter_ = NULL;
  return temp;
}
inline void GetColumnsReq::set_allocated_table_name_filter(::exec::user::LikeFilter* table_name_filter) {
  delete table_name_filter_;
  table_name_filter_ = table_name_filter;
  if (table_name_filter) {
    set_has_table_name_filter();
  } else {
    clear_has_table_name_filter();
  }
}

// optional .exec.user.LikeFilter column_name_filter = 4;
inline bool GetColumnsReq::has_column_name_filter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetColumnsReq::set_has_column_name_filter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetColumnsReq::clear_has_column_name_filter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetColumnsReq::clear_column_name_filter() {
  if (column_name_filter_ != NULL) column_name_filter_->::exec::user::LikeFilter::Clear();
  clear_has_column_name_filter();
}
inline const ::exec::user::LikeFilter& GetColumnsReq::column_name_filter() const {
  return column_name_filter_ != NULL ? *column_name_filter_ : *default_instance_->column_name_filter_;
}
inline ::exec::user::LikeFilter* GetColumnsReq::mutable_column_name_filter() {
  set_has_column_name_filter();
  if (column_name_filter_ == NULL) column_name_filter_ = new ::exec::user::LikeFilter;
  return column_name_filter_;
}
inline ::exec::user::LikeFilter* GetColumnsReq::release_column_name_filter() {
  clear_has_column_name_filter();
  ::exec::user::LikeFilter* temp = column_name_filter_;
  column_name_filter_ = NULL;
  return temp;
}
inline void GetColumnsReq::set_allocated_column_name_filter(::exec::user::LikeFilter* column_name_filter) {
  delete column_name_filter_;
  column_name_filter_ = column_name_filter;
  if (column_name_filter) {
    set_has_column_name_filter();
  } else {
    clear_has_column_name_filter();
  }
}

// -------------------------------------------------------------------

// ColumnMetadata

// optional string catalog_name = 1;
inline bool ColumnMetadata::has_catalog_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnMetadata::set_has_catalog_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnMetadata::clear_has_catalog_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnMetadata::clear_catalog_name() {
  if (catalog_name_ != &::google::protobuf::internal::kEmptyString) {
    catalog_name_->clear();
  }
  clear_has_catalog_name();
}
inline const ::std::string& ColumnMetadata::catalog_name() const {
  return *catalog_name_;
}
inline void ColumnMetadata::set_catalog_name(const ::std::string& value) {
  set_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    catalog_name_ = new ::std::string;
  }
  catalog_name_->assign(value);
}
inline void ColumnMetadata::set_catalog_name(const char* value) {
  set_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    catalog_name_ = new ::std::string;
  }
  catalog_name_->assign(value);
}
inline void ColumnMetadata::set_catalog_name(const char* value, size_t size) {
  set_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    catalog_name_ = new ::std::string;
  }
  catalog_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ColumnMetadata::mutable_catalog_name() {
  set_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    catalog_name_ = new ::std::string;
  }
  return catalog_name_;
}
inline ::std::string* ColumnMetadata::release_catalog_name() {
  clear_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = catalog_name_;
    catalog_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ColumnMetadata::set_allocated_catalog_name(::std::string* catalog_name) {
  if (catalog_name_ != &::google::protobuf::internal::kEmptyString) {
    delete catalog_name_;
  }
  if (catalog_name) {
    set_has_catalog_name();
    catalog_name_ = catalog_name;
  } else {
    clear_has_catalog_name();
    catalog_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string schema_name = 2;
inline bool ColumnMetadata::has_schema_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnMetadata::set_has_schema_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColumnMetadata::clear_has_schema_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColumnMetadata::clear_schema_name() {
  if (schema_name_ != &::google::protobuf::internal::kEmptyString) {
    schema_name_->clear();
  }
  clear_has_schema_name();
}
inline const ::std::string& ColumnMetadata::schema_name() const {
  return *schema_name_;
}
inline void ColumnMetadata::set_schema_name(const ::std::string& value) {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::kEmptyString) {
    schema_name_ = new ::std::string;
  }
  schema_name_->assign(value);
}
inline void ColumnMetadata::set_schema_name(const char* value) {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::kEmptyString) {
    schema_name_ = new ::std::string;
  }
  schema_name_->assign(value);
}
inline void ColumnMetadata::set_schema_name(const char* value, size_t size) {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::kEmptyString) {
    schema_name_ = new ::std::string;
  }
  schema_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ColumnMetadata::mutable_schema_name() {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::kEmptyString) {
    schema_name_ = new ::std::string;
  }
  return schema_name_;
}
inline ::std::string* ColumnMetadata::release_schema_name() {
  clear_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = schema_name_;
    schema_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ColumnMetadata::set_allocated_schema_name(::std::string* schema_name) {
  if (schema_name_ != &::google::protobuf::internal::kEmptyString) {
    delete schema_name_;
  }
  if (schema_name) {
    set_has_schema_name();
    schema_name_ = schema_name;
  } else {
    clear_has_schema_name();
    schema_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string table_name = 3;
inline bool ColumnMetadata::has_table_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ColumnMetadata::set_has_table_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ColumnMetadata::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ColumnMetadata::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& ColumnMetadata::table_name() const {
  return *table_name_;
}
inline void ColumnMetadata::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void ColumnMetadata::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void ColumnMetadata::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ColumnMetadata::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  return table_name_;
}
inline ::std::string* ColumnMetadata::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ColumnMetadata::set_allocated_table_name(::std::string* table_name) {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    delete table_name_;
  }
  if (table_name) {
    set_has_table_name();
    table_name_ = table_name;
  } else {
    clear_has_table_name();
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string column_name = 4;
inline bool ColumnMetadata::has_column_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ColumnMetadata::set_has_column_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ColumnMetadata::clear_has_column_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ColumnMetadata::clear_column_name() {
  if (column_name_ != &::google::protobuf::internal::kEmptyString) {
    column_name_->clear();
  }
  clear_has_column_name();
}
inline const ::std::string& ColumnMetadata::column_name() const {
  return *column_name_;
}
inline void ColumnMetadata::set_column_name(const ::std::string& value) {
  set_has_column_name();
  if (column_name_ == &::google::protobuf::internal::kEmptyString) {
    column_name_ = new ::std::string;
  }
  column_name_->assign(value);
}
inline void ColumnMetadata::set_column_name(const char* value) {
  set_has_column_name();
  if (column_name_ == &::google::protobuf::internal::kEmptyString) {
    column_name_ = new ::std::string;
  }
  column_name_->assign(value);
}
inline void ColumnMetadata::set_column_name(const char* value, size_t size) {
  set_has_column_name();
  if (column_name_ == &::google::protobuf::internal::kEmptyString) {
    column_name_ = new ::std::string;
  }
  column_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ColumnMetadata::mutable_column_name() {
  set_has_column_name();
  if (column_name_ == &::google::protobuf::internal::kEmptyString) {
    column_name_ = new ::std::string;
  }
  return column_name_;
}
inline ::std::string* ColumnMetadata::release_column_name() {
  clear_has_column_name();
  if (column_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = column_name_;
    column_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ColumnMetadata::set_allocated_column_name(::std::string* column_name) {
  if (column_name_ != &::google::protobuf::internal::kEmptyString) {
    delete column_name_;
  }
  if (column_name) {
    set_has_column_name();
    column_name_ = column_name;
  } else {
    clear_has_column_name();
    column_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 ordinal_position = 5;
inline bool ColumnMetadata::has_ordinal_position() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ColumnMetadata::set_has_ordinal_position() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ColumnMetadata::clear_has_ordinal_position() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ColumnMetadata::clear_ordinal_position() {
  ordinal_position_ = 0;
  clear_has_ordinal_position();
}
inline ::google::protobuf::int32 ColumnMetadata::ordinal_position() const {
  return ordinal_position_;
}
inline void ColumnMetadata::set_ordinal_position(::google::protobuf::int32 value) {
  set_has_ordinal_position();
  ordinal_position_ = value;
}

// optional string default_value = 6;
inline bool ColumnMetadata::has_default_value() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ColumnMetadata::set_has_default_value() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ColumnMetadata::clear_has_default_value() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ColumnMetadata::clear_default_value() {
  if (default_value_ != &::google::protobuf::internal::kEmptyString) {
    default_value_->clear();
  }
  clear_has_default_value();
}
inline const ::std::string& ColumnMetadata::default_value() const {
  return *default_value_;
}
inline void ColumnMetadata::set_default_value(const ::std::string& value) {
  set_has_default_value();
  if (default_value_ == &::google::protobuf::internal::kEmptyString) {
    default_value_ = new ::std::string;
  }
  default_value_->assign(value);
}
inline void ColumnMetadata::set_default_value(const char* value) {
  set_has_default_value();
  if (default_value_ == &::google::protobuf::internal::kEmptyString) {
    default_value_ = new ::std::string;
  }
  default_value_->assign(value);
}
inline void ColumnMetadata::set_default_value(const char* value, size_t size) {
  set_has_default_value();
  if (default_value_ == &::google::protobuf::internal::kEmptyString) {
    default_value_ = new ::std::string;
  }
  default_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ColumnMetadata::mutable_default_value() {
  set_has_default_value();
  if (default_value_ == &::google::protobuf::internal::kEmptyString) {
    default_value_ = new ::std::string;
  }
  return default_value_;
}
inline ::std::string* ColumnMetadata::release_default_value() {
  clear_has_default_value();
  if (default_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = default_value_;
    default_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ColumnMetadata::set_allocated_default_value(::std::string* default_value) {
  if (default_value_ != &::google::protobuf::internal::kEmptyString) {
    delete default_value_;
  }
  if (default_value) {
    set_has_default_value();
    default_value_ = default_value;
  } else {
    clear_has_default_value();
    default_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_nullable = 7;
inline bool ColumnMetadata::has_is_nullable() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ColumnMetadata::set_has_is_nullable() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ColumnMetadata::clear_has_is_nullable() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ColumnMetadata::clear_is_nullable() {
  is_nullable_ = false;
  clear_has_is_nullable();
}
inline bool ColumnMetadata::is_nullable() const {
  return is_nullable_;
}
inline void ColumnMetadata::set_is_nullable(bool value) {
  set_has_is_nullable();
  is_nullable_ = value;
}

// optional string data_type = 8;
inline bool ColumnMetadata::has_data_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ColumnMetadata::set_has_data_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ColumnMetadata::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ColumnMetadata::clear_data_type() {
  if (data_type_ != &::google::protobuf::internal::kEmptyString) {
    data_type_->clear();
  }
  clear_has_data_type();
}
inline const ::std::string& ColumnMetadata::data_type() const {
  return *data_type_;
}
inline void ColumnMetadata::set_data_type(const ::std::string& value) {
  set_has_data_type();
  if (data_type_ == &::google::protobuf::internal::kEmptyString) {
    data_type_ = new ::std::string;
  }
  data_type_->assign(value);
}
inline void ColumnMetadata::set_data_type(const char* value) {
  set_has_data_type();
  if (data_type_ == &::google::protobuf::internal::kEmptyString) {
    data_type_ = new ::std::string;
  }
  data_type_->assign(value);
}
inline void ColumnMetadata::set_data_type(const char* value, size_t size) {
  set_has_data_type();
  if (data_type_ == &::google::protobuf::internal::kEmptyString) {
    data_type_ = new ::std::string;
  }
  data_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ColumnMetadata::mutable_data_type() {
  set_has_data_type();
  if (data_type_ == &::google::protobuf::internal::kEmptyString) {
    data_type_ = new ::std::string;
  }
  return data_type_;
}
inline ::std::string* ColumnMetadata::release_data_type() {
  clear_has_data_type();
  if (data_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_type_;
    data_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ColumnMetadata::set_allocated_data_type(::std::string* data_type) {
  if (data_type_ != &::google::protobuf::internal::kEmptyString) {
    delete data_type_;
  }
  if (data_type) {
    set_has_data_type();
    data_type_ = data_type;
  } else {
    clear_has_data_type();
    data_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 char_max_length = 9;
inline bool ColumnMetadata::has_char_max_length() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ColumnMetadata::set_has_char_max_length() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ColumnMetadata::clear_has_char_max_length() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ColumnMetadata::clear_char_max_length() {
  char_max_length_ = 0;
  clear_has_char_max_length();
}
inline ::google::protobuf::int32 ColumnMetadata::char_max_length() const {
  return char_max_length_;
}
inline void ColumnMetadata::set_char_max_length(::google::protobuf::int32 value) {
  set_has_char_max_length();
  char_max_length_ = value;
}

// optional int32 char_octet_length = 10;
inline bool ColumnMetadata::has_char_octet_length() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ColumnMetadata::set_has_char_octet_length() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ColumnMetadata::clear_has_char_octet_length() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ColumnMetadata::clear_char_octet_length() {
  char_octet_length_ = 0;
  clear_has_char_octet_length();
}
inline ::google::protobuf::int32 ColumnMetadata::char_octet_length() const {
  return char_octet_length_;
}
inline void ColumnMetadata::set_char_octet_length(::google::protobuf::int32 value) {
  set_has_char_octet_length();
  char_octet_length_ = value;
}

// optional int32 numeric_precision = 11;
inline bool ColumnMetadata::has_numeric_precision() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ColumnMetadata::set_has_numeric_precision() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ColumnMetadata::clear_has_numeric_precision() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ColumnMetadata::clear_numeric_precision() {
  numeric_precision_ = 0;
  clear_has_numeric_precision();
}
inline ::google::protobuf::int32 ColumnMetadata::numeric_precision() const {
  return numeric_precision_;
}
inline void ColumnMetadata::set_numeric_precision(::google::protobuf::int32 value) {
  set_has_numeric_precision();
  numeric_precision_ = value;
}

// optional int32 numeric_precision_radix = 12;
inline bool ColumnMetadata::has_numeric_precision_radix() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ColumnMetadata::set_has_numeric_precision_radix() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ColumnMetadata::clear_has_numeric_precision_radix() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ColumnMetadata::clear_numeric_precision_radix() {
  numeric_precision_radix_ = 0;
  clear_has_numeric_precision_radix();
}
inline ::google::protobuf::int32 ColumnMetadata::numeric_precision_radix() const {
  return numeric_precision_radix_;
}
inline void ColumnMetadata::set_numeric_precision_radix(::google::protobuf::int32 value) {
  set_has_numeric_precision_radix();
  numeric_precision_radix_ = value;
}

// optional int32 numeric_scale = 13;
inline bool ColumnMetadata::has_numeric_scale() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ColumnMetadata::set_has_numeric_scale() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ColumnMetadata::clear_has_numeric_scale() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ColumnMetadata::clear_numeric_scale() {
  numeric_scale_ = 0;
  clear_has_numeric_scale();
}
inline ::google::protobuf::int32 ColumnMetadata::numeric_scale() const {
  return numeric_scale_;
}
inline void ColumnMetadata::set_numeric_scale(::google::protobuf::int32 value) {
  set_has_numeric_scale();
  numeric_scale_ = value;
}

// optional int32 date_time_precision = 14;
inline bool ColumnMetadata::has_date_time_precision() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ColumnMetadata::set_has_date_time_precision() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ColumnMetadata::clear_has_date_time_precision() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ColumnMetadata::clear_date_time_precision() {
  date_time_precision_ = 0;
  clear_has_date_time_precision();
}
inline ::google::protobuf::int32 ColumnMetadata::date_time_precision() const {
  return date_time_precision_;
}
inline void ColumnMetadata::set_date_time_precision(::google::protobuf::int32 value) {
  set_has_date_time_precision();
  date_time_precision_ = value;
}

// optional string interval_type = 15;
inline bool ColumnMetadata::has_interval_type() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ColumnMetadata::set_has_interval_type() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ColumnMetadata::clear_has_interval_type() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ColumnMetadata::clear_interval_type() {
  if (interval_type_ != &::google::protobuf::internal::kEmptyString) {
    interval_type_->clear();
  }
  clear_has_interval_type();
}
inline const ::std::string& ColumnMetadata::interval_type() const {
  return *interval_type_;
}
inline void ColumnMetadata::set_interval_type(const ::std::string& value) {
  set_has_interval_type();
  if (interval_type_ == &::google::protobuf::internal::kEmptyString) {
    interval_type_ = new ::std::string;
  }
  interval_type_->assign(value);
}
inline void ColumnMetadata::set_interval_type(const char* value) {
  set_has_interval_type();
  if (interval_type_ == &::google::protobuf::internal::kEmptyString) {
    interval_type_ = new ::std::string;
  }
  interval_type_->assign(value);
}
inline void ColumnMetadata::set_interval_type(const char* value, size_t size) {
  set_has_interval_type();
  if (interval_type_ == &::google::protobuf::internal::kEmptyString) {
    interval_type_ = new ::std::string;
  }
  interval_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ColumnMetadata::mutable_interval_type() {
  set_has_interval_type();
  if (interval_type_ == &::google::protobuf::internal::kEmptyString) {
    interval_type_ = new ::std::string;
  }
  return interval_type_;
}
inline ::std::string* ColumnMetadata::release_interval_type() {
  clear_has_interval_type();
  if (interval_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = interval_type_;
    interval_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ColumnMetadata::set_allocated_interval_type(::std::string* interval_type) {
  if (interval_type_ != &::google::protobuf::internal::kEmptyString) {
    delete interval_type_;
  }
  if (interval_type) {
    set_has_interval_type();
    interval_type_ = interval_type;
  } else {
    clear_has_interval_type();
    interval_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 interval_precision = 16;
inline bool ColumnMetadata::has_interval_precision() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ColumnMetadata::set_has_interval_precision() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ColumnMetadata::clear_has_interval_precision() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ColumnMetadata::clear_interval_precision() {
  interval_precision_ = 0;
  clear_has_interval_precision();
}
inline ::google::protobuf::int32 ColumnMetadata::interval_precision() const {
  return interval_precision_;
}
inline void ColumnMetadata::set_interval_precision(::google::protobuf::int32 value) {
  set_has_interval_precision();
  interval_precision_ = value;
}

// optional int32 column_size = 17;
inline bool ColumnMetadata::has_column_size() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ColumnMetadata::set_has_column_size() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ColumnMetadata::clear_has_column_size() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ColumnMetadata::clear_column_size() {
  column_size_ = 0;
  clear_has_column_size();
}
inline ::google::protobuf::int32 ColumnMetadata::column_size() const {
  return column_size_;
}
inline void ColumnMetadata::set_column_size(::google::protobuf::int32 value) {
  set_has_column_size();
  column_size_ = value;
}

// -------------------------------------------------------------------

// GetColumnsResp

// optional .exec.user.RequestStatus status = 1;
inline bool GetColumnsResp::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetColumnsResp::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetColumnsResp::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetColumnsResp::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::exec::user::RequestStatus GetColumnsResp::status() const {
  return static_cast< ::exec::user::RequestStatus >(status_);
}
inline void GetColumnsResp::set_status(::exec::user::RequestStatus value) {
  assert(::exec::user::RequestStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// repeated .exec.user.ColumnMetadata columns = 2;
inline int GetColumnsResp::columns_size() const {
  return columns_.size();
}
inline void GetColumnsResp::clear_columns() {
  columns_.Clear();
}
inline const ::exec::user::ColumnMetadata& GetColumnsResp::columns(int index) const {
  return columns_.Get(index);
}
inline ::exec::user::ColumnMetadata* GetColumnsResp::mutable_columns(int index) {
  return columns_.Mutable(index);
}
inline ::exec::user::ColumnMetadata* GetColumnsResp::add_columns() {
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::user::ColumnMetadata >&
GetColumnsResp::columns() const {
  return columns_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::user::ColumnMetadata >*
GetColumnsResp::mutable_columns() {
  return &columns_;
}

// optional .exec.shared.DrillPBError error = 3;
inline bool GetColumnsResp::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetColumnsResp::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetColumnsResp::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetColumnsResp::clear_error() {
  if (error_ != NULL) error_->::exec::shared::DrillPBError::Clear();
  clear_has_error();
}
inline const ::exec::shared::DrillPBError& GetColumnsResp::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::exec::shared::DrillPBError* GetColumnsResp::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::exec::shared::DrillPBError;
  return error_;
}
inline ::exec::shared::DrillPBError* GetColumnsResp::release_error() {
  clear_has_error();
  ::exec::shared::DrillPBError* temp = error_;
  error_ = NULL;
  return temp;
}
inline void GetColumnsResp::set_allocated_error(::exec::shared::DrillPBError* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
}

// -------------------------------------------------------------------

// CreatePreparedStatementReq

// optional string sql_query = 1;
inline bool CreatePreparedStatementReq::has_sql_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreatePreparedStatementReq::set_has_sql_query() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreatePreparedStatementReq::clear_has_sql_query() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreatePreparedStatementReq::clear_sql_query() {
  if (sql_query_ != &::google::protobuf::internal::kEmptyString) {
    sql_query_->clear();
  }
  clear_has_sql_query();
}
inline const ::std::string& CreatePreparedStatementReq::sql_query() const {
  return *sql_query_;
}
inline void CreatePreparedStatementReq::set_sql_query(const ::std::string& value) {
  set_has_sql_query();
  if (sql_query_ == &::google::protobuf::internal::kEmptyString) {
    sql_query_ = new ::std::string;
  }
  sql_query_->assign(value);
}
inline void CreatePreparedStatementReq::set_sql_query(const char* value) {
  set_has_sql_query();
  if (sql_query_ == &::google::protobuf::internal::kEmptyString) {
    sql_query_ = new ::std::string;
  }
  sql_query_->assign(value);
}
inline void CreatePreparedStatementReq::set_sql_query(const char* value, size_t size) {
  set_has_sql_query();
  if (sql_query_ == &::google::protobuf::internal::kEmptyString) {
    sql_query_ = new ::std::string;
  }
  sql_query_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreatePreparedStatementReq::mutable_sql_query() {
  set_has_sql_query();
  if (sql_query_ == &::google::protobuf::internal::kEmptyString) {
    sql_query_ = new ::std::string;
  }
  return sql_query_;
}
inline ::std::string* CreatePreparedStatementReq::release_sql_query() {
  clear_has_sql_query();
  if (sql_query_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sql_query_;
    sql_query_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreatePreparedStatementReq::set_allocated_sql_query(::std::string* sql_query) {
  if (sql_query_ != &::google::protobuf::internal::kEmptyString) {
    delete sql_query_;
  }
  if (sql_query) {
    set_has_sql_query();
    sql_query_ = sql_query;
  } else {
    clear_has_sql_query();
    sql_query_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResultColumnMetadata

// optional string catalog_name = 1;
inline bool ResultColumnMetadata::has_catalog_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResultColumnMetadata::set_has_catalog_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResultColumnMetadata::clear_has_catalog_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResultColumnMetadata::clear_catalog_name() {
  if (catalog_name_ != &::google::protobuf::internal::kEmptyString) {
    catalog_name_->clear();
  }
  clear_has_catalog_name();
}
inline const ::std::string& ResultColumnMetadata::catalog_name() const {
  return *catalog_name_;
}
inline void ResultColumnMetadata::set_catalog_name(const ::std::string& value) {
  set_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    catalog_name_ = new ::std::string;
  }
  catalog_name_->assign(value);
}
inline void ResultColumnMetadata::set_catalog_name(const char* value) {
  set_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    catalog_name_ = new ::std::string;
  }
  catalog_name_->assign(value);
}
inline void ResultColumnMetadata::set_catalog_name(const char* value, size_t size) {
  set_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    catalog_name_ = new ::std::string;
  }
  catalog_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResultColumnMetadata::mutable_catalog_name() {
  set_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    catalog_name_ = new ::std::string;
  }
  return catalog_name_;
}
inline ::std::string* ResultColumnMetadata::release_catalog_name() {
  clear_has_catalog_name();
  if (catalog_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = catalog_name_;
    catalog_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResultColumnMetadata::set_allocated_catalog_name(::std::string* catalog_name) {
  if (catalog_name_ != &::google::protobuf::internal::kEmptyString) {
    delete catalog_name_;
  }
  if (catalog_name) {
    set_has_catalog_name();
    catalog_name_ = catalog_name;
  } else {
    clear_has_catalog_name();
    catalog_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string schema_name = 2;
inline bool ResultColumnMetadata::has_schema_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResultColumnMetadata::set_has_schema_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResultColumnMetadata::clear_has_schema_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResultColumnMetadata::clear_schema_name() {
  if (schema_name_ != &::google::protobuf::internal::kEmptyString) {
    schema_name_->clear();
  }
  clear_has_schema_name();
}
inline const ::std::string& ResultColumnMetadata::schema_name() const {
  return *schema_name_;
}
inline void ResultColumnMetadata::set_schema_name(const ::std::string& value) {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::kEmptyString) {
    schema_name_ = new ::std::string;
  }
  schema_name_->assign(value);
}
inline void ResultColumnMetadata::set_schema_name(const char* value) {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::kEmptyString) {
    schema_name_ = new ::std::string;
  }
  schema_name_->assign(value);
}
inline void ResultColumnMetadata::set_schema_name(const char* value, size_t size) {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::kEmptyString) {
    schema_name_ = new ::std::string;
  }
  schema_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResultColumnMetadata::mutable_schema_name() {
  set_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::kEmptyString) {
    schema_name_ = new ::std::string;
  }
  return schema_name_;
}
inline ::std::string* ResultColumnMetadata::release_schema_name() {
  clear_has_schema_name();
  if (schema_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = schema_name_;
    schema_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResultColumnMetadata::set_allocated_schema_name(::std::string* schema_name) {
  if (schema_name_ != &::google::protobuf::internal::kEmptyString) {
    delete schema_name_;
  }
  if (schema_name) {
    set_has_schema_name();
    schema_name_ = schema_name;
  } else {
    clear_has_schema_name();
    schema_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string table_name = 3;
inline bool ResultColumnMetadata::has_table_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResultColumnMetadata::set_has_table_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResultColumnMetadata::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResultColumnMetadata::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& ResultColumnMetadata::table_name() const {
  return *table_name_;
}
inline void ResultColumnMetadata::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void ResultColumnMetadata::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void ResultColumnMetadata::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResultColumnMetadata::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  return table_name_;
}
inline ::std::string* ResultColumnMetadata::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResultColumnMetadata::set_allocated_table_name(::std::string* table_name) {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    delete table_name_;
  }
  if (table_name) {
    set_has_table_name();
    table_name_ = table_name;
  } else {
    clear_has_table_name();
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string column_name = 4;
inline bool ResultColumnMetadata::has_column_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResultColumnMetadata::set_has_column_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResultColumnMetadata::clear_has_column_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResultColumnMetadata::clear_column_name() {
  if (column_name_ != &::google::protobuf::internal::kEmptyString) {
    column_name_->clear();
  }
  clear_has_column_name();
}
inline const ::std::string& ResultColumnMetadata::column_name() const {
  return *column_name_;
}
inline void ResultColumnMetadata::set_column_name(const ::std::string& value) {
  set_has_column_name();
  if (column_name_ == &::google::protobuf::internal::kEmptyString) {
    column_name_ = new ::std::string;
  }
  column_name_->assign(value);
}
inline void ResultColumnMetadata::set_column_name(const char* value) {
  set_has_column_name();
  if (column_name_ == &::google::protobuf::internal::kEmptyString) {
    column_name_ = new ::std::string;
  }
  column_name_->assign(value);
}
inline void ResultColumnMetadata::set_column_name(const char* value, size_t size) {
  set_has_column_name();
  if (column_name_ == &::google::protobuf::internal::kEmptyString) {
    column_name_ = new ::std::string;
  }
  column_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResultColumnMetadata::mutable_column_name() {
  set_has_column_name();
  if (column_name_ == &::google::protobuf::internal::kEmptyString) {
    column_name_ = new ::std::string;
  }
  return column_name_;
}
inline ::std::string* ResultColumnMetadata::release_column_name() {
  clear_has_column_name();
  if (column_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = column_name_;
    column_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResultColumnMetadata::set_allocated_column_name(::std::string* column_name) {
  if (column_name_ != &::google::protobuf::internal::kEmptyString) {
    delete column_name_;
  }
  if (column_name) {
    set_has_column_name();
    column_name_ = column_name;
  } else {
    clear_has_column_name();
    column_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string label = 5;
inline bool ResultColumnMetadata::has_label() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResultColumnMetadata::set_has_label() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResultColumnMetadata::clear_has_label() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResultColumnMetadata::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& ResultColumnMetadata::label() const {
  return *label_;
}
inline void ResultColumnMetadata::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void ResultColumnMetadata::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void ResultColumnMetadata::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResultColumnMetadata::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* ResultColumnMetadata::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResultColumnMetadata::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string data_type = 6;
inline bool ResultColumnMetadata::has_data_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResultColumnMetadata::set_has_data_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResultColumnMetadata::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResultColumnMetadata::clear_data_type() {
  if (data_type_ != &::google::protobuf::internal::kEmptyString) {
    data_type_->clear();
  }
  clear_has_data_type();
}
inline const ::std::string& ResultColumnMetadata::data_type() const {
  return *data_type_;
}
inline void ResultColumnMetadata::set_data_type(const ::std::string& value) {
  set_has_data_type();
  if (data_type_ == &::google::protobuf::internal::kEmptyString) {
    data_type_ = new ::std::string;
  }
  data_type_->assign(value);
}
inline void ResultColumnMetadata::set_data_type(const char* value) {
  set_has_data_type();
  if (data_type_ == &::google::protobuf::internal::kEmptyString) {
    data_type_ = new ::std::string;
  }
  data_type_->assign(value);
}
inline void ResultColumnMetadata::set_data_type(const char* value, size_t size) {
  set_has_data_type();
  if (data_type_ == &::google::protobuf::internal::kEmptyString) {
    data_type_ = new ::std::string;
  }
  data_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResultColumnMetadata::mutable_data_type() {
  set_has_data_type();
  if (data_type_ == &::google::protobuf::internal::kEmptyString) {
    data_type_ = new ::std::string;
  }
  return data_type_;
}
inline ::std::string* ResultColumnMetadata::release_data_type() {
  clear_has_data_type();
  if (data_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_type_;
    data_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResultColumnMetadata::set_allocated_data_type(::std::string* data_type) {
  if (data_type_ != &::google::protobuf::internal::kEmptyString) {
    delete data_type_;
  }
  if (data_type) {
    set_has_data_type();
    data_type_ = data_type;
  } else {
    clear_has_data_type();
    data_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_nullable = 7;
inline bool ResultColumnMetadata::has_is_nullable() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResultColumnMetadata::set_has_is_nullable() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResultColumnMetadata::clear_has_is_nullable() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResultColumnMetadata::clear_is_nullable() {
  is_nullable_ = false;
  clear_has_is_nullable();
}
inline bool ResultColumnMetadata::is_nullable() const {
  return is_nullable_;
}
inline void ResultColumnMetadata::set_is_nullable(bool value) {
  set_has_is_nullable();
  is_nullable_ = value;
}

// optional int32 precision = 8;
inline bool ResultColumnMetadata::has_precision() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResultColumnMetadata::set_has_precision() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResultColumnMetadata::clear_has_precision() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResultColumnMetadata::clear_precision() {
  precision_ = 0;
  clear_has_precision();
}
inline ::google::protobuf::int32 ResultColumnMetadata::precision() const {
  return precision_;
}
inline void ResultColumnMetadata::set_precision(::google::protobuf::int32 value) {
  set_has_precision();
  precision_ = value;
}

// optional int32 scale = 9;
inline bool ResultColumnMetadata::has_scale() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResultColumnMetadata::set_has_scale() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResultColumnMetadata::clear_has_scale() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResultColumnMetadata::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline ::google::protobuf::int32 ResultColumnMetadata::scale() const {
  return scale_;
}
inline void ResultColumnMetadata::set_scale(::google::protobuf::int32 value) {
  set_has_scale();
  scale_ = value;
}

// optional bool signed = 10;
inline bool ResultColumnMetadata::has_signed_() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResultColumnMetadata::set_has_signed_() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResultColumnMetadata::clear_has_signed_() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResultColumnMetadata::clear_signed_() {
  signed__ = false;
  clear_has_signed_();
}
inline bool ResultColumnMetadata::signed_() const {
  return signed__;
}
inline void ResultColumnMetadata::set_signed_(bool value) {
  set_has_signed_();
  signed__ = value;
}

// optional int32 display_size = 11;
inline bool ResultColumnMetadata::has_display_size() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ResultColumnMetadata::set_has_display_size() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ResultColumnMetadata::clear_has_display_size() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ResultColumnMetadata::clear_display_size() {
  display_size_ = 0;
  clear_has_display_size();
}
inline ::google::protobuf::int32 ResultColumnMetadata::display_size() const {
  return display_size_;
}
inline void ResultColumnMetadata::set_display_size(::google::protobuf::int32 value) {
  set_has_display_size();
  display_size_ = value;
}

// optional bool is_aliased = 12;
inline bool ResultColumnMetadata::has_is_aliased() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ResultColumnMetadata::set_has_is_aliased() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ResultColumnMetadata::clear_has_is_aliased() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ResultColumnMetadata::clear_is_aliased() {
  is_aliased_ = false;
  clear_has_is_aliased();
}
inline bool ResultColumnMetadata::is_aliased() const {
  return is_aliased_;
}
inline void ResultColumnMetadata::set_is_aliased(bool value) {
  set_has_is_aliased();
  is_aliased_ = value;
}

// optional .exec.user.ColumnSearchability searchability = 13;
inline bool ResultColumnMetadata::has_searchability() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ResultColumnMetadata::set_has_searchability() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ResultColumnMetadata::clear_has_searchability() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ResultColumnMetadata::clear_searchability() {
  searchability_ = 0;
  clear_has_searchability();
}
inline ::exec::user::ColumnSearchability ResultColumnMetadata::searchability() const {
  return static_cast< ::exec::user::ColumnSearchability >(searchability_);
}
inline void ResultColumnMetadata::set_searchability(::exec::user::ColumnSearchability value) {
  assert(::exec::user::ColumnSearchability_IsValid(value));
  set_has_searchability();
  searchability_ = value;
}

// optional .exec.user.ColumnUpdatability updatability = 14;
inline bool ResultColumnMetadata::has_updatability() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ResultColumnMetadata::set_has_updatability() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ResultColumnMetadata::clear_has_updatability() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ResultColumnMetadata::clear_updatability() {
  updatability_ = 0;
  clear_has_updatability();
}
inline ::exec::user::ColumnUpdatability ResultColumnMetadata::updatability() const {
  return static_cast< ::exec::user::ColumnUpdatability >(updatability_);
}
inline void ResultColumnMetadata::set_updatability(::exec::user::ColumnUpdatability value) {
  assert(::exec::user::ColumnUpdatability_IsValid(value));
  set_has_updatability();
  updatability_ = value;
}

// optional bool auto_increment = 15;
inline bool ResultColumnMetadata::has_auto_increment() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ResultColumnMetadata::set_has_auto_increment() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ResultColumnMetadata::clear_has_auto_increment() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ResultColumnMetadata::clear_auto_increment() {
  auto_increment_ = false;
  clear_has_auto_increment();
}
inline bool ResultColumnMetadata::auto_increment() const {
  return auto_increment_;
}
inline void ResultColumnMetadata::set_auto_increment(bool value) {
  set_has_auto_increment();
  auto_increment_ = value;
}

// optional bool case_sensitivity = 16;
inline bool ResultColumnMetadata::has_case_sensitivity() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ResultColumnMetadata::set_has_case_sensitivity() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ResultColumnMetadata::clear_has_case_sensitivity() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ResultColumnMetadata::clear_case_sensitivity() {
  case_sensitivity_ = false;
  clear_has_case_sensitivity();
}
inline bool ResultColumnMetadata::case_sensitivity() const {
  return case_sensitivity_;
}
inline void ResultColumnMetadata::set_case_sensitivity(bool value) {
  set_has_case_sensitivity();
  case_sensitivity_ = value;
}

// optional bool sortable = 17;
inline bool ResultColumnMetadata::has_sortable() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ResultColumnMetadata::set_has_sortable() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ResultColumnMetadata::clear_has_sortable() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ResultColumnMetadata::clear_sortable() {
  sortable_ = false;
  clear_has_sortable();
}
inline bool ResultColumnMetadata::sortable() const {
  return sortable_;
}
inline void ResultColumnMetadata::set_sortable(bool value) {
  set_has_sortable();
  sortable_ = value;
}

// optional string class_name = 18;
inline bool ResultColumnMetadata::has_class_name() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ResultColumnMetadata::set_has_class_name() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ResultColumnMetadata::clear_has_class_name() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ResultColumnMetadata::clear_class_name() {
  if (class_name_ != &::google::protobuf::internal::kEmptyString) {
    class_name_->clear();
  }
  clear_has_class_name();
}
inline const ::std::string& ResultColumnMetadata::class_name() const {
  return *class_name_;
}
inline void ResultColumnMetadata::set_class_name(const ::std::string& value) {
  set_has_class_name();
  if (class_name_ == &::google::protobuf::internal::kEmptyString) {
    class_name_ = new ::std::string;
  }
  class_name_->assign(value);
}
inline void ResultColumnMetadata::set_class_name(const char* value) {
  set_has_class_name();
  if (class_name_ == &::google::protobuf::internal::kEmptyString) {
    class_name_ = new ::std::string;
  }
  class_name_->assign(value);
}
inline void ResultColumnMetadata::set_class_name(const char* value, size_t size) {
  set_has_class_name();
  if (class_name_ == &::google::protobuf::internal::kEmptyString) {
    class_name_ = new ::std::string;
  }
  class_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResultColumnMetadata::mutable_class_name() {
  set_has_class_name();
  if (class_name_ == &::google::protobuf::internal::kEmptyString) {
    class_name_ = new ::std::string;
  }
  return class_name_;
}
inline ::std::string* ResultColumnMetadata::release_class_name() {
  clear_has_class_name();
  if (class_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = class_name_;
    class_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResultColumnMetadata::set_allocated_class_name(::std::string* class_name) {
  if (class_name_ != &::google::protobuf::internal::kEmptyString) {
    delete class_name_;
  }
  if (class_name) {
    set_has_class_name();
    class_name_ = class_name;
  } else {
    clear_has_class_name();
    class_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_currency = 20;
inline bool ResultColumnMetadata::has_is_currency() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ResultColumnMetadata::set_has_is_currency() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ResultColumnMetadata::clear_has_is_currency() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ResultColumnMetadata::clear_is_currency() {
  is_currency_ = false;
  clear_has_is_currency();
}
inline bool ResultColumnMetadata::is_currency() const {
  return is_currency_;
}
inline void ResultColumnMetadata::set_is_currency(bool value) {
  set_has_is_currency();
  is_currency_ = value;
}

// -------------------------------------------------------------------

// PreparedStatementHandle

// optional bytes server_info = 1;
inline bool PreparedStatementHandle::has_server_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PreparedStatementHandle::set_has_server_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PreparedStatementHandle::clear_has_server_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PreparedStatementHandle::clear_server_info() {
  if (server_info_ != &::google::protobuf::internal::kEmptyString) {
    server_info_->clear();
  }
  clear_has_server_info();
}
inline const ::std::string& PreparedStatementHandle::server_info() const {
  return *server_info_;
}
inline void PreparedStatementHandle::set_server_info(const ::std::string& value) {
  set_has_server_info();
  if (server_info_ == &::google::protobuf::internal::kEmptyString) {
    server_info_ = new ::std::string;
  }
  server_info_->assign(value);
}
inline void PreparedStatementHandle::set_server_info(const char* value) {
  set_has_server_info();
  if (server_info_ == &::google::protobuf::internal::kEmptyString) {
    server_info_ = new ::std::string;
  }
  server_info_->assign(value);
}
inline void PreparedStatementHandle::set_server_info(const void* value, size_t size) {
  set_has_server_info();
  if (server_info_ == &::google::protobuf::internal::kEmptyString) {
    server_info_ = new ::std::string;
  }
  server_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PreparedStatementHandle::mutable_server_info() {
  set_has_server_info();
  if (server_info_ == &::google::protobuf::internal::kEmptyString) {
    server_info_ = new ::std::string;
  }
  return server_info_;
}
inline ::std::string* PreparedStatementHandle::release_server_info() {
  clear_has_server_info();
  if (server_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_info_;
    server_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PreparedStatementHandle::set_allocated_server_info(::std::string* server_info) {
  if (server_info_ != &::google::protobuf::internal::kEmptyString) {
    delete server_info_;
  }
  if (server_info) {
    set_has_server_info();
    server_info_ = server_info;
  } else {
    clear_has_server_info();
    server_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PreparedStatement

// repeated .exec.user.ResultColumnMetadata columns = 1;
inline int PreparedStatement::columns_size() const {
  return columns_.size();
}
inline void PreparedStatement::clear_columns() {
  columns_.Clear();
}
inline const ::exec::user::ResultColumnMetadata& PreparedStatement::columns(int index) const {
  return columns_.Get(index);
}
inline ::exec::user::ResultColumnMetadata* PreparedStatement::mutable_columns(int index) {
  return columns_.Mutable(index);
}
inline ::exec::user::ResultColumnMetadata* PreparedStatement::add_columns() {
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::user::ResultColumnMetadata >&
PreparedStatement::columns() const {
  return columns_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::user::ResultColumnMetadata >*
PreparedStatement::mutable_columns() {
  return &columns_;
}

// optional .exec.user.PreparedStatementHandle server_handle = 2;
inline bool PreparedStatement::has_server_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PreparedStatement::set_has_server_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PreparedStatement::clear_has_server_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PreparedStatement::clear_server_handle() {
  if (server_handle_ != NULL) server_handle_->::exec::user::PreparedStatementHandle::Clear();
  clear_has_server_handle();
}
inline const ::exec::user::PreparedStatementHandle& PreparedStatement::server_handle() const {
  return server_handle_ != NULL ? *server_handle_ : *default_instance_->server_handle_;
}
inline ::exec::user::PreparedStatementHandle* PreparedStatement::mutable_server_handle() {
  set_has_server_handle();
  if (server_handle_ == NULL) server_handle_ = new ::exec::user::PreparedStatementHandle;
  return server_handle_;
}
inline ::exec::user::PreparedStatementHandle* PreparedStatement::release_server_handle() {
  clear_has_server_handle();
  ::exec::user::PreparedStatementHandle* temp = server_handle_;
  server_handle_ = NULL;
  return temp;
}
inline void PreparedStatement::set_allocated_server_handle(::exec::user::PreparedStatementHandle* server_handle) {
  delete server_handle_;
  server_handle_ = server_handle;
  if (server_handle) {
    set_has_server_handle();
  } else {
    clear_has_server_handle();
  }
}

// -------------------------------------------------------------------

// CreatePreparedStatementResp

// optional .exec.user.RequestStatus status = 1;
inline bool CreatePreparedStatementResp::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreatePreparedStatementResp::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreatePreparedStatementResp::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreatePreparedStatementResp::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::exec::user::RequestStatus CreatePreparedStatementResp::status() const {
  return static_cast< ::exec::user::RequestStatus >(status_);
}
inline void CreatePreparedStatementResp::set_status(::exec::user::RequestStatus value) {
  assert(::exec::user::RequestStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .exec.user.PreparedStatement prepared_statement = 2;
inline bool CreatePreparedStatementResp::has_prepared_statement() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreatePreparedStatementResp::set_has_prepared_statement() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreatePreparedStatementResp::clear_has_prepared_statement() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreatePreparedStatementResp::clear_prepared_statement() {
  if (prepared_statement_ != NULL) prepared_statement_->::exec::user::PreparedStatement::Clear();
  clear_has_prepared_statement();
}
inline const ::exec::user::PreparedStatement& CreatePreparedStatementResp::prepared_statement() const {
  return prepared_statement_ != NULL ? *prepared_statement_ : *default_instance_->prepared_statement_;
}
inline ::exec::user::PreparedStatement* CreatePreparedStatementResp::mutable_prepared_statement() {
  set_has_prepared_statement();
  if (prepared_statement_ == NULL) prepared_statement_ = new ::exec::user::PreparedStatement;
  return prepared_statement_;
}
inline ::exec::user::PreparedStatement* CreatePreparedStatementResp::release_prepared_statement() {
  clear_has_prepared_statement();
  ::exec::user::PreparedStatement* temp = prepared_statement_;
  prepared_statement_ = NULL;
  return temp;
}
inline void CreatePreparedStatementResp::set_allocated_prepared_statement(::exec::user::PreparedStatement* prepared_statement) {
  delete prepared_statement_;
  prepared_statement_ = prepared_statement;
  if (prepared_statement) {
    set_has_prepared_statement();
  } else {
    clear_has_prepared_statement();
  }
}

// optional .exec.shared.DrillPBError error = 3;
inline bool CreatePreparedStatementResp::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreatePreparedStatementResp::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreatePreparedStatementResp::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreatePreparedStatementResp::clear_error() {
  if (error_ != NULL) error_->::exec::shared::DrillPBError::Clear();
  clear_has_error();
}
inline const ::exec::shared::DrillPBError& CreatePreparedStatementResp::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::exec::shared::DrillPBError* CreatePreparedStatementResp::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::exec::shared::DrillPBError;
  return error_;
}
inline ::exec::shared::DrillPBError* CreatePreparedStatementResp::release_error() {
  clear_has_error();
  ::exec::shared::DrillPBError* temp = error_;
  error_ = NULL;
  return temp;
}
inline void CreatePreparedStatementResp::set_allocated_error(::exec::shared::DrillPBError* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
}

// -------------------------------------------------------------------

// GetServerMetaReq

// -------------------------------------------------------------------

// ConvertSupport

// required .common.MinorType from = 1;
inline bool ConvertSupport::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConvertSupport::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConvertSupport::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConvertSupport::clear_from() {
  from_ = 0;
  clear_has_from();
}
inline ::common::MinorType ConvertSupport::from() const {
  return static_cast< ::common::MinorType >(from_);
}
inline void ConvertSupport::set_from(::common::MinorType value) {
  assert(::common::MinorType_IsValid(value));
  set_has_from();
  from_ = value;
}

// required .common.MinorType to = 2;
inline bool ConvertSupport::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConvertSupport::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConvertSupport::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConvertSupport::clear_to() {
  to_ = 0;
  clear_has_to();
}
inline ::common::MinorType ConvertSupport::to() const {
  return static_cast< ::common::MinorType >(to_);
}
inline void ConvertSupport::set_to(::common::MinorType value) {
  assert(::common::MinorType_IsValid(value));
  set_has_to();
  to_ = value;
}

// -------------------------------------------------------------------

// GetServerMetaResp

// optional .exec.user.RequestStatus status = 1;
inline bool GetServerMetaResp::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetServerMetaResp::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetServerMetaResp::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetServerMetaResp::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::exec::user::RequestStatus GetServerMetaResp::status() const {
  return static_cast< ::exec::user::RequestStatus >(status_);
}
inline void GetServerMetaResp::set_status(::exec::user::RequestStatus value) {
  assert(::exec::user::RequestStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .exec.user.ServerMeta server_meta = 2;
inline bool GetServerMetaResp::has_server_meta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetServerMetaResp::set_has_server_meta() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetServerMetaResp::clear_has_server_meta() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetServerMetaResp::clear_server_meta() {
  if (server_meta_ != NULL) server_meta_->::exec::user::ServerMeta::Clear();
  clear_has_server_meta();
}
inline const ::exec::user::ServerMeta& GetServerMetaResp::server_meta() const {
  return server_meta_ != NULL ? *server_meta_ : *default_instance_->server_meta_;
}
inline ::exec::user::ServerMeta* GetServerMetaResp::mutable_server_meta() {
  set_has_server_meta();
  if (server_meta_ == NULL) server_meta_ = new ::exec::user::ServerMeta;
  return server_meta_;
}
inline ::exec::user::ServerMeta* GetServerMetaResp::release_server_meta() {
  clear_has_server_meta();
  ::exec::user::ServerMeta* temp = server_meta_;
  server_meta_ = NULL;
  return temp;
}
inline void GetServerMetaResp::set_allocated_server_meta(::exec::user::ServerMeta* server_meta) {
  delete server_meta_;
  server_meta_ = server_meta;
  if (server_meta) {
    set_has_server_meta();
  } else {
    clear_has_server_meta();
  }
}

// optional .exec.shared.DrillPBError error = 3;
inline bool GetServerMetaResp::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetServerMetaResp::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetServerMetaResp::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetServerMetaResp::clear_error() {
  if (error_ != NULL) error_->::exec::shared::DrillPBError::Clear();
  clear_has_error();
}
inline const ::exec::shared::DrillPBError& GetServerMetaResp::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::exec::shared::DrillPBError* GetServerMetaResp::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::exec::shared::DrillPBError;
  return error_;
}
inline ::exec::shared::DrillPBError* GetServerMetaResp::release_error() {
  clear_has_error();
  ::exec::shared::DrillPBError* temp = error_;
  error_ = NULL;
  return temp;
}
inline void GetServerMetaResp::set_allocated_error(::exec::shared::DrillPBError* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
}

// -------------------------------------------------------------------

// ServerMeta

// optional bool all_tables_selectable = 1;
inline bool ServerMeta::has_all_tables_selectable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerMeta::set_has_all_tables_selectable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerMeta::clear_has_all_tables_selectable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerMeta::clear_all_tables_selectable() {
  all_tables_selectable_ = false;
  clear_has_all_tables_selectable();
}
inline bool ServerMeta::all_tables_selectable() const {
  return all_tables_selectable_;
}
inline void ServerMeta::set_all_tables_selectable(bool value) {
  set_has_all_tables_selectable();
  all_tables_selectable_ = value;
}

// optional bool blob_included_in_max_row_size = 2;
inline bool ServerMeta::has_blob_included_in_max_row_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerMeta::set_has_blob_included_in_max_row_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerMeta::clear_has_blob_included_in_max_row_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerMeta::clear_blob_included_in_max_row_size() {
  blob_included_in_max_row_size_ = false;
  clear_has_blob_included_in_max_row_size();
}
inline bool ServerMeta::blob_included_in_max_row_size() const {
  return blob_included_in_max_row_size_;
}
inline void ServerMeta::set_blob_included_in_max_row_size(bool value) {
  set_has_blob_included_in_max_row_size();
  blob_included_in_max_row_size_ = value;
}

// optional bool catalog_at_start = 3;
inline bool ServerMeta::has_catalog_at_start() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerMeta::set_has_catalog_at_start() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerMeta::clear_has_catalog_at_start() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerMeta::clear_catalog_at_start() {
  catalog_at_start_ = false;
  clear_has_catalog_at_start();
}
inline bool ServerMeta::catalog_at_start() const {
  return catalog_at_start_;
}
inline void ServerMeta::set_catalog_at_start(bool value) {
  set_has_catalog_at_start();
  catalog_at_start_ = value;
}

// optional string catalog_separator = 4;
inline bool ServerMeta::has_catalog_separator() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerMeta::set_has_catalog_separator() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerMeta::clear_has_catalog_separator() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerMeta::clear_catalog_separator() {
  if (catalog_separator_ != &::google::protobuf::internal::kEmptyString) {
    catalog_separator_->clear();
  }
  clear_has_catalog_separator();
}
inline const ::std::string& ServerMeta::catalog_separator() const {
  return *catalog_separator_;
}
inline void ServerMeta::set_catalog_separator(const ::std::string& value) {
  set_has_catalog_separator();
  if (catalog_separator_ == &::google::protobuf::internal::kEmptyString) {
    catalog_separator_ = new ::std::string;
  }
  catalog_separator_->assign(value);
}
inline void ServerMeta::set_catalog_separator(const char* value) {
  set_has_catalog_separator();
  if (catalog_separator_ == &::google::protobuf::internal::kEmptyString) {
    catalog_separator_ = new ::std::string;
  }
  catalog_separator_->assign(value);
}
inline void ServerMeta::set_catalog_separator(const char* value, size_t size) {
  set_has_catalog_separator();
  if (catalog_separator_ == &::google::protobuf::internal::kEmptyString) {
    catalog_separator_ = new ::std::string;
  }
  catalog_separator_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerMeta::mutable_catalog_separator() {
  set_has_catalog_separator();
  if (catalog_separator_ == &::google::protobuf::internal::kEmptyString) {
    catalog_separator_ = new ::std::string;
  }
  return catalog_separator_;
}
inline ::std::string* ServerMeta::release_catalog_separator() {
  clear_has_catalog_separator();
  if (catalog_separator_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = catalog_separator_;
    catalog_separator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerMeta::set_allocated_catalog_separator(::std::string* catalog_separator) {
  if (catalog_separator_ != &::google::protobuf::internal::kEmptyString) {
    delete catalog_separator_;
  }
  if (catalog_separator) {
    set_has_catalog_separator();
    catalog_separator_ = catalog_separator;
  } else {
    clear_has_catalog_separator();
    catalog_separator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string catalog_term = 5;
inline bool ServerMeta::has_catalog_term() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerMeta::set_has_catalog_term() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerMeta::clear_has_catalog_term() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerMeta::clear_catalog_term() {
  if (catalog_term_ != &::google::protobuf::internal::kEmptyString) {
    catalog_term_->clear();
  }
  clear_has_catalog_term();
}
inline const ::std::string& ServerMeta::catalog_term() const {
  return *catalog_term_;
}
inline void ServerMeta::set_catalog_term(const ::std::string& value) {
  set_has_catalog_term();
  if (catalog_term_ == &::google::protobuf::internal::kEmptyString) {
    catalog_term_ = new ::std::string;
  }
  catalog_term_->assign(value);
}
inline void ServerMeta::set_catalog_term(const char* value) {
  set_has_catalog_term();
  if (catalog_term_ == &::google::protobuf::internal::kEmptyString) {
    catalog_term_ = new ::std::string;
  }
  catalog_term_->assign(value);
}
inline void ServerMeta::set_catalog_term(const char* value, size_t size) {
  set_has_catalog_term();
  if (catalog_term_ == &::google::protobuf::internal::kEmptyString) {
    catalog_term_ = new ::std::string;
  }
  catalog_term_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerMeta::mutable_catalog_term() {
  set_has_catalog_term();
  if (catalog_term_ == &::google::protobuf::internal::kEmptyString) {
    catalog_term_ = new ::std::string;
  }
  return catalog_term_;
}
inline ::std::string* ServerMeta::release_catalog_term() {
  clear_has_catalog_term();
  if (catalog_term_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = catalog_term_;
    catalog_term_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerMeta::set_allocated_catalog_term(::std::string* catalog_term) {
  if (catalog_term_ != &::google::protobuf::internal::kEmptyString) {
    delete catalog_term_;
  }
  if (catalog_term) {
    set_has_catalog_term();
    catalog_term_ = catalog_term;
  } else {
    clear_has_catalog_term();
    catalog_term_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .exec.user.CollateSupport collate_support = 6;
inline int ServerMeta::collate_support_size() const {
  return collate_support_.size();
}
inline void ServerMeta::clear_collate_support() {
  collate_support_.Clear();
}
inline ::exec::user::CollateSupport ServerMeta::collate_support(int index) const {
  return static_cast< ::exec::user::CollateSupport >(collate_support_.Get(index));
}
inline void ServerMeta::set_collate_support(int index, ::exec::user::CollateSupport value) {
  assert(::exec::user::CollateSupport_IsValid(value));
  collate_support_.Set(index, value);
}
inline void ServerMeta::add_collate_support(::exec::user::CollateSupport value) {
  assert(::exec::user::CollateSupport_IsValid(value));
  collate_support_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
ServerMeta::collate_support() const {
  return collate_support_;
}
inline ::google::protobuf::RepeatedField<int>*
ServerMeta::mutable_collate_support() {
  return &collate_support_;
}

// optional bool column_aliasing_supported = 7;
inline bool ServerMeta::has_column_aliasing_supported() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ServerMeta::set_has_column_aliasing_supported() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ServerMeta::clear_has_column_aliasing_supported() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ServerMeta::clear_column_aliasing_supported() {
  column_aliasing_supported_ = false;
  clear_has_column_aliasing_supported();
}
inline bool ServerMeta::column_aliasing_supported() const {
  return column_aliasing_supported_;
}
inline void ServerMeta::set_column_aliasing_supported(bool value) {
  set_has_column_aliasing_supported();
  column_aliasing_supported_ = value;
}

// repeated .exec.user.ConvertSupport convert_support = 8;
inline int ServerMeta::convert_support_size() const {
  return convert_support_.size();
}
inline void ServerMeta::clear_convert_support() {
  convert_support_.Clear();
}
inline const ::exec::user::ConvertSupport& ServerMeta::convert_support(int index) const {
  return convert_support_.Get(index);
}
inline ::exec::user::ConvertSupport* ServerMeta::mutable_convert_support(int index) {
  return convert_support_.Mutable(index);
}
inline ::exec::user::ConvertSupport* ServerMeta::add_convert_support() {
  return convert_support_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::user::ConvertSupport >&
ServerMeta::convert_support() const {
  return convert_support_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::user::ConvertSupport >*
ServerMeta::mutable_convert_support() {
  return &convert_support_;
}

// optional .exec.user.CorrelationNamesSupport correlation_names_support = 9;
inline bool ServerMeta::has_correlation_names_support() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ServerMeta::set_has_correlation_names_support() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ServerMeta::clear_has_correlation_names_support() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ServerMeta::clear_correlation_names_support() {
  correlation_names_support_ = 1;
  clear_has_correlation_names_support();
}
inline ::exec::user::CorrelationNamesSupport ServerMeta::correlation_names_support() const {
  return static_cast< ::exec::user::CorrelationNamesSupport >(correlation_names_support_);
}
inline void ServerMeta::set_correlation_names_support(::exec::user::CorrelationNamesSupport value) {
  assert(::exec::user::CorrelationNamesSupport_IsValid(value));
  set_has_correlation_names_support();
  correlation_names_support_ = value;
}

// repeated string date_time_functions = 10;
inline int ServerMeta::date_time_functions_size() const {
  return date_time_functions_.size();
}
inline void ServerMeta::clear_date_time_functions() {
  date_time_functions_.Clear();
}
inline const ::std::string& ServerMeta::date_time_functions(int index) const {
  return date_time_functions_.Get(index);
}
inline ::std::string* ServerMeta::mutable_date_time_functions(int index) {
  return date_time_functions_.Mutable(index);
}
inline void ServerMeta::set_date_time_functions(int index, const ::std::string& value) {
  date_time_functions_.Mutable(index)->assign(value);
}
inline void ServerMeta::set_date_time_functions(int index, const char* value) {
  date_time_functions_.Mutable(index)->assign(value);
}
inline void ServerMeta::set_date_time_functions(int index, const char* value, size_t size) {
  date_time_functions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerMeta::add_date_time_functions() {
  return date_time_functions_.Add();
}
inline void ServerMeta::add_date_time_functions(const ::std::string& value) {
  date_time_functions_.Add()->assign(value);
}
inline void ServerMeta::add_date_time_functions(const char* value) {
  date_time_functions_.Add()->assign(value);
}
inline void ServerMeta::add_date_time_functions(const char* value, size_t size) {
  date_time_functions_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ServerMeta::date_time_functions() const {
  return date_time_functions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ServerMeta::mutable_date_time_functions() {
  return &date_time_functions_;
}

// repeated .exec.user.DateTimeLiteralsSupport date_time_literals_support = 11;
inline int ServerMeta::date_time_literals_support_size() const {
  return date_time_literals_support_.size();
}
inline void ServerMeta::clear_date_time_literals_support() {
  date_time_literals_support_.Clear();
}
inline ::exec::user::DateTimeLiteralsSupport ServerMeta::date_time_literals_support(int index) const {
  return static_cast< ::exec::user::DateTimeLiteralsSupport >(date_time_literals_support_.Get(index));
}
inline void ServerMeta::set_date_time_literals_support(int index, ::exec::user::DateTimeLiteralsSupport value) {
  assert(::exec::user::DateTimeLiteralsSupport_IsValid(value));
  date_time_literals_support_.Set(index, value);
}
inline void ServerMeta::add_date_time_literals_support(::exec::user::DateTimeLiteralsSupport value) {
  assert(::exec::user::DateTimeLiteralsSupport_IsValid(value));
  date_time_literals_support_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
ServerMeta::date_time_literals_support() const {
  return date_time_literals_support_;
}
inline ::google::protobuf::RepeatedField<int>*
ServerMeta::mutable_date_time_literals_support() {
  return &date_time_literals_support_;
}

// optional .exec.user.GroupBySupport group_by_support = 12;
inline bool ServerMeta::has_group_by_support() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ServerMeta::set_has_group_by_support() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ServerMeta::clear_has_group_by_support() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ServerMeta::clear_group_by_support() {
  group_by_support_ = 1;
  clear_has_group_by_support();
}
inline ::exec::user::GroupBySupport ServerMeta::group_by_support() const {
  return static_cast< ::exec::user::GroupBySupport >(group_by_support_);
}
inline void ServerMeta::set_group_by_support(::exec::user::GroupBySupport value) {
  assert(::exec::user::GroupBySupport_IsValid(value));
  set_has_group_by_support();
  group_by_support_ = value;
}

// optional .exec.user.IdentifierCasing identifier_casing = 13;
inline bool ServerMeta::has_identifier_casing() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ServerMeta::set_has_identifier_casing() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ServerMeta::clear_has_identifier_casing() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ServerMeta::clear_identifier_casing() {
  identifier_casing_ = 0;
  clear_has_identifier_casing();
}
inline ::exec::user::IdentifierCasing ServerMeta::identifier_casing() const {
  return static_cast< ::exec::user::IdentifierCasing >(identifier_casing_);
}
inline void ServerMeta::set_identifier_casing(::exec::user::IdentifierCasing value) {
  assert(::exec::user::IdentifierCasing_IsValid(value));
  set_has_identifier_casing();
  identifier_casing_ = value;
}

// optional string identifier_quote_string = 14;
inline bool ServerMeta::has_identifier_quote_string() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ServerMeta::set_has_identifier_quote_string() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ServerMeta::clear_has_identifier_quote_string() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ServerMeta::clear_identifier_quote_string() {
  if (identifier_quote_string_ != &::google::protobuf::internal::kEmptyString) {
    identifier_quote_string_->clear();
  }
  clear_has_identifier_quote_string();
}
inline const ::std::string& ServerMeta::identifier_quote_string() const {
  return *identifier_quote_string_;
}
inline void ServerMeta::set_identifier_quote_string(const ::std::string& value) {
  set_has_identifier_quote_string();
  if (identifier_quote_string_ == &::google::protobuf::internal::kEmptyString) {
    identifier_quote_string_ = new ::std::string;
  }
  identifier_quote_string_->assign(value);
}
inline void ServerMeta::set_identifier_quote_string(const char* value) {
  set_has_identifier_quote_string();
  if (identifier_quote_string_ == &::google::protobuf::internal::kEmptyString) {
    identifier_quote_string_ = new ::std::string;
  }
  identifier_quote_string_->assign(value);
}
inline void ServerMeta::set_identifier_quote_string(const char* value, size_t size) {
  set_has_identifier_quote_string();
  if (identifier_quote_string_ == &::google::protobuf::internal::kEmptyString) {
    identifier_quote_string_ = new ::std::string;
  }
  identifier_quote_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerMeta::mutable_identifier_quote_string() {
  set_has_identifier_quote_string();
  if (identifier_quote_string_ == &::google::protobuf::internal::kEmptyString) {
    identifier_quote_string_ = new ::std::string;
  }
  return identifier_quote_string_;
}
inline ::std::string* ServerMeta::release_identifier_quote_string() {
  clear_has_identifier_quote_string();
  if (identifier_quote_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identifier_quote_string_;
    identifier_quote_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerMeta::set_allocated_identifier_quote_string(::std::string* identifier_quote_string) {
  if (identifier_quote_string_ != &::google::protobuf::internal::kEmptyString) {
    delete identifier_quote_string_;
  }
  if (identifier_quote_string) {
    set_has_identifier_quote_string();
    identifier_quote_string_ = identifier_quote_string;
  } else {
    clear_has_identifier_quote_string();
    identifier_quote_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool like_escape_clause_supported = 15;
inline bool ServerMeta::has_like_escape_clause_supported() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ServerMeta::set_has_like_escape_clause_supported() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ServerMeta::clear_has_like_escape_clause_supported() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ServerMeta::clear_like_escape_clause_supported() {
  like_escape_clause_supported_ = false;
  clear_has_like_escape_clause_supported();
}
inline bool ServerMeta::like_escape_clause_supported() const {
  return like_escape_clause_supported_;
}
inline void ServerMeta::set_like_escape_clause_supported(bool value) {
  set_has_like_escape_clause_supported();
  like_escape_clause_supported_ = value;
}

// optional uint32 max_binary_literal_length = 16;
inline bool ServerMeta::has_max_binary_literal_length() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ServerMeta::set_has_max_binary_literal_length() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ServerMeta::clear_has_max_binary_literal_length() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ServerMeta::clear_max_binary_literal_length() {
  max_binary_literal_length_ = 0u;
  clear_has_max_binary_literal_length();
}
inline ::google::protobuf::uint32 ServerMeta::max_binary_literal_length() const {
  return max_binary_literal_length_;
}
inline void ServerMeta::set_max_binary_literal_length(::google::protobuf::uint32 value) {
  set_has_max_binary_literal_length();
  max_binary_literal_length_ = value;
}

// optional uint32 max_catalog_name_length = 17;
inline bool ServerMeta::has_max_catalog_name_length() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ServerMeta::set_has_max_catalog_name_length() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ServerMeta::clear_has_max_catalog_name_length() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ServerMeta::clear_max_catalog_name_length() {
  max_catalog_name_length_ = 0u;
  clear_has_max_catalog_name_length();
}
inline ::google::protobuf::uint32 ServerMeta::max_catalog_name_length() const {
  return max_catalog_name_length_;
}
inline void ServerMeta::set_max_catalog_name_length(::google::protobuf::uint32 value) {
  set_has_max_catalog_name_length();
  max_catalog_name_length_ = value;
}

// optional uint32 max_char_literal_length = 18;
inline bool ServerMeta::has_max_char_literal_length() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ServerMeta::set_has_max_char_literal_length() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ServerMeta::clear_has_max_char_literal_length() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ServerMeta::clear_max_char_literal_length() {
  max_char_literal_length_ = 0u;
  clear_has_max_char_literal_length();
}
inline ::google::protobuf::uint32 ServerMeta::max_char_literal_length() const {
  return max_char_literal_length_;
}
inline void ServerMeta::set_max_char_literal_length(::google::protobuf::uint32 value) {
  set_has_max_char_literal_length();
  max_char_literal_length_ = value;
}

// optional uint32 max_column_name_length = 19;
inline bool ServerMeta::has_max_column_name_length() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ServerMeta::set_has_max_column_name_length() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ServerMeta::clear_has_max_column_name_length() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ServerMeta::clear_max_column_name_length() {
  max_column_name_length_ = 0u;
  clear_has_max_column_name_length();
}
inline ::google::protobuf::uint32 ServerMeta::max_column_name_length() const {
  return max_column_name_length_;
}
inline void ServerMeta::set_max_column_name_length(::google::protobuf::uint32 value) {
  set_has_max_column_name_length();
  max_column_name_length_ = value;
}

// optional uint32 max_columns_in_group_by = 20;
inline bool ServerMeta::has_max_columns_in_group_by() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ServerMeta::set_has_max_columns_in_group_by() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ServerMeta::clear_has_max_columns_in_group_by() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ServerMeta::clear_max_columns_in_group_by() {
  max_columns_in_group_by_ = 0u;
  clear_has_max_columns_in_group_by();
}
inline ::google::protobuf::uint32 ServerMeta::max_columns_in_group_by() const {
  return max_columns_in_group_by_;
}
inline void ServerMeta::set_max_columns_in_group_by(::google::protobuf::uint32 value) {
  set_has_max_columns_in_group_by();
  max_columns_in_group_by_ = value;
}

// optional uint32 max_columns_in_order_by = 21;
inline bool ServerMeta::has_max_columns_in_order_by() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ServerMeta::set_has_max_columns_in_order_by() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ServerMeta::clear_has_max_columns_in_order_by() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ServerMeta::clear_max_columns_in_order_by() {
  max_columns_in_order_by_ = 0u;
  clear_has_max_columns_in_order_by();
}
inline ::google::protobuf::uint32 ServerMeta::max_columns_in_order_by() const {
  return max_columns_in_order_by_;
}
inline void ServerMeta::set_max_columns_in_order_by(::google::protobuf::uint32 value) {
  set_has_max_columns_in_order_by();
  max_columns_in_order_by_ = value;
}

// optional uint32 max_columns_in_select = 22;
inline bool ServerMeta::has_max_columns_in_select() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ServerMeta::set_has_max_columns_in_select() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ServerMeta::clear_has_max_columns_in_select() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ServerMeta::clear_max_columns_in_select() {
  max_columns_in_select_ = 0u;
  clear_has_max_columns_in_select();
}
inline ::google::protobuf::uint32 ServerMeta::max_columns_in_select() const {
  return max_columns_in_select_;
}
inline void ServerMeta::set_max_columns_in_select(::google::protobuf::uint32 value) {
  set_has_max_columns_in_select();
  max_columns_in_select_ = value;
}

// optional uint32 max_cursor_name_length = 23;
inline bool ServerMeta::has_max_cursor_name_length() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ServerMeta::set_has_max_cursor_name_length() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ServerMeta::clear_has_max_cursor_name_length() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ServerMeta::clear_max_cursor_name_length() {
  max_cursor_name_length_ = 0u;
  clear_has_max_cursor_name_length();
}
inline ::google::protobuf::uint32 ServerMeta::max_cursor_name_length() const {
  return max_cursor_name_length_;
}
inline void ServerMeta::set_max_cursor_name_length(::google::protobuf::uint32 value) {
  set_has_max_cursor_name_length();
  max_cursor_name_length_ = value;
}

// optional uint32 max_logical_lob_size = 24;
inline bool ServerMeta::has_max_logical_lob_size() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ServerMeta::set_has_max_logical_lob_size() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ServerMeta::clear_has_max_logical_lob_size() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ServerMeta::clear_max_logical_lob_size() {
  max_logical_lob_size_ = 0u;
  clear_has_max_logical_lob_size();
}
inline ::google::protobuf::uint32 ServerMeta::max_logical_lob_size() const {
  return max_logical_lob_size_;
}
inline void ServerMeta::set_max_logical_lob_size(::google::protobuf::uint32 value) {
  set_has_max_logical_lob_size();
  max_logical_lob_size_ = value;
}

// optional uint32 max_row_size = 25;
inline bool ServerMeta::has_max_row_size() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ServerMeta::set_has_max_row_size() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ServerMeta::clear_has_max_row_size() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ServerMeta::clear_max_row_size() {
  max_row_size_ = 0u;
  clear_has_max_row_size();
}
inline ::google::protobuf::uint32 ServerMeta::max_row_size() const {
  return max_row_size_;
}
inline void ServerMeta::set_max_row_size(::google::protobuf::uint32 value) {
  set_has_max_row_size();
  max_row_size_ = value;
}

// optional uint32 max_schema_name_length = 26;
inline bool ServerMeta::has_max_schema_name_length() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ServerMeta::set_has_max_schema_name_length() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ServerMeta::clear_has_max_schema_name_length() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ServerMeta::clear_max_schema_name_length() {
  max_schema_name_length_ = 0u;
  clear_has_max_schema_name_length();
}
inline ::google::protobuf::uint32 ServerMeta::max_schema_name_length() const {
  return max_schema_name_length_;
}
inline void ServerMeta::set_max_schema_name_length(::google::protobuf::uint32 value) {
  set_has_max_schema_name_length();
  max_schema_name_length_ = value;
}

// optional uint32 max_statement_length = 27;
inline bool ServerMeta::has_max_statement_length() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ServerMeta::set_has_max_statement_length() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ServerMeta::clear_has_max_statement_length() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ServerMeta::clear_max_statement_length() {
  max_statement_length_ = 0u;
  clear_has_max_statement_length();
}
inline ::google::protobuf::uint32 ServerMeta::max_statement_length() const {
  return max_statement_length_;
}
inline void ServerMeta::set_max_statement_length(::google::protobuf::uint32 value) {
  set_has_max_statement_length();
  max_statement_length_ = value;
}

// optional uint32 max_statements = 28;
inline bool ServerMeta::has_max_statements() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ServerMeta::set_has_max_statements() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ServerMeta::clear_has_max_statements() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ServerMeta::clear_max_statements() {
  max_statements_ = 0u;
  clear_has_max_statements();
}
inline ::google::protobuf::uint32 ServerMeta::max_statements() const {
  return max_statements_;
}
inline void ServerMeta::set_max_statements(::google::protobuf::uint32 value) {
  set_has_max_statements();
  max_statements_ = value;
}

// optional uint32 max_table_name_length = 29;
inline bool ServerMeta::has_max_table_name_length() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ServerMeta::set_has_max_table_name_length() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ServerMeta::clear_has_max_table_name_length() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ServerMeta::clear_max_table_name_length() {
  max_table_name_length_ = 0u;
  clear_has_max_table_name_length();
}
inline ::google::protobuf::uint32 ServerMeta::max_table_name_length() const {
  return max_table_name_length_;
}
inline void ServerMeta::set_max_table_name_length(::google::protobuf::uint32 value) {
  set_has_max_table_name_length();
  max_table_name_length_ = value;
}

// optional uint32 max_tables_in_select = 30;
inline bool ServerMeta::has_max_tables_in_select() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void ServerMeta::set_has_max_tables_in_select() {
  _has_bits_[0] |= 0x20000000u;
}
inline void ServerMeta::clear_has_max_tables_in_select() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void ServerMeta::clear_max_tables_in_select() {
  max_tables_in_select_ = 0u;
  clear_has_max_tables_in_select();
}
inline ::google::protobuf::uint32 ServerMeta::max_tables_in_select() const {
  return max_tables_in_select_;
}
inline void ServerMeta::set_max_tables_in_select(::google::protobuf::uint32 value) {
  set_has_max_tables_in_select();
  max_tables_in_select_ = value;
}

// optional uint32 max_user_name_length = 31;
inline bool ServerMeta::has_max_user_name_length() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void ServerMeta::set_has_max_user_name_length() {
  _has_bits_[0] |= 0x40000000u;
}
inline void ServerMeta::clear_has_max_user_name_length() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void ServerMeta::clear_max_user_name_length() {
  max_user_name_length_ = 0u;
  clear_has_max_user_name_length();
}
inline ::google::protobuf::uint32 ServerMeta::max_user_name_length() const {
  return max_user_name_length_;
}
inline void ServerMeta::set_max_user_name_length(::google::protobuf::uint32 value) {
  set_has_max_user_name_length();
  max_user_name_length_ = value;
}

// optional .exec.user.NullCollation null_collation = 32;
inline bool ServerMeta::has_null_collation() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void ServerMeta::set_has_null_collation() {
  _has_bits_[0] |= 0x80000000u;
}
inline void ServerMeta::clear_has_null_collation() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void ServerMeta::clear_null_collation() {
  null_collation_ = 0;
  clear_has_null_collation();
}
inline ::exec::user::NullCollation ServerMeta::null_collation() const {
  return static_cast< ::exec::user::NullCollation >(null_collation_);
}
inline void ServerMeta::set_null_collation(::exec::user::NullCollation value) {
  assert(::exec::user::NullCollation_IsValid(value));
  set_has_null_collation();
  null_collation_ = value;
}

// optional bool null_plus_non_null_equals_null = 33;
inline bool ServerMeta::has_null_plus_non_null_equals_null() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void ServerMeta::set_has_null_plus_non_null_equals_null() {
  _has_bits_[1] |= 0x00000001u;
}
inline void ServerMeta::clear_has_null_plus_non_null_equals_null() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void ServerMeta::clear_null_plus_non_null_equals_null() {
  null_plus_non_null_equals_null_ = false;
  clear_has_null_plus_non_null_equals_null();
}
inline bool ServerMeta::null_plus_non_null_equals_null() const {
  return null_plus_non_null_equals_null_;
}
inline void ServerMeta::set_null_plus_non_null_equals_null(bool value) {
  set_has_null_plus_non_null_equals_null();
  null_plus_non_null_equals_null_ = value;
}

// repeated string numeric_functions = 34;
inline int ServerMeta::numeric_functions_size() const {
  return numeric_functions_.size();
}
inline void ServerMeta::clear_numeric_functions() {
  numeric_functions_.Clear();
}
inline const ::std::string& ServerMeta::numeric_functions(int index) const {
  return numeric_functions_.Get(index);
}
inline ::std::string* ServerMeta::mutable_numeric_functions(int index) {
  return numeric_functions_.Mutable(index);
}
inline void ServerMeta::set_numeric_functions(int index, const ::std::string& value) {
  numeric_functions_.Mutable(index)->assign(value);
}
inline void ServerMeta::set_numeric_functions(int index, const char* value) {
  numeric_functions_.Mutable(index)->assign(value);
}
inline void ServerMeta::set_numeric_functions(int index, const char* value, size_t size) {
  numeric_functions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerMeta::add_numeric_functions() {
  return numeric_functions_.Add();
}
inline void ServerMeta::add_numeric_functions(const ::std::string& value) {
  numeric_functions_.Add()->assign(value);
}
inline void ServerMeta::add_numeric_functions(const char* value) {
  numeric_functions_.Add()->assign(value);
}
inline void ServerMeta::add_numeric_functions(const char* value, size_t size) {
  numeric_functions_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ServerMeta::numeric_functions() const {
  return numeric_functions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ServerMeta::mutable_numeric_functions() {
  return &numeric_functions_;
}

// repeated .exec.user.OrderBySupport order_by_support = 35;
inline int ServerMeta::order_by_support_size() const {
  return order_by_support_.size();
}
inline void ServerMeta::clear_order_by_support() {
  order_by_support_.Clear();
}
inline ::exec::user::OrderBySupport ServerMeta::order_by_support(int index) const {
  return static_cast< ::exec::user::OrderBySupport >(order_by_support_.Get(index));
}
inline void ServerMeta::set_order_by_support(int index, ::exec::user::OrderBySupport value) {
  assert(::exec::user::OrderBySupport_IsValid(value));
  order_by_support_.Set(index, value);
}
inline void ServerMeta::add_order_by_support(::exec::user::OrderBySupport value) {
  assert(::exec::user::OrderBySupport_IsValid(value));
  order_by_support_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
ServerMeta::order_by_support() const {
  return order_by_support_;
}
inline ::google::protobuf::RepeatedField<int>*
ServerMeta::mutable_order_by_support() {
  return &order_by_support_;
}

// repeated .exec.user.OuterJoinSupport outer_join_support = 36;
inline int ServerMeta::outer_join_support_size() const {
  return outer_join_support_.size();
}
inline void ServerMeta::clear_outer_join_support() {
  outer_join_support_.Clear();
}
inline ::exec::user::OuterJoinSupport ServerMeta::outer_join_support(int index) const {
  return static_cast< ::exec::user::OuterJoinSupport >(outer_join_support_.Get(index));
}
inline void ServerMeta::set_outer_join_support(int index, ::exec::user::OuterJoinSupport value) {
  assert(::exec::user::OuterJoinSupport_IsValid(value));
  outer_join_support_.Set(index, value);
}
inline void ServerMeta::add_outer_join_support(::exec::user::OuterJoinSupport value) {
  assert(::exec::user::OuterJoinSupport_IsValid(value));
  outer_join_support_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
ServerMeta::outer_join_support() const {
  return outer_join_support_;
}
inline ::google::protobuf::RepeatedField<int>*
ServerMeta::mutable_outer_join_support() {
  return &outer_join_support_;
}

// optional .exec.user.IdentifierCasing quoted_identifier_casing = 37;
inline bool ServerMeta::has_quoted_identifier_casing() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void ServerMeta::set_has_quoted_identifier_casing() {
  _has_bits_[1] |= 0x00000010u;
}
inline void ServerMeta::clear_has_quoted_identifier_casing() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void ServerMeta::clear_quoted_identifier_casing() {
  quoted_identifier_casing_ = 0;
  clear_has_quoted_identifier_casing();
}
inline ::exec::user::IdentifierCasing ServerMeta::quoted_identifier_casing() const {
  return static_cast< ::exec::user::IdentifierCasing >(quoted_identifier_casing_);
}
inline void ServerMeta::set_quoted_identifier_casing(::exec::user::IdentifierCasing value) {
  assert(::exec::user::IdentifierCasing_IsValid(value));
  set_has_quoted_identifier_casing();
  quoted_identifier_casing_ = value;
}

// optional bool read_only = 38;
inline bool ServerMeta::has_read_only() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void ServerMeta::set_has_read_only() {
  _has_bits_[1] |= 0x00000020u;
}
inline void ServerMeta::clear_has_read_only() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void ServerMeta::clear_read_only() {
  read_only_ = false;
  clear_has_read_only();
}
inline bool ServerMeta::read_only() const {
  return read_only_;
}
inline void ServerMeta::set_read_only(bool value) {
  set_has_read_only();
  read_only_ = value;
}

// optional string schema_term = 39;
inline bool ServerMeta::has_schema_term() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void ServerMeta::set_has_schema_term() {
  _has_bits_[1] |= 0x00000040u;
}
inline void ServerMeta::clear_has_schema_term() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void ServerMeta::clear_schema_term() {
  if (schema_term_ != &::google::protobuf::internal::kEmptyString) {
    schema_term_->clear();
  }
  clear_has_schema_term();
}
inline const ::std::string& ServerMeta::schema_term() const {
  return *schema_term_;
}
inline void ServerMeta::set_schema_term(const ::std::string& value) {
  set_has_schema_term();
  if (schema_term_ == &::google::protobuf::internal::kEmptyString) {
    schema_term_ = new ::std::string;
  }
  schema_term_->assign(value);
}
inline void ServerMeta::set_schema_term(const char* value) {
  set_has_schema_term();
  if (schema_term_ == &::google::protobuf::internal::kEmptyString) {
    schema_term_ = new ::std::string;
  }
  schema_term_->assign(value);
}
inline void ServerMeta::set_schema_term(const char* value, size_t size) {
  set_has_schema_term();
  if (schema_term_ == &::google::protobuf::internal::kEmptyString) {
    schema_term_ = new ::std::string;
  }
  schema_term_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerMeta::mutable_schema_term() {
  set_has_schema_term();
  if (schema_term_ == &::google::protobuf::internal::kEmptyString) {
    schema_term_ = new ::std::string;
  }
  return schema_term_;
}
inline ::std::string* ServerMeta::release_schema_term() {
  clear_has_schema_term();
  if (schema_term_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = schema_term_;
    schema_term_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerMeta::set_allocated_schema_term(::std::string* schema_term) {
  if (schema_term_ != &::google::protobuf::internal::kEmptyString) {
    delete schema_term_;
  }
  if (schema_term) {
    set_has_schema_term();
    schema_term_ = schema_term;
  } else {
    clear_has_schema_term();
    schema_term_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string search_escape_string = 40;
inline bool ServerMeta::has_search_escape_string() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void ServerMeta::set_has_search_escape_string() {
  _has_bits_[1] |= 0x00000080u;
}
inline void ServerMeta::clear_has_search_escape_string() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void ServerMeta::clear_search_escape_string() {
  if (search_escape_string_ != &::google::protobuf::internal::kEmptyString) {
    search_escape_string_->clear();
  }
  clear_has_search_escape_string();
}
inline const ::std::string& ServerMeta::search_escape_string() const {
  return *search_escape_string_;
}
inline void ServerMeta::set_search_escape_string(const ::std::string& value) {
  set_has_search_escape_string();
  if (search_escape_string_ == &::google::protobuf::internal::kEmptyString) {
    search_escape_string_ = new ::std::string;
  }
  search_escape_string_->assign(value);
}
inline void ServerMeta::set_search_escape_string(const char* value) {
  set_has_search_escape_string();
  if (search_escape_string_ == &::google::protobuf::internal::kEmptyString) {
    search_escape_string_ = new ::std::string;
  }
  search_escape_string_->assign(value);
}
inline void ServerMeta::set_search_escape_string(const char* value, size_t size) {
  set_has_search_escape_string();
  if (search_escape_string_ == &::google::protobuf::internal::kEmptyString) {
    search_escape_string_ = new ::std::string;
  }
  search_escape_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerMeta::mutable_search_escape_string() {
  set_has_search_escape_string();
  if (search_escape_string_ == &::google::protobuf::internal::kEmptyString) {
    search_escape_string_ = new ::std::string;
  }
  return search_escape_string_;
}
inline ::std::string* ServerMeta::release_search_escape_string() {
  clear_has_search_escape_string();
  if (search_escape_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = search_escape_string_;
    search_escape_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerMeta::set_allocated_search_escape_string(::std::string* search_escape_string) {
  if (search_escape_string_ != &::google::protobuf::internal::kEmptyString) {
    delete search_escape_string_;
  }
  if (search_escape_string) {
    set_has_search_escape_string();
    search_escape_string_ = search_escape_string;
  } else {
    clear_has_search_escape_string();
    search_escape_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool select_for_update_supported = 41;
inline bool ServerMeta::has_select_for_update_supported() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void ServerMeta::set_has_select_for_update_supported() {
  _has_bits_[1] |= 0x00000100u;
}
inline void ServerMeta::clear_has_select_for_update_supported() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void ServerMeta::clear_select_for_update_supported() {
  select_for_update_supported_ = false;
  clear_has_select_for_update_supported();
}
inline bool ServerMeta::select_for_update_supported() const {
  return select_for_update_supported_;
}
inline void ServerMeta::set_select_for_update_supported(bool value) {
  set_has_select_for_update_supported();
  select_for_update_supported_ = value;
}

// optional string special_characters = 42;
inline bool ServerMeta::has_special_characters() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void ServerMeta::set_has_special_characters() {
  _has_bits_[1] |= 0x00000200u;
}
inline void ServerMeta::clear_has_special_characters() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void ServerMeta::clear_special_characters() {
  if (special_characters_ != &::google::protobuf::internal::kEmptyString) {
    special_characters_->clear();
  }
  clear_has_special_characters();
}
inline const ::std::string& ServerMeta::special_characters() const {
  return *special_characters_;
}
inline void ServerMeta::set_special_characters(const ::std::string& value) {
  set_has_special_characters();
  if (special_characters_ == &::google::protobuf::internal::kEmptyString) {
    special_characters_ = new ::std::string;
  }
  special_characters_->assign(value);
}
inline void ServerMeta::set_special_characters(const char* value) {
  set_has_special_characters();
  if (special_characters_ == &::google::protobuf::internal::kEmptyString) {
    special_characters_ = new ::std::string;
  }
  special_characters_->assign(value);
}
inline void ServerMeta::set_special_characters(const char* value, size_t size) {
  set_has_special_characters();
  if (special_characters_ == &::google::protobuf::internal::kEmptyString) {
    special_characters_ = new ::std::string;
  }
  special_characters_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerMeta::mutable_special_characters() {
  set_has_special_characters();
  if (special_characters_ == &::google::protobuf::internal::kEmptyString) {
    special_characters_ = new ::std::string;
  }
  return special_characters_;
}
inline ::std::string* ServerMeta::release_special_characters() {
  clear_has_special_characters();
  if (special_characters_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = special_characters_;
    special_characters_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerMeta::set_allocated_special_characters(::std::string* special_characters) {
  if (special_characters_ != &::google::protobuf::internal::kEmptyString) {
    delete special_characters_;
  }
  if (special_characters) {
    set_has_special_characters();
    special_characters_ = special_characters;
  } else {
    clear_has_special_characters();
    special_characters_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string sql_keywords = 43;
inline int ServerMeta::sql_keywords_size() const {
  return sql_keywords_.size();
}
inline void ServerMeta::clear_sql_keywords() {
  sql_keywords_.Clear();
}
inline const ::std::string& ServerMeta::sql_keywords(int index) const {
  return sql_keywords_.Get(index);
}
inline ::std::string* ServerMeta::mutable_sql_keywords(int index) {
  return sql_keywords_.Mutable(index);
}
inline void ServerMeta::set_sql_keywords(int index, const ::std::string& value) {
  sql_keywords_.Mutable(index)->assign(value);
}
inline void ServerMeta::set_sql_keywords(int index, const char* value) {
  sql_keywords_.Mutable(index)->assign(value);
}
inline void ServerMeta::set_sql_keywords(int index, const char* value, size_t size) {
  sql_keywords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerMeta::add_sql_keywords() {
  return sql_keywords_.Add();
}
inline void ServerMeta::add_sql_keywords(const ::std::string& value) {
  sql_keywords_.Add()->assign(value);
}
inline void ServerMeta::add_sql_keywords(const char* value) {
  sql_keywords_.Add()->assign(value);
}
inline void ServerMeta::add_sql_keywords(const char* value, size_t size) {
  sql_keywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ServerMeta::sql_keywords() const {
  return sql_keywords_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ServerMeta::mutable_sql_keywords() {
  return &sql_keywords_;
}

// repeated string string_functions = 44;
inline int ServerMeta::string_functions_size() const {
  return string_functions_.size();
}
inline void ServerMeta::clear_string_functions() {
  string_functions_.Clear();
}
inline const ::std::string& ServerMeta::string_functions(int index) const {
  return string_functions_.Get(index);
}
inline ::std::string* ServerMeta::mutable_string_functions(int index) {
  return string_functions_.Mutable(index);
}
inline void ServerMeta::set_string_functions(int index, const ::std::string& value) {
  string_functions_.Mutable(index)->assign(value);
}
inline void ServerMeta::set_string_functions(int index, const char* value) {
  string_functions_.Mutable(index)->assign(value);
}
inline void ServerMeta::set_string_functions(int index, const char* value, size_t size) {
  string_functions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerMeta::add_string_functions() {
  return string_functions_.Add();
}
inline void ServerMeta::add_string_functions(const ::std::string& value) {
  string_functions_.Add()->assign(value);
}
inline void ServerMeta::add_string_functions(const char* value) {
  string_functions_.Add()->assign(value);
}
inline void ServerMeta::add_string_functions(const char* value, size_t size) {
  string_functions_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ServerMeta::string_functions() const {
  return string_functions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ServerMeta::mutable_string_functions() {
  return &string_functions_;
}

// repeated .exec.user.SubQuerySupport subquery_support = 45;
inline int ServerMeta::subquery_support_size() const {
  return subquery_support_.size();
}
inline void ServerMeta::clear_subquery_support() {
  subquery_support_.Clear();
}
inline ::exec::user::SubQuerySupport ServerMeta::subquery_support(int index) const {
  return static_cast< ::exec::user::SubQuerySupport >(subquery_support_.Get(index));
}
inline void ServerMeta::set_subquery_support(int index, ::exec::user::SubQuerySupport value) {
  assert(::exec::user::SubQuerySupport_IsValid(value));
  subquery_support_.Set(index, value);
}
inline void ServerMeta::add_subquery_support(::exec::user::SubQuerySupport value) {
  assert(::exec::user::SubQuerySupport_IsValid(value));
  subquery_support_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
ServerMeta::subquery_support() const {
  return subquery_support_;
}
inline ::google::protobuf::RepeatedField<int>*
ServerMeta::mutable_subquery_support() {
  return &subquery_support_;
}

// repeated string system_functions = 46;
inline int ServerMeta::system_functions_size() const {
  return system_functions_.size();
}
inline void ServerMeta::clear_system_functions() {
  system_functions_.Clear();
}
inline const ::std::string& ServerMeta::system_functions(int index) const {
  return system_functions_.Get(index);
}
inline ::std::string* ServerMeta::mutable_system_functions(int index) {
  return system_functions_.Mutable(index);
}
inline void ServerMeta::set_system_functions(int index, const ::std::string& value) {
  system_functions_.Mutable(index)->assign(value);
}
inline void ServerMeta::set_system_functions(int index, const char* value) {
  system_functions_.Mutable(index)->assign(value);
}
inline void ServerMeta::set_system_functions(int index, const char* value, size_t size) {
  system_functions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerMeta::add_system_functions() {
  return system_functions_.Add();
}
inline void ServerMeta::add_system_functions(const ::std::string& value) {
  system_functions_.Add()->assign(value);
}
inline void ServerMeta::add_system_functions(const char* value) {
  system_functions_.Add()->assign(value);
}
inline void ServerMeta::add_system_functions(const char* value, size_t size) {
  system_functions_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ServerMeta::system_functions() const {
  return system_functions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ServerMeta::mutable_system_functions() {
  return &system_functions_;
}

// optional string table_term = 47;
inline bool ServerMeta::has_table_term() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void ServerMeta::set_has_table_term() {
  _has_bits_[1] |= 0x00004000u;
}
inline void ServerMeta::clear_has_table_term() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void ServerMeta::clear_table_term() {
  if (table_term_ != &::google::protobuf::internal::kEmptyString) {
    table_term_->clear();
  }
  clear_has_table_term();
}
inline const ::std::string& ServerMeta::table_term() const {
  return *table_term_;
}
inline void ServerMeta::set_table_term(const ::std::string& value) {
  set_has_table_term();
  if (table_term_ == &::google::protobuf::internal::kEmptyString) {
    table_term_ = new ::std::string;
  }
  table_term_->assign(value);
}
inline void ServerMeta::set_table_term(const char* value) {
  set_has_table_term();
  if (table_term_ == &::google::protobuf::internal::kEmptyString) {
    table_term_ = new ::std::string;
  }
  table_term_->assign(value);
}
inline void ServerMeta::set_table_term(const char* value, size_t size) {
  set_has_table_term();
  if (table_term_ == &::google::protobuf::internal::kEmptyString) {
    table_term_ = new ::std::string;
  }
  table_term_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerMeta::mutable_table_term() {
  set_has_table_term();
  if (table_term_ == &::google::protobuf::internal::kEmptyString) {
    table_term_ = new ::std::string;
  }
  return table_term_;
}
inline ::std::string* ServerMeta::release_table_term() {
  clear_has_table_term();
  if (table_term_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_term_;
    table_term_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerMeta::set_allocated_table_term(::std::string* table_term) {
  if (table_term_ != &::google::protobuf::internal::kEmptyString) {
    delete table_term_;
  }
  if (table_term) {
    set_has_table_term();
    table_term_ = table_term;
  } else {
    clear_has_table_term();
    table_term_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool transaction_supported = 48;
inline bool ServerMeta::has_transaction_supported() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void ServerMeta::set_has_transaction_supported() {
  _has_bits_[1] |= 0x00008000u;
}
inline void ServerMeta::clear_has_transaction_supported() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void ServerMeta::clear_transaction_supported() {
  transaction_supported_ = false;
  clear_has_transaction_supported();
}
inline bool ServerMeta::transaction_supported() const {
  return transaction_supported_;
}
inline void ServerMeta::set_transaction_supported(bool value) {
  set_has_transaction_supported();
  transaction_supported_ = value;
}

// repeated .exec.user.UnionSupport union_support = 49;
inline int ServerMeta::union_support_size() const {
  return union_support_.size();
}
inline void ServerMeta::clear_union_support() {
  union_support_.Clear();
}
inline ::exec::user::UnionSupport ServerMeta::union_support(int index) const {
  return static_cast< ::exec::user::UnionSupport >(union_support_.Get(index));
}
inline void ServerMeta::set_union_support(int index, ::exec::user::UnionSupport value) {
  assert(::exec::user::UnionSupport_IsValid(value));
  union_support_.Set(index, value);
}
inline void ServerMeta::add_union_support(::exec::user::UnionSupport value) {
  assert(::exec::user::UnionSupport_IsValid(value));
  union_support_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
ServerMeta::union_support() const {
  return union_support_;
}
inline ::google::protobuf::RepeatedField<int>*
ServerMeta::mutable_union_support() {
  return &union_support_;
}

// optional string current_schema = 50;
inline bool ServerMeta::has_current_schema() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void ServerMeta::set_has_current_schema() {
  _has_bits_[1] |= 0x00020000u;
}
inline void ServerMeta::clear_has_current_schema() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void ServerMeta::clear_current_schema() {
  if (current_schema_ != &::google::protobuf::internal::kEmptyString) {
    current_schema_->clear();
  }
  clear_has_current_schema();
}
inline const ::std::string& ServerMeta::current_schema() const {
  return *current_schema_;
}
inline void ServerMeta::set_current_schema(const ::std::string& value) {
  set_has_current_schema();
  if (current_schema_ == &::google::protobuf::internal::kEmptyString) {
    current_schema_ = new ::std::string;
  }
  current_schema_->assign(value);
}
inline void ServerMeta::set_current_schema(const char* value) {
  set_has_current_schema();
  if (current_schema_ == &::google::protobuf::internal::kEmptyString) {
    current_schema_ = new ::std::string;
  }
  current_schema_->assign(value);
}
inline void ServerMeta::set_current_schema(const char* value, size_t size) {
  set_has_current_schema();
  if (current_schema_ == &::google::protobuf::internal::kEmptyString) {
    current_schema_ = new ::std::string;
  }
  current_schema_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerMeta::mutable_current_schema() {
  set_has_current_schema();
  if (current_schema_ == &::google::protobuf::internal::kEmptyString) {
    current_schema_ = new ::std::string;
  }
  return current_schema_;
}
inline ::std::string* ServerMeta::release_current_schema() {
  clear_has_current_schema();
  if (current_schema_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = current_schema_;
    current_schema_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerMeta::set_allocated_current_schema(::std::string* current_schema) {
  if (current_schema_ != &::google::protobuf::internal::kEmptyString) {
    delete current_schema_;
  }
  if (current_schema) {
    set_has_current_schema();
    current_schema_ = current_schema;
  } else {
    clear_has_current_schema();
    current_schema_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RunQuery

// optional .exec.user.QueryResultsMode results_mode = 1;
inline bool RunQuery::has_results_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RunQuery::set_has_results_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RunQuery::clear_has_results_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RunQuery::clear_results_mode() {
  results_mode_ = 1;
  clear_has_results_mode();
}
inline ::exec::user::QueryResultsMode RunQuery::results_mode() const {
  return static_cast< ::exec::user::QueryResultsMode >(results_mode_);
}
inline void RunQuery::set_results_mode(::exec::user::QueryResultsMode value) {
  assert(::exec::user::QueryResultsMode_IsValid(value));
  set_has_results_mode();
  results_mode_ = value;
}

// optional .exec.shared.QueryType type = 2;
inline bool RunQuery::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RunQuery::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RunQuery::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RunQuery::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::exec::shared::QueryType RunQuery::type() const {
  return static_cast< ::exec::shared::QueryType >(type_);
}
inline void RunQuery::set_type(::exec::shared::QueryType value) {
  assert(::exec::shared::QueryType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string plan = 3;
inline bool RunQuery::has_plan() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RunQuery::set_has_plan() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RunQuery::clear_has_plan() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RunQuery::clear_plan() {
  if (plan_ != &::google::protobuf::internal::kEmptyString) {
    plan_->clear();
  }
  clear_has_plan();
}
inline const ::std::string& RunQuery::plan() const {
  return *plan_;
}
inline void RunQuery::set_plan(const ::std::string& value) {
  set_has_plan();
  if (plan_ == &::google::protobuf::internal::kEmptyString) {
    plan_ = new ::std::string;
  }
  plan_->assign(value);
}
inline void RunQuery::set_plan(const char* value) {
  set_has_plan();
  if (plan_ == &::google::protobuf::internal::kEmptyString) {
    plan_ = new ::std::string;
  }
  plan_->assign(value);
}
inline void RunQuery::set_plan(const char* value, size_t size) {
  set_has_plan();
  if (plan_ == &::google::protobuf::internal::kEmptyString) {
    plan_ = new ::std::string;
  }
  plan_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunQuery::mutable_plan() {
  set_has_plan();
  if (plan_ == &::google::protobuf::internal::kEmptyString) {
    plan_ = new ::std::string;
  }
  return plan_;
}
inline ::std::string* RunQuery::release_plan() {
  clear_has_plan();
  if (plan_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = plan_;
    plan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RunQuery::set_allocated_plan(::std::string* plan) {
  if (plan_ != &::google::protobuf::internal::kEmptyString) {
    delete plan_;
  }
  if (plan) {
    set_has_plan();
    plan_ = plan;
  } else {
    clear_has_plan();
    plan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .exec.bit.control.PlanFragment fragments = 4;
inline int RunQuery::fragments_size() const {
  return fragments_.size();
}
inline void RunQuery::clear_fragments() {
  fragments_.Clear();
}
inline const ::exec::bit::control::PlanFragment& RunQuery::fragments(int index) const {
  return fragments_.Get(index);
}
inline ::exec::bit::control::PlanFragment* RunQuery::mutable_fragments(int index) {
  return fragments_.Mutable(index);
}
inline ::exec::bit::control::PlanFragment* RunQuery::add_fragments() {
  return fragments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment >&
RunQuery::fragments() const {
  return fragments_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment >*
RunQuery::mutable_fragments() {
  return &fragments_;
}

// optional .exec.user.PreparedStatementHandle prepared_statement_handle = 5;
inline bool RunQuery::has_prepared_statement_handle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RunQuery::set_has_prepared_statement_handle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RunQuery::clear_has_prepared_statement_handle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RunQuery::clear_prepared_statement_handle() {
  if (prepared_statement_handle_ != NULL) prepared_statement_handle_->::exec::user::PreparedStatementHandle::Clear();
  clear_has_prepared_statement_handle();
}
inline const ::exec::user::PreparedStatementHandle& RunQuery::prepared_statement_handle() const {
  return prepared_statement_handle_ != NULL ? *prepared_statement_handle_ : *default_instance_->prepared_statement_handle_;
}
inline ::exec::user::PreparedStatementHandle* RunQuery::mutable_prepared_statement_handle() {
  set_has_prepared_statement_handle();
  if (prepared_statement_handle_ == NULL) prepared_statement_handle_ = new ::exec::user::PreparedStatementHandle;
  return prepared_statement_handle_;
}
inline ::exec::user::PreparedStatementHandle* RunQuery::release_prepared_statement_handle() {
  clear_has_prepared_statement_handle();
  ::exec::user::PreparedStatementHandle* temp = prepared_statement_handle_;
  prepared_statement_handle_ = NULL;
  return temp;
}
inline void RunQuery::set_allocated_prepared_statement_handle(::exec::user::PreparedStatementHandle* prepared_statement_handle) {
  delete prepared_statement_handle_;
  prepared_statement_handle_ = prepared_statement_handle;
  if (prepared_statement_handle) {
    set_has_prepared_statement_handle();
  } else {
    clear_has_prepared_statement_handle();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace user
}  // namespace exec

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::RpcType>() {
  return ::exec::user::RpcType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::SaslSupport>() {
  return ::exec::user::SaslSupport_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::QueryResultsMode>() {
  return ::exec::user::QueryResultsMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::HandshakeStatus>() {
  return ::exec::user::HandshakeStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::RequestStatus>() {
  return ::exec::user::RequestStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::ColumnSearchability>() {
  return ::exec::user::ColumnSearchability_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::ColumnUpdatability>() {
  return ::exec::user::ColumnUpdatability_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::CollateSupport>() {
  return ::exec::user::CollateSupport_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::CorrelationNamesSupport>() {
  return ::exec::user::CorrelationNamesSupport_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::DateTimeLiteralsSupport>() {
  return ::exec::user::DateTimeLiteralsSupport_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::GroupBySupport>() {
  return ::exec::user::GroupBySupport_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::IdentifierCasing>() {
  return ::exec::user::IdentifierCasing_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::NullCollation>() {
  return ::exec::user::NullCollation_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::OrderBySupport>() {
  return ::exec::user::OrderBySupport_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::OuterJoinSupport>() {
  return ::exec::user::OuterJoinSupport_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::SubQuerySupport>() {
  return ::exec::user::SubQuerySupport_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::UnionSupport>() {
  return ::exec::user::UnionSupport_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_User_2eproto__INCLUDED
