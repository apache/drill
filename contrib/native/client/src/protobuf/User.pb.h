// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: User.proto

#ifndef PROTOBUF_INCLUDED_User_2eproto
#define PROTOBUF_INCLUDED_User_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "SchemaDef.pb.h"
#include "Types.pb.h"
#include "UserBitShared.pb.h"
#include "BitData.pb.h"
#include "BitControl.pb.h"
#include "ExecutionProtos.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_User_2eproto 

namespace protobuf_User_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[31];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_User_2eproto
namespace exec {
namespace user {
class BitToUserHandshake;
class BitToUserHandshakeDefaultTypeInternal;
extern BitToUserHandshakeDefaultTypeInternal _BitToUserHandshake_default_instance_;
class CatalogMetadata;
class CatalogMetadataDefaultTypeInternal;
extern CatalogMetadataDefaultTypeInternal _CatalogMetadata_default_instance_;
class ColumnMetadata;
class ColumnMetadataDefaultTypeInternal;
extern ColumnMetadataDefaultTypeInternal _ColumnMetadata_default_instance_;
class ConvertSupport;
class ConvertSupportDefaultTypeInternal;
extern ConvertSupportDefaultTypeInternal _ConvertSupport_default_instance_;
class CreatePreparedStatementReq;
class CreatePreparedStatementReqDefaultTypeInternal;
extern CreatePreparedStatementReqDefaultTypeInternal _CreatePreparedStatementReq_default_instance_;
class CreatePreparedStatementResp;
class CreatePreparedStatementRespDefaultTypeInternal;
extern CreatePreparedStatementRespDefaultTypeInternal _CreatePreparedStatementResp_default_instance_;
class GetCatalogsReq;
class GetCatalogsReqDefaultTypeInternal;
extern GetCatalogsReqDefaultTypeInternal _GetCatalogsReq_default_instance_;
class GetCatalogsResp;
class GetCatalogsRespDefaultTypeInternal;
extern GetCatalogsRespDefaultTypeInternal _GetCatalogsResp_default_instance_;
class GetColumnsReq;
class GetColumnsReqDefaultTypeInternal;
extern GetColumnsReqDefaultTypeInternal _GetColumnsReq_default_instance_;
class GetColumnsResp;
class GetColumnsRespDefaultTypeInternal;
extern GetColumnsRespDefaultTypeInternal _GetColumnsResp_default_instance_;
class GetQueryPlanFragments;
class GetQueryPlanFragmentsDefaultTypeInternal;
extern GetQueryPlanFragmentsDefaultTypeInternal _GetQueryPlanFragments_default_instance_;
class GetSchemasReq;
class GetSchemasReqDefaultTypeInternal;
extern GetSchemasReqDefaultTypeInternal _GetSchemasReq_default_instance_;
class GetSchemasResp;
class GetSchemasRespDefaultTypeInternal;
extern GetSchemasRespDefaultTypeInternal _GetSchemasResp_default_instance_;
class GetServerMetaReq;
class GetServerMetaReqDefaultTypeInternal;
extern GetServerMetaReqDefaultTypeInternal _GetServerMetaReq_default_instance_;
class GetServerMetaResp;
class GetServerMetaRespDefaultTypeInternal;
extern GetServerMetaRespDefaultTypeInternal _GetServerMetaResp_default_instance_;
class GetTablesReq;
class GetTablesReqDefaultTypeInternal;
extern GetTablesReqDefaultTypeInternal _GetTablesReq_default_instance_;
class GetTablesResp;
class GetTablesRespDefaultTypeInternal;
extern GetTablesRespDefaultTypeInternal _GetTablesResp_default_instance_;
class LikeFilter;
class LikeFilterDefaultTypeInternal;
extern LikeFilterDefaultTypeInternal _LikeFilter_default_instance_;
class PreparedStatement;
class PreparedStatementDefaultTypeInternal;
extern PreparedStatementDefaultTypeInternal _PreparedStatement_default_instance_;
class PreparedStatementHandle;
class PreparedStatementHandleDefaultTypeInternal;
extern PreparedStatementHandleDefaultTypeInternal _PreparedStatementHandle_default_instance_;
class Property;
class PropertyDefaultTypeInternal;
extern PropertyDefaultTypeInternal _Property_default_instance_;
class QueryPlanFragments;
class QueryPlanFragmentsDefaultTypeInternal;
extern QueryPlanFragmentsDefaultTypeInternal _QueryPlanFragments_default_instance_;
class RequestResults;
class RequestResultsDefaultTypeInternal;
extern RequestResultsDefaultTypeInternal _RequestResults_default_instance_;
class ResultColumnMetadata;
class ResultColumnMetadataDefaultTypeInternal;
extern ResultColumnMetadataDefaultTypeInternal _ResultColumnMetadata_default_instance_;
class RpcEndpointInfos;
class RpcEndpointInfosDefaultTypeInternal;
extern RpcEndpointInfosDefaultTypeInternal _RpcEndpointInfos_default_instance_;
class RunQuery;
class RunQueryDefaultTypeInternal;
extern RunQueryDefaultTypeInternal _RunQuery_default_instance_;
class SchemaMetadata;
class SchemaMetadataDefaultTypeInternal;
extern SchemaMetadataDefaultTypeInternal _SchemaMetadata_default_instance_;
class ServerMeta;
class ServerMetaDefaultTypeInternal;
extern ServerMetaDefaultTypeInternal _ServerMeta_default_instance_;
class TableMetadata;
class TableMetadataDefaultTypeInternal;
extern TableMetadataDefaultTypeInternal _TableMetadata_default_instance_;
class UserProperties;
class UserPropertiesDefaultTypeInternal;
extern UserPropertiesDefaultTypeInternal _UserProperties_default_instance_;
class UserToBitHandshake;
class UserToBitHandshakeDefaultTypeInternal;
extern UserToBitHandshakeDefaultTypeInternal _UserToBitHandshake_default_instance_;
}  // namespace user
}  // namespace exec
namespace google {
namespace protobuf {
template<> ::exec::user::BitToUserHandshake* Arena::CreateMaybeMessage<::exec::user::BitToUserHandshake>(Arena*);
template<> ::exec::user::CatalogMetadata* Arena::CreateMaybeMessage<::exec::user::CatalogMetadata>(Arena*);
template<> ::exec::user::ColumnMetadata* Arena::CreateMaybeMessage<::exec::user::ColumnMetadata>(Arena*);
template<> ::exec::user::ConvertSupport* Arena::CreateMaybeMessage<::exec::user::ConvertSupport>(Arena*);
template<> ::exec::user::CreatePreparedStatementReq* Arena::CreateMaybeMessage<::exec::user::CreatePreparedStatementReq>(Arena*);
template<> ::exec::user::CreatePreparedStatementResp* Arena::CreateMaybeMessage<::exec::user::CreatePreparedStatementResp>(Arena*);
template<> ::exec::user::GetCatalogsReq* Arena::CreateMaybeMessage<::exec::user::GetCatalogsReq>(Arena*);
template<> ::exec::user::GetCatalogsResp* Arena::CreateMaybeMessage<::exec::user::GetCatalogsResp>(Arena*);
template<> ::exec::user::GetColumnsReq* Arena::CreateMaybeMessage<::exec::user::GetColumnsReq>(Arena*);
template<> ::exec::user::GetColumnsResp* Arena::CreateMaybeMessage<::exec::user::GetColumnsResp>(Arena*);
template<> ::exec::user::GetQueryPlanFragments* Arena::CreateMaybeMessage<::exec::user::GetQueryPlanFragments>(Arena*);
template<> ::exec::user::GetSchemasReq* Arena::CreateMaybeMessage<::exec::user::GetSchemasReq>(Arena*);
template<> ::exec::user::GetSchemasResp* Arena::CreateMaybeMessage<::exec::user::GetSchemasResp>(Arena*);
template<> ::exec::user::GetServerMetaReq* Arena::CreateMaybeMessage<::exec::user::GetServerMetaReq>(Arena*);
template<> ::exec::user::GetServerMetaResp* Arena::CreateMaybeMessage<::exec::user::GetServerMetaResp>(Arena*);
template<> ::exec::user::GetTablesReq* Arena::CreateMaybeMessage<::exec::user::GetTablesReq>(Arena*);
template<> ::exec::user::GetTablesResp* Arena::CreateMaybeMessage<::exec::user::GetTablesResp>(Arena*);
template<> ::exec::user::LikeFilter* Arena::CreateMaybeMessage<::exec::user::LikeFilter>(Arena*);
template<> ::exec::user::PreparedStatement* Arena::CreateMaybeMessage<::exec::user::PreparedStatement>(Arena*);
template<> ::exec::user::PreparedStatementHandle* Arena::CreateMaybeMessage<::exec::user::PreparedStatementHandle>(Arena*);
template<> ::exec::user::Property* Arena::CreateMaybeMessage<::exec::user::Property>(Arena*);
template<> ::exec::user::QueryPlanFragments* Arena::CreateMaybeMessage<::exec::user::QueryPlanFragments>(Arena*);
template<> ::exec::user::RequestResults* Arena::CreateMaybeMessage<::exec::user::RequestResults>(Arena*);
template<> ::exec::user::ResultColumnMetadata* Arena::CreateMaybeMessage<::exec::user::ResultColumnMetadata>(Arena*);
template<> ::exec::user::RpcEndpointInfos* Arena::CreateMaybeMessage<::exec::user::RpcEndpointInfos>(Arena*);
template<> ::exec::user::RunQuery* Arena::CreateMaybeMessage<::exec::user::RunQuery>(Arena*);
template<> ::exec::user::SchemaMetadata* Arena::CreateMaybeMessage<::exec::user::SchemaMetadata>(Arena*);
template<> ::exec::user::ServerMeta* Arena::CreateMaybeMessage<::exec::user::ServerMeta>(Arena*);
template<> ::exec::user::TableMetadata* Arena::CreateMaybeMessage<::exec::user::TableMetadata>(Arena*);
template<> ::exec::user::UserProperties* Arena::CreateMaybeMessage<::exec::user::UserProperties>(Arena*);
template<> ::exec::user::UserToBitHandshake* Arena::CreateMaybeMessage<::exec::user::UserToBitHandshake>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace exec {
namespace user {

enum RpcType {
  HANDSHAKE = 0,
  ACK = 1,
  GOODBYE = 2,
  RUN_QUERY = 3,
  CANCEL_QUERY = 4,
  REQUEST_RESULTS = 5,
  RESUME_PAUSED_QUERY = 11,
  GET_QUERY_PLAN_FRAGMENTS = 12,
  GET_CATALOGS = 14,
  GET_SCHEMAS = 15,
  GET_TABLES = 16,
  GET_COLUMNS = 17,
  CREATE_PREPARED_STATEMENT = 22,
  GET_SERVER_META = 8,
  QUERY_DATA = 6,
  QUERY_HANDLE = 7,
  QUERY_PLAN_FRAGMENTS = 13,
  CATALOGS = 18,
  SCHEMAS = 19,
  TABLES = 20,
  COLUMNS = 21,
  PREPARED_STATEMENT = 23,
  SERVER_META = 9,
  QUERY_RESULT = 10,
  SASL_MESSAGE = 24
};
bool RpcType_IsValid(int value);
const RpcType RpcType_MIN = HANDSHAKE;
const RpcType RpcType_MAX = SASL_MESSAGE;
const int RpcType_ARRAYSIZE = RpcType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpcType_descriptor();
inline const ::std::string& RpcType_Name(RpcType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpcType_descriptor(), value);
}
inline bool RpcType_Parse(
    const ::std::string& name, RpcType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcType>(
    RpcType_descriptor(), name, value);
}
enum SaslSupport {
  UNKNOWN_SASL_SUPPORT = 0,
  SASL_AUTH = 1,
  SASL_PRIVACY = 2
};
bool SaslSupport_IsValid(int value);
const SaslSupport SaslSupport_MIN = UNKNOWN_SASL_SUPPORT;
const SaslSupport SaslSupport_MAX = SASL_PRIVACY;
const int SaslSupport_ARRAYSIZE = SaslSupport_MAX + 1;

const ::google::protobuf::EnumDescriptor* SaslSupport_descriptor();
inline const ::std::string& SaslSupport_Name(SaslSupport value) {
  return ::google::protobuf::internal::NameOfEnum(
    SaslSupport_descriptor(), value);
}
inline bool SaslSupport_Parse(
    const ::std::string& name, SaslSupport* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SaslSupport>(
    SaslSupport_descriptor(), name, value);
}
enum QueryResultsMode {
  STREAM_FULL = 1
};
bool QueryResultsMode_IsValid(int value);
const QueryResultsMode QueryResultsMode_MIN = STREAM_FULL;
const QueryResultsMode QueryResultsMode_MAX = STREAM_FULL;
const int QueryResultsMode_ARRAYSIZE = QueryResultsMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* QueryResultsMode_descriptor();
inline const ::std::string& QueryResultsMode_Name(QueryResultsMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    QueryResultsMode_descriptor(), value);
}
inline bool QueryResultsMode_Parse(
    const ::std::string& name, QueryResultsMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QueryResultsMode>(
    QueryResultsMode_descriptor(), name, value);
}
enum HandshakeStatus {
  SUCCESS = 1,
  RPC_VERSION_MISMATCH = 2,
  AUTH_FAILED = 3,
  UNKNOWN_FAILURE = 4,
  AUTH_REQUIRED = 5
};
bool HandshakeStatus_IsValid(int value);
const HandshakeStatus HandshakeStatus_MIN = SUCCESS;
const HandshakeStatus HandshakeStatus_MAX = AUTH_REQUIRED;
const int HandshakeStatus_ARRAYSIZE = HandshakeStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* HandshakeStatus_descriptor();
inline const ::std::string& HandshakeStatus_Name(HandshakeStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    HandshakeStatus_descriptor(), value);
}
inline bool HandshakeStatus_Parse(
    const ::std::string& name, HandshakeStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HandshakeStatus>(
    HandshakeStatus_descriptor(), name, value);
}
enum RequestStatus {
  UNKNOWN_STATUS = 0,
  OK = 1,
  FAILED = 2,
  TIMEOUT = 3
};
bool RequestStatus_IsValid(int value);
const RequestStatus RequestStatus_MIN = UNKNOWN_STATUS;
const RequestStatus RequestStatus_MAX = TIMEOUT;
const int RequestStatus_ARRAYSIZE = RequestStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* RequestStatus_descriptor();
inline const ::std::string& RequestStatus_Name(RequestStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    RequestStatus_descriptor(), value);
}
inline bool RequestStatus_Parse(
    const ::std::string& name, RequestStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestStatus>(
    RequestStatus_descriptor(), name, value);
}
enum ColumnSearchability {
  UNKNOWN_SEARCHABILITY = 0,
  NONE = 1,
  CHAR = 2,
  NUMBER = 3,
  ALL = 4
};
bool ColumnSearchability_IsValid(int value);
const ColumnSearchability ColumnSearchability_MIN = UNKNOWN_SEARCHABILITY;
const ColumnSearchability ColumnSearchability_MAX = ALL;
const int ColumnSearchability_ARRAYSIZE = ColumnSearchability_MAX + 1;

const ::google::protobuf::EnumDescriptor* ColumnSearchability_descriptor();
inline const ::std::string& ColumnSearchability_Name(ColumnSearchability value) {
  return ::google::protobuf::internal::NameOfEnum(
    ColumnSearchability_descriptor(), value);
}
inline bool ColumnSearchability_Parse(
    const ::std::string& name, ColumnSearchability* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ColumnSearchability>(
    ColumnSearchability_descriptor(), name, value);
}
enum ColumnUpdatability {
  UNKNOWN_UPDATABILITY = 0,
  READ_ONLY = 1,
  WRITABLE = 2
};
bool ColumnUpdatability_IsValid(int value);
const ColumnUpdatability ColumnUpdatability_MIN = UNKNOWN_UPDATABILITY;
const ColumnUpdatability ColumnUpdatability_MAX = WRITABLE;
const int ColumnUpdatability_ARRAYSIZE = ColumnUpdatability_MAX + 1;

const ::google::protobuf::EnumDescriptor* ColumnUpdatability_descriptor();
inline const ::std::string& ColumnUpdatability_Name(ColumnUpdatability value) {
  return ::google::protobuf::internal::NameOfEnum(
    ColumnUpdatability_descriptor(), value);
}
inline bool ColumnUpdatability_Parse(
    const ::std::string& name, ColumnUpdatability* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ColumnUpdatability>(
    ColumnUpdatability_descriptor(), name, value);
}
enum CollateSupport {
  CS_UNKNOWN = 0,
  CS_GROUP_BY = 1
};
bool CollateSupport_IsValid(int value);
const CollateSupport CollateSupport_MIN = CS_UNKNOWN;
const CollateSupport CollateSupport_MAX = CS_GROUP_BY;
const int CollateSupport_ARRAYSIZE = CollateSupport_MAX + 1;

const ::google::protobuf::EnumDescriptor* CollateSupport_descriptor();
inline const ::std::string& CollateSupport_Name(CollateSupport value) {
  return ::google::protobuf::internal::NameOfEnum(
    CollateSupport_descriptor(), value);
}
inline bool CollateSupport_Parse(
    const ::std::string& name, CollateSupport* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CollateSupport>(
    CollateSupport_descriptor(), name, value);
}
enum CorrelationNamesSupport {
  CN_NONE = 1,
  CN_DIFFERENT_NAMES = 2,
  CN_ANY = 3
};
bool CorrelationNamesSupport_IsValid(int value);
const CorrelationNamesSupport CorrelationNamesSupport_MIN = CN_NONE;
const CorrelationNamesSupport CorrelationNamesSupport_MAX = CN_ANY;
const int CorrelationNamesSupport_ARRAYSIZE = CorrelationNamesSupport_MAX + 1;

const ::google::protobuf::EnumDescriptor* CorrelationNamesSupport_descriptor();
inline const ::std::string& CorrelationNamesSupport_Name(CorrelationNamesSupport value) {
  return ::google::protobuf::internal::NameOfEnum(
    CorrelationNamesSupport_descriptor(), value);
}
inline bool CorrelationNamesSupport_Parse(
    const ::std::string& name, CorrelationNamesSupport* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CorrelationNamesSupport>(
    CorrelationNamesSupport_descriptor(), name, value);
}
enum DateTimeLiteralsSupport {
  DL_UNKNOWN = 0,
  DL_DATE = 1,
  DL_TIME = 2,
  DL_TIMESTAMP = 3,
  DL_INTERVAL_YEAR = 4,
  DL_INTERVAL_MONTH = 5,
  DL_INTERVAL_DAY = 6,
  DL_INTERVAL_HOUR = 7,
  DL_INTERVAL_MINUTE = 8,
  DL_INTERVAL_SECOND = 9,
  DL_INTERVAL_YEAR_TO_MONTH = 10,
  DL_INTERVAL_DAY_TO_HOUR = 11,
  DL_INTERVAL_DAY_TO_MINUTE = 12,
  DL_INTERVAL_DAY_TO_SECOND = 13,
  DL_INTERVAL_HOUR_TO_MINUTE = 14,
  DL_INTERVAL_HOUR_TO_SECOND = 15,
  DL_INTERVAL_MINUTE_TO_SECOND = 16
};
bool DateTimeLiteralsSupport_IsValid(int value);
const DateTimeLiteralsSupport DateTimeLiteralsSupport_MIN = DL_UNKNOWN;
const DateTimeLiteralsSupport DateTimeLiteralsSupport_MAX = DL_INTERVAL_MINUTE_TO_SECOND;
const int DateTimeLiteralsSupport_ARRAYSIZE = DateTimeLiteralsSupport_MAX + 1;

const ::google::protobuf::EnumDescriptor* DateTimeLiteralsSupport_descriptor();
inline const ::std::string& DateTimeLiteralsSupport_Name(DateTimeLiteralsSupport value) {
  return ::google::protobuf::internal::NameOfEnum(
    DateTimeLiteralsSupport_descriptor(), value);
}
inline bool DateTimeLiteralsSupport_Parse(
    const ::std::string& name, DateTimeLiteralsSupport* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DateTimeLiteralsSupport>(
    DateTimeLiteralsSupport_descriptor(), name, value);
}
enum GroupBySupport {
  GB_NONE = 1,
  GB_SELECT_ONLY = 2,
  GB_BEYOND_SELECT = 3,
  GB_UNRELATED = 4
};
bool GroupBySupport_IsValid(int value);
const GroupBySupport GroupBySupport_MIN = GB_NONE;
const GroupBySupport GroupBySupport_MAX = GB_UNRELATED;
const int GroupBySupport_ARRAYSIZE = GroupBySupport_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupBySupport_descriptor();
inline const ::std::string& GroupBySupport_Name(GroupBySupport value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupBySupport_descriptor(), value);
}
inline bool GroupBySupport_Parse(
    const ::std::string& name, GroupBySupport* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupBySupport>(
    GroupBySupport_descriptor(), name, value);
}
enum IdentifierCasing {
  IC_UNKNOWN = 0,
  IC_STORES_LOWER = 1,
  IC_STORES_MIXED = 2,
  IC_STORES_UPPER = 3,
  IC_SUPPORTS_MIXED = 4
};
bool IdentifierCasing_IsValid(int value);
const IdentifierCasing IdentifierCasing_MIN = IC_UNKNOWN;
const IdentifierCasing IdentifierCasing_MAX = IC_SUPPORTS_MIXED;
const int IdentifierCasing_ARRAYSIZE = IdentifierCasing_MAX + 1;

const ::google::protobuf::EnumDescriptor* IdentifierCasing_descriptor();
inline const ::std::string& IdentifierCasing_Name(IdentifierCasing value) {
  return ::google::protobuf::internal::NameOfEnum(
    IdentifierCasing_descriptor(), value);
}
inline bool IdentifierCasing_Parse(
    const ::std::string& name, IdentifierCasing* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IdentifierCasing>(
    IdentifierCasing_descriptor(), name, value);
}
enum NullCollation {
  NC_UNKNOWN = 0,
  NC_AT_START = 1,
  NC_AT_END = 2,
  NC_HIGH = 3,
  NC_LOW = 4
};
bool NullCollation_IsValid(int value);
const NullCollation NullCollation_MIN = NC_UNKNOWN;
const NullCollation NullCollation_MAX = NC_LOW;
const int NullCollation_ARRAYSIZE = NullCollation_MAX + 1;

const ::google::protobuf::EnumDescriptor* NullCollation_descriptor();
inline const ::std::string& NullCollation_Name(NullCollation value) {
  return ::google::protobuf::internal::NameOfEnum(
    NullCollation_descriptor(), value);
}
inline bool NullCollation_Parse(
    const ::std::string& name, NullCollation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NullCollation>(
    NullCollation_descriptor(), name, value);
}
enum OrderBySupport {
  OB_UNKNOWN = 0,
  OB_UNRELATED = 1,
  OB_EXPRESSION = 2
};
bool OrderBySupport_IsValid(int value);
const OrderBySupport OrderBySupport_MIN = OB_UNKNOWN;
const OrderBySupport OrderBySupport_MAX = OB_EXPRESSION;
const int OrderBySupport_ARRAYSIZE = OrderBySupport_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderBySupport_descriptor();
inline const ::std::string& OrderBySupport_Name(OrderBySupport value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderBySupport_descriptor(), value);
}
inline bool OrderBySupport_Parse(
    const ::std::string& name, OrderBySupport* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderBySupport>(
    OrderBySupport_descriptor(), name, value);
}
enum OuterJoinSupport {
  OJ_UNKNOWN = 0,
  OJ_LEFT = 1,
  OJ_RIGHT = 2,
  OJ_FULL = 3,
  OJ_NESTED = 4,
  OJ_NOT_ORDERED = 5,
  OJ_INNER = 6,
  OJ_ALL_COMPARISON_OPS = 7
};
bool OuterJoinSupport_IsValid(int value);
const OuterJoinSupport OuterJoinSupport_MIN = OJ_UNKNOWN;
const OuterJoinSupport OuterJoinSupport_MAX = OJ_ALL_COMPARISON_OPS;
const int OuterJoinSupport_ARRAYSIZE = OuterJoinSupport_MAX + 1;

const ::google::protobuf::EnumDescriptor* OuterJoinSupport_descriptor();
inline const ::std::string& OuterJoinSupport_Name(OuterJoinSupport value) {
  return ::google::protobuf::internal::NameOfEnum(
    OuterJoinSupport_descriptor(), value);
}
inline bool OuterJoinSupport_Parse(
    const ::std::string& name, OuterJoinSupport* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OuterJoinSupport>(
    OuterJoinSupport_descriptor(), name, value);
}
enum SubQuerySupport {
  SQ_UNKNOWN = 0,
  SQ_CORRELATED = 1,
  SQ_IN_COMPARISON = 2,
  SQ_IN_EXISTS = 3,
  SQ_IN_INSERT = 4,
  SQ_IN_QUANTIFIED = 5
};
bool SubQuerySupport_IsValid(int value);
const SubQuerySupport SubQuerySupport_MIN = SQ_UNKNOWN;
const SubQuerySupport SubQuerySupport_MAX = SQ_IN_QUANTIFIED;
const int SubQuerySupport_ARRAYSIZE = SubQuerySupport_MAX + 1;

const ::google::protobuf::EnumDescriptor* SubQuerySupport_descriptor();
inline const ::std::string& SubQuerySupport_Name(SubQuerySupport value) {
  return ::google::protobuf::internal::NameOfEnum(
    SubQuerySupport_descriptor(), value);
}
inline bool SubQuerySupport_Parse(
    const ::std::string& name, SubQuerySupport* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SubQuerySupport>(
    SubQuerySupport_descriptor(), name, value);
}
enum UnionSupport {
  U_UNKNOWN = 0,
  U_UNION = 1,
  U_UNION_ALL = 2
};
bool UnionSupport_IsValid(int value);
const UnionSupport UnionSupport_MIN = U_UNKNOWN;
const UnionSupport UnionSupport_MAX = U_UNION_ALL;
const int UnionSupport_ARRAYSIZE = UnionSupport_MAX + 1;

const ::google::protobuf::EnumDescriptor* UnionSupport_descriptor();
inline const ::std::string& UnionSupport_Name(UnionSupport value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnionSupport_descriptor(), value);
}
inline bool UnionSupport_Parse(
    const ::std::string& name, UnionSupport* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnionSupport>(
    UnionSupport_descriptor(), name, value);
}
// ===================================================================

class Property : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.Property) */ {
 public:
  Property();
  virtual ~Property();

  Property(const Property& from);

  inline Property& operator=(const Property& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Property(Property&& from) noexcept
    : Property() {
    *this = ::std::move(from);
  }

  inline Property& operator=(Property&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Property& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Property* internal_default_instance() {
    return reinterpret_cast<const Property*>(
               &_Property_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Property* other);
  friend void swap(Property& a, Property& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Property* New() const final {
    return CreateMaybeMessage<Property>(NULL);
  }

  Property* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Property>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Property& from);
  void MergeFrom(const Property& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Property* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:exec.user.Property)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserProperties : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.UserProperties) */ {
 public:
  UserProperties();
  virtual ~UserProperties();

  UserProperties(const UserProperties& from);

  inline UserProperties& operator=(const UserProperties& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserProperties(UserProperties&& from) noexcept
    : UserProperties() {
    *this = ::std::move(from);
  }

  inline UserProperties& operator=(UserProperties&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserProperties& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserProperties* internal_default_instance() {
    return reinterpret_cast<const UserProperties*>(
               &_UserProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(UserProperties* other);
  friend void swap(UserProperties& a, UserProperties& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserProperties* New() const final {
    return CreateMaybeMessage<UserProperties>(NULL);
  }

  UserProperties* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserProperties>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserProperties& from);
  void MergeFrom(const UserProperties& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserProperties* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .exec.user.Property properties = 1;
  int properties_size() const;
  void clear_properties();
  static const int kPropertiesFieldNumber = 1;
  ::exec::user::Property* mutable_properties(int index);
  ::google::protobuf::RepeatedPtrField< ::exec::user::Property >*
      mutable_properties();
  const ::exec::user::Property& properties(int index) const;
  ::exec::user::Property* add_properties();
  const ::google::protobuf::RepeatedPtrField< ::exec::user::Property >&
      properties() const;

  // @@protoc_insertion_point(class_scope:exec.user.UserProperties)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::exec::user::Property > properties_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RpcEndpointInfos : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.RpcEndpointInfos) */ {
 public:
  RpcEndpointInfos();
  virtual ~RpcEndpointInfos();

  RpcEndpointInfos(const RpcEndpointInfos& from);

  inline RpcEndpointInfos& operator=(const RpcEndpointInfos& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RpcEndpointInfos(RpcEndpointInfos&& from) noexcept
    : RpcEndpointInfos() {
    *this = ::std::move(from);
  }

  inline RpcEndpointInfos& operator=(RpcEndpointInfos&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpcEndpointInfos& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RpcEndpointInfos* internal_default_instance() {
    return reinterpret_cast<const RpcEndpointInfos*>(
               &_RpcEndpointInfos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RpcEndpointInfos* other);
  friend void swap(RpcEndpointInfos& a, RpcEndpointInfos& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RpcEndpointInfos* New() const final {
    return CreateMaybeMessage<RpcEndpointInfos>(NULL);
  }

  RpcEndpointInfos* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RpcEndpointInfos>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RpcEndpointInfos& from);
  void MergeFrom(const RpcEndpointInfos& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RpcEndpointInfos* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string version = 2;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional string application = 6;
  bool has_application() const;
  void clear_application();
  static const int kApplicationFieldNumber = 6;
  const ::std::string& application() const;
  void set_application(const ::std::string& value);
  #if LANG_CXX11
  void set_application(::std::string&& value);
  #endif
  void set_application(const char* value);
  void set_application(const char* value, size_t size);
  ::std::string* mutable_application();
  ::std::string* release_application();
  void set_allocated_application(::std::string* application);

  // optional string versionQualifier = 8;
  bool has_versionqualifier() const;
  void clear_versionqualifier();
  static const int kVersionQualifierFieldNumber = 8;
  const ::std::string& versionqualifier() const;
  void set_versionqualifier(const ::std::string& value);
  #if LANG_CXX11
  void set_versionqualifier(::std::string&& value);
  #endif
  void set_versionqualifier(const char* value);
  void set_versionqualifier(const char* value, size_t size);
  ::std::string* mutable_versionqualifier();
  ::std::string* release_versionqualifier();
  void set_allocated_versionqualifier(::std::string* versionqualifier);

  // optional uint32 majorVersion = 3;
  bool has_majorversion() const;
  void clear_majorversion();
  static const int kMajorVersionFieldNumber = 3;
  ::google::protobuf::uint32 majorversion() const;
  void set_majorversion(::google::protobuf::uint32 value);

  // optional uint32 minorVersion = 4;
  bool has_minorversion() const;
  void clear_minorversion();
  static const int kMinorVersionFieldNumber = 4;
  ::google::protobuf::uint32 minorversion() const;
  void set_minorversion(::google::protobuf::uint32 value);

  // optional uint32 patchVersion = 5;
  bool has_patchversion() const;
  void clear_patchversion();
  static const int kPatchVersionFieldNumber = 5;
  ::google::protobuf::uint32 patchversion() const;
  void set_patchversion(::google::protobuf::uint32 value);

  // optional uint32 buildNumber = 7;
  bool has_buildnumber() const;
  void clear_buildnumber();
  static const int kBuildNumberFieldNumber = 7;
  ::google::protobuf::uint32 buildnumber() const;
  void set_buildnumber(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:exec.user.RpcEndpointInfos)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_version();
  void clear_has_version();
  void set_has_majorversion();
  void clear_has_majorversion();
  void set_has_minorversion();
  void clear_has_minorversion();
  void set_has_patchversion();
  void clear_has_patchversion();
  void set_has_application();
  void clear_has_application();
  void set_has_buildnumber();
  void clear_has_buildnumber();
  void set_has_versionqualifier();
  void clear_has_versionqualifier();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr application_;
  ::google::protobuf::internal::ArenaStringPtr versionqualifier_;
  ::google::protobuf::uint32 majorversion_;
  ::google::protobuf::uint32 minorversion_;
  ::google::protobuf::uint32 patchversion_;
  ::google::protobuf::uint32 buildnumber_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserToBitHandshake : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.UserToBitHandshake) */ {
 public:
  UserToBitHandshake();
  virtual ~UserToBitHandshake();

  UserToBitHandshake(const UserToBitHandshake& from);

  inline UserToBitHandshake& operator=(const UserToBitHandshake& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserToBitHandshake(UserToBitHandshake&& from) noexcept
    : UserToBitHandshake() {
    *this = ::std::move(from);
  }

  inline UserToBitHandshake& operator=(UserToBitHandshake&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserToBitHandshake& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserToBitHandshake* internal_default_instance() {
    return reinterpret_cast<const UserToBitHandshake*>(
               &_UserToBitHandshake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(UserToBitHandshake* other);
  friend void swap(UserToBitHandshake& a, UserToBitHandshake& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserToBitHandshake* New() const final {
    return CreateMaybeMessage<UserToBitHandshake>(NULL);
  }

  UserToBitHandshake* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserToBitHandshake>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserToBitHandshake& from);
  void MergeFrom(const UserToBitHandshake& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserToBitHandshake* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.shared.UserCredentials credentials = 4;
  bool has_credentials() const;
  void clear_credentials();
  static const int kCredentialsFieldNumber = 4;
  private:
  const ::exec::shared::UserCredentials& _internal_credentials() const;
  public:
  const ::exec::shared::UserCredentials& credentials() const;
  ::exec::shared::UserCredentials* release_credentials();
  ::exec::shared::UserCredentials* mutable_credentials();
  void set_allocated_credentials(::exec::shared::UserCredentials* credentials);

  // optional .exec.user.UserProperties properties = 5;
  bool has_properties() const;
  void clear_properties();
  static const int kPropertiesFieldNumber = 5;
  private:
  const ::exec::user::UserProperties& _internal_properties() const;
  public:
  const ::exec::user::UserProperties& properties() const;
  ::exec::user::UserProperties* release_properties();
  ::exec::user::UserProperties* mutable_properties();
  void set_allocated_properties(::exec::user::UserProperties* properties);

  // optional .exec.user.RpcEndpointInfos client_infos = 8;
  bool has_client_infos() const;
  void clear_client_infos();
  static const int kClientInfosFieldNumber = 8;
  private:
  const ::exec::user::RpcEndpointInfos& _internal_client_infos() const;
  public:
  const ::exec::user::RpcEndpointInfos& client_infos() const;
  ::exec::user::RpcEndpointInfos* release_client_infos();
  ::exec::user::RpcEndpointInfos* mutable_client_infos();
  void set_allocated_client_infos(::exec::user::RpcEndpointInfos* client_infos);

  // optional int32 rpc_version = 3;
  bool has_rpc_version() const;
  void clear_rpc_version();
  static const int kRpcVersionFieldNumber = 3;
  ::google::protobuf::int32 rpc_version() const;
  void set_rpc_version(::google::protobuf::int32 value);

  // optional bool support_listening = 2;
  bool has_support_listening() const;
  void clear_support_listening();
  static const int kSupportListeningFieldNumber = 2;
  bool support_listening() const;
  void set_support_listening(bool value);

  // optional bool support_complex_types = 6 [default = false];
  bool has_support_complex_types() const;
  void clear_support_complex_types();
  static const int kSupportComplexTypesFieldNumber = 6;
  bool support_complex_types() const;
  void set_support_complex_types(bool value);

  // optional bool support_timeout = 7 [default = false];
  bool has_support_timeout() const;
  void clear_support_timeout();
  static const int kSupportTimeoutFieldNumber = 7;
  bool support_timeout() const;
  void set_support_timeout(bool value);

  // optional .exec.user.SaslSupport sasl_support = 9;
  bool has_sasl_support() const;
  void clear_sasl_support();
  static const int kSaslSupportFieldNumber = 9;
  ::exec::user::SaslSupport sasl_support() const;
  void set_sasl_support(::exec::user::SaslSupport value);

  // optional .exec.shared.RpcChannel channel = 1 [default = USER];
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 1;
  ::exec::shared::RpcChannel channel() const;
  void set_channel(::exec::shared::RpcChannel value);

  // @@protoc_insertion_point(class_scope:exec.user.UserToBitHandshake)
 private:
  void set_has_channel();
  void clear_has_channel();
  void set_has_support_listening();
  void clear_has_support_listening();
  void set_has_rpc_version();
  void clear_has_rpc_version();
  void set_has_credentials();
  void clear_has_credentials();
  void set_has_properties();
  void clear_has_properties();
  void set_has_support_complex_types();
  void clear_has_support_complex_types();
  void set_has_support_timeout();
  void clear_has_support_timeout();
  void set_has_client_infos();
  void clear_has_client_infos();
  void set_has_sasl_support();
  void clear_has_sasl_support();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::exec::shared::UserCredentials* credentials_;
  ::exec::user::UserProperties* properties_;
  ::exec::user::RpcEndpointInfos* client_infos_;
  ::google::protobuf::int32 rpc_version_;
  bool support_listening_;
  bool support_complex_types_;
  bool support_timeout_;
  int sasl_support_;
  int channel_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestResults : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.RequestResults) */ {
 public:
  RequestResults();
  virtual ~RequestResults();

  RequestResults(const RequestResults& from);

  inline RequestResults& operator=(const RequestResults& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestResults(RequestResults&& from) noexcept
    : RequestResults() {
    *this = ::std::move(from);
  }

  inline RequestResults& operator=(RequestResults&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestResults& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestResults* internal_default_instance() {
    return reinterpret_cast<const RequestResults*>(
               &_RequestResults_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RequestResults* other);
  friend void swap(RequestResults& a, RequestResults& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestResults* New() const final {
    return CreateMaybeMessage<RequestResults>(NULL);
  }

  RequestResults* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestResults>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestResults& from);
  void MergeFrom(const RequestResults& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestResults* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.shared.QueryId query_id = 1;
  bool has_query_id() const;
  void clear_query_id();
  static const int kQueryIdFieldNumber = 1;
  private:
  const ::exec::shared::QueryId& _internal_query_id() const;
  public:
  const ::exec::shared::QueryId& query_id() const;
  ::exec::shared::QueryId* release_query_id();
  ::exec::shared::QueryId* mutable_query_id();
  void set_allocated_query_id(::exec::shared::QueryId* query_id);

  // optional int32 maximum_responses = 2;
  bool has_maximum_responses() const;
  void clear_maximum_responses();
  static const int kMaximumResponsesFieldNumber = 2;
  ::google::protobuf::int32 maximum_responses() const;
  void set_maximum_responses(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:exec.user.RequestResults)
 private:
  void set_has_query_id();
  void clear_has_query_id();
  void set_has_maximum_responses();
  void clear_has_maximum_responses();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::exec::shared::QueryId* query_id_;
  ::google::protobuf::int32 maximum_responses_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetQueryPlanFragments : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.GetQueryPlanFragments) */ {
 public:
  GetQueryPlanFragments();
  virtual ~GetQueryPlanFragments();

  GetQueryPlanFragments(const GetQueryPlanFragments& from);

  inline GetQueryPlanFragments& operator=(const GetQueryPlanFragments& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetQueryPlanFragments(GetQueryPlanFragments&& from) noexcept
    : GetQueryPlanFragments() {
    *this = ::std::move(from);
  }

  inline GetQueryPlanFragments& operator=(GetQueryPlanFragments&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetQueryPlanFragments& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetQueryPlanFragments* internal_default_instance() {
    return reinterpret_cast<const GetQueryPlanFragments*>(
               &_GetQueryPlanFragments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(GetQueryPlanFragments* other);
  friend void swap(GetQueryPlanFragments& a, GetQueryPlanFragments& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetQueryPlanFragments* New() const final {
    return CreateMaybeMessage<GetQueryPlanFragments>(NULL);
  }

  GetQueryPlanFragments* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetQueryPlanFragments>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetQueryPlanFragments& from);
  void MergeFrom(const GetQueryPlanFragments& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetQueryPlanFragments* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string query = 1;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 1;
  const ::std::string& query() const;
  void set_query(const ::std::string& value);
  #if LANG_CXX11
  void set_query(::std::string&& value);
  #endif
  void set_query(const char* value);
  void set_query(const char* value, size_t size);
  ::std::string* mutable_query();
  ::std::string* release_query();
  void set_allocated_query(::std::string* query);

  // optional bool split_plan = 3 [default = false];
  bool has_split_plan() const;
  void clear_split_plan();
  static const int kSplitPlanFieldNumber = 3;
  bool split_plan() const;
  void set_split_plan(bool value);

  // optional .exec.shared.QueryType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::exec::shared::QueryType type() const;
  void set_type(::exec::shared::QueryType value);

  // @@protoc_insertion_point(class_scope:exec.user.GetQueryPlanFragments)
 private:
  void set_has_query();
  void clear_has_query();
  void set_has_type();
  void clear_has_type();
  void set_has_split_plan();
  void clear_has_split_plan();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr query_;
  bool split_plan_;
  int type_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryPlanFragments : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.QueryPlanFragments) */ {
 public:
  QueryPlanFragments();
  virtual ~QueryPlanFragments();

  QueryPlanFragments(const QueryPlanFragments& from);

  inline QueryPlanFragments& operator=(const QueryPlanFragments& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryPlanFragments(QueryPlanFragments&& from) noexcept
    : QueryPlanFragments() {
    *this = ::std::move(from);
  }

  inline QueryPlanFragments& operator=(QueryPlanFragments&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryPlanFragments& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueryPlanFragments* internal_default_instance() {
    return reinterpret_cast<const QueryPlanFragments*>(
               &_QueryPlanFragments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(QueryPlanFragments* other);
  friend void swap(QueryPlanFragments& a, QueryPlanFragments& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryPlanFragments* New() const final {
    return CreateMaybeMessage<QueryPlanFragments>(NULL);
  }

  QueryPlanFragments* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<QueryPlanFragments>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const QueryPlanFragments& from);
  void MergeFrom(const QueryPlanFragments& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryPlanFragments* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .exec.bit.control.PlanFragment fragments = 3;
  int fragments_size() const;
  void clear_fragments();
  static const int kFragmentsFieldNumber = 3;
  ::exec::bit::control::PlanFragment* mutable_fragments(int index);
  ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment >*
      mutable_fragments();
  const ::exec::bit::control::PlanFragment& fragments(int index) const;
  ::exec::bit::control::PlanFragment* add_fragments();
  const ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment >&
      fragments() const;

  // optional .exec.shared.QueryId query_id = 2;
  bool has_query_id() const;
  void clear_query_id();
  static const int kQueryIdFieldNumber = 2;
  private:
  const ::exec::shared::QueryId& _internal_query_id() const;
  public:
  const ::exec::shared::QueryId& query_id() const;
  ::exec::shared::QueryId* release_query_id();
  ::exec::shared::QueryId* mutable_query_id();
  void set_allocated_query_id(::exec::shared::QueryId* query_id);

  // optional .exec.shared.DrillPBError error = 4;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 4;
  private:
  const ::exec::shared::DrillPBError& _internal_error() const;
  public:
  const ::exec::shared::DrillPBError& error() const;
  ::exec::shared::DrillPBError* release_error();
  ::exec::shared::DrillPBError* mutable_error();
  void set_allocated_error(::exec::shared::DrillPBError* error);

  // required .exec.shared.QueryResult.QueryState status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::exec::shared::QueryResult_QueryState status() const;
  void set_status(::exec::shared::QueryResult_QueryState value);

  // @@protoc_insertion_point(class_scope:exec.user.QueryPlanFragments)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_query_id();
  void clear_has_query_id();
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment > fragments_;
  ::exec::shared::QueryId* query_id_;
  ::exec::shared::DrillPBError* error_;
  int status_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BitToUserHandshake : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.BitToUserHandshake) */ {
 public:
  BitToUserHandshake();
  virtual ~BitToUserHandshake();

  BitToUserHandshake(const BitToUserHandshake& from);

  inline BitToUserHandshake& operator=(const BitToUserHandshake& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BitToUserHandshake(BitToUserHandshake&& from) noexcept
    : BitToUserHandshake() {
    *this = ::std::move(from);
  }

  inline BitToUserHandshake& operator=(BitToUserHandshake&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BitToUserHandshake& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BitToUserHandshake* internal_default_instance() {
    return reinterpret_cast<const BitToUserHandshake*>(
               &_BitToUserHandshake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(BitToUserHandshake* other);
  friend void swap(BitToUserHandshake& a, BitToUserHandshake& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BitToUserHandshake* New() const final {
    return CreateMaybeMessage<BitToUserHandshake>(NULL);
  }

  BitToUserHandshake* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BitToUserHandshake>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BitToUserHandshake& from);
  void MergeFrom(const BitToUserHandshake& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitToUserHandshake* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string authenticationMechanisms = 7;
  int authenticationmechanisms_size() const;
  void clear_authenticationmechanisms();
  static const int kAuthenticationMechanismsFieldNumber = 7;
  const ::std::string& authenticationmechanisms(int index) const;
  ::std::string* mutable_authenticationmechanisms(int index);
  void set_authenticationmechanisms(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_authenticationmechanisms(int index, ::std::string&& value);
  #endif
  void set_authenticationmechanisms(int index, const char* value);
  void set_authenticationmechanisms(int index, const char* value, size_t size);
  ::std::string* add_authenticationmechanisms();
  void add_authenticationmechanisms(const ::std::string& value);
  #if LANG_CXX11
  void add_authenticationmechanisms(::std::string&& value);
  #endif
  void add_authenticationmechanisms(const char* value);
  void add_authenticationmechanisms(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& authenticationmechanisms() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_authenticationmechanisms();

  // repeated .exec.user.RpcType supported_methods = 8;
  int supported_methods_size() const;
  void clear_supported_methods();
  static const int kSupportedMethodsFieldNumber = 8;
  ::exec::user::RpcType supported_methods(int index) const;
  void set_supported_methods(int index, ::exec::user::RpcType value);
  void add_supported_methods(::exec::user::RpcType value);
  const ::google::protobuf::RepeatedField<int>& supported_methods() const;
  ::google::protobuf::RepeatedField<int>* mutable_supported_methods();

  // optional string errorId = 4;
  bool has_errorid() const;
  void clear_errorid();
  static const int kErrorIdFieldNumber = 4;
  const ::std::string& errorid() const;
  void set_errorid(const ::std::string& value);
  #if LANG_CXX11
  void set_errorid(::std::string&& value);
  #endif
  void set_errorid(const char* value);
  void set_errorid(const char* value, size_t size);
  ::std::string* mutable_errorid();
  ::std::string* release_errorid();
  void set_allocated_errorid(::std::string* errorid);

  // optional string errorMessage = 5;
  bool has_errormessage() const;
  void clear_errormessage();
  static const int kErrorMessageFieldNumber = 5;
  const ::std::string& errormessage() const;
  void set_errormessage(const ::std::string& value);
  #if LANG_CXX11
  void set_errormessage(::std::string&& value);
  #endif
  void set_errormessage(const char* value);
  void set_errormessage(const char* value, size_t size);
  ::std::string* mutable_errormessage();
  ::std::string* release_errormessage();
  void set_allocated_errormessage(::std::string* errormessage);

  // optional .exec.user.RpcEndpointInfos server_infos = 6;
  bool has_server_infos() const;
  void clear_server_infos();
  static const int kServerInfosFieldNumber = 6;
  private:
  const ::exec::user::RpcEndpointInfos& _internal_server_infos() const;
  public:
  const ::exec::user::RpcEndpointInfos& server_infos() const;
  ::exec::user::RpcEndpointInfos* release_server_infos();
  ::exec::user::RpcEndpointInfos* mutable_server_infos();
  void set_allocated_server_infos(::exec::user::RpcEndpointInfos* server_infos);

  // optional int32 rpc_version = 2;
  bool has_rpc_version() const;
  void clear_rpc_version();
  static const int kRpcVersionFieldNumber = 2;
  ::google::protobuf::int32 rpc_version() const;
  void set_rpc_version(::google::protobuf::int32 value);

  // optional bool encrypted = 9;
  bool has_encrypted() const;
  void clear_encrypted();
  static const int kEncryptedFieldNumber = 9;
  bool encrypted() const;
  void set_encrypted(bool value);

  // optional int32 maxWrappedSize = 10;
  bool has_maxwrappedsize() const;
  void clear_maxwrappedsize();
  static const int kMaxWrappedSizeFieldNumber = 10;
  ::google::protobuf::int32 maxwrappedsize() const;
  void set_maxwrappedsize(::google::protobuf::int32 value);

  // optional .exec.user.HandshakeStatus status = 3;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::exec::user::HandshakeStatus status() const;
  void set_status(::exec::user::HandshakeStatus value);

  // @@protoc_insertion_point(class_scope:exec.user.BitToUserHandshake)
 private:
  void set_has_rpc_version();
  void clear_has_rpc_version();
  void set_has_status();
  void clear_has_status();
  void set_has_errorid();
  void clear_has_errorid();
  void set_has_errormessage();
  void clear_has_errormessage();
  void set_has_server_infos();
  void clear_has_server_infos();
  void set_has_encrypted();
  void clear_has_encrypted();
  void set_has_maxwrappedsize();
  void clear_has_maxwrappedsize();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> authenticationmechanisms_;
  ::google::protobuf::RepeatedField<int> supported_methods_;
  ::google::protobuf::internal::ArenaStringPtr errorid_;
  ::google::protobuf::internal::ArenaStringPtr errormessage_;
  ::exec::user::RpcEndpointInfos* server_infos_;
  ::google::protobuf::int32 rpc_version_;
  bool encrypted_;
  ::google::protobuf::int32 maxwrappedsize_;
  int status_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LikeFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.LikeFilter) */ {
 public:
  LikeFilter();
  virtual ~LikeFilter();

  LikeFilter(const LikeFilter& from);

  inline LikeFilter& operator=(const LikeFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LikeFilter(LikeFilter&& from) noexcept
    : LikeFilter() {
    *this = ::std::move(from);
  }

  inline LikeFilter& operator=(LikeFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LikeFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LikeFilter* internal_default_instance() {
    return reinterpret_cast<const LikeFilter*>(
               &_LikeFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(LikeFilter* other);
  friend void swap(LikeFilter& a, LikeFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LikeFilter* New() const final {
    return CreateMaybeMessage<LikeFilter>(NULL);
  }

  LikeFilter* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LikeFilter>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LikeFilter& from);
  void MergeFrom(const LikeFilter& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LikeFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pattern = 1;
  bool has_pattern() const;
  void clear_pattern();
  static const int kPatternFieldNumber = 1;
  const ::std::string& pattern() const;
  void set_pattern(const ::std::string& value);
  #if LANG_CXX11
  void set_pattern(::std::string&& value);
  #endif
  void set_pattern(const char* value);
  void set_pattern(const char* value, size_t size);
  ::std::string* mutable_pattern();
  ::std::string* release_pattern();
  void set_allocated_pattern(::std::string* pattern);

  // optional string escape = 2;
  bool has_escape() const;
  void clear_escape();
  static const int kEscapeFieldNumber = 2;
  const ::std::string& escape() const;
  void set_escape(const ::std::string& value);
  #if LANG_CXX11
  void set_escape(::std::string&& value);
  #endif
  void set_escape(const char* value);
  void set_escape(const char* value, size_t size);
  ::std::string* mutable_escape();
  ::std::string* release_escape();
  void set_allocated_escape(::std::string* escape);

  // @@protoc_insertion_point(class_scope:exec.user.LikeFilter)
 private:
  void set_has_pattern();
  void clear_has_pattern();
  void set_has_escape();
  void clear_has_escape();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr pattern_;
  ::google::protobuf::internal::ArenaStringPtr escape_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetCatalogsReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.GetCatalogsReq) */ {
 public:
  GetCatalogsReq();
  virtual ~GetCatalogsReq();

  GetCatalogsReq(const GetCatalogsReq& from);

  inline GetCatalogsReq& operator=(const GetCatalogsReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetCatalogsReq(GetCatalogsReq&& from) noexcept
    : GetCatalogsReq() {
    *this = ::std::move(from);
  }

  inline GetCatalogsReq& operator=(GetCatalogsReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCatalogsReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetCatalogsReq* internal_default_instance() {
    return reinterpret_cast<const GetCatalogsReq*>(
               &_GetCatalogsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GetCatalogsReq* other);
  friend void swap(GetCatalogsReq& a, GetCatalogsReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetCatalogsReq* New() const final {
    return CreateMaybeMessage<GetCatalogsReq>(NULL);
  }

  GetCatalogsReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetCatalogsReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetCatalogsReq& from);
  void MergeFrom(const GetCatalogsReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCatalogsReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.user.LikeFilter catalog_name_filter = 1;
  bool has_catalog_name_filter() const;
  void clear_catalog_name_filter();
  static const int kCatalogNameFilterFieldNumber = 1;
  private:
  const ::exec::user::LikeFilter& _internal_catalog_name_filter() const;
  public:
  const ::exec::user::LikeFilter& catalog_name_filter() const;
  ::exec::user::LikeFilter* release_catalog_name_filter();
  ::exec::user::LikeFilter* mutable_catalog_name_filter();
  void set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter);

  // @@protoc_insertion_point(class_scope:exec.user.GetCatalogsReq)
 private:
  void set_has_catalog_name_filter();
  void clear_has_catalog_name_filter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::exec::user::LikeFilter* catalog_name_filter_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CatalogMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.CatalogMetadata) */ {
 public:
  CatalogMetadata();
  virtual ~CatalogMetadata();

  CatalogMetadata(const CatalogMetadata& from);

  inline CatalogMetadata& operator=(const CatalogMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CatalogMetadata(CatalogMetadata&& from) noexcept
    : CatalogMetadata() {
    *this = ::std::move(from);
  }

  inline CatalogMetadata& operator=(CatalogMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CatalogMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CatalogMetadata* internal_default_instance() {
    return reinterpret_cast<const CatalogMetadata*>(
               &_CatalogMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CatalogMetadata* other);
  friend void swap(CatalogMetadata& a, CatalogMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CatalogMetadata* New() const final {
    return CreateMaybeMessage<CatalogMetadata>(NULL);
  }

  CatalogMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CatalogMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CatalogMetadata& from);
  void MergeFrom(const CatalogMetadata& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CatalogMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string catalog_name = 1;
  bool has_catalog_name() const;
  void clear_catalog_name();
  static const int kCatalogNameFieldNumber = 1;
  const ::std::string& catalog_name() const;
  void set_catalog_name(const ::std::string& value);
  #if LANG_CXX11
  void set_catalog_name(::std::string&& value);
  #endif
  void set_catalog_name(const char* value);
  void set_catalog_name(const char* value, size_t size);
  ::std::string* mutable_catalog_name();
  ::std::string* release_catalog_name();
  void set_allocated_catalog_name(::std::string* catalog_name);

  // optional string description = 2;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 2;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional string connect = 3;
  bool has_connect() const;
  void clear_connect();
  static const int kConnectFieldNumber = 3;
  const ::std::string& connect() const;
  void set_connect(const ::std::string& value);
  #if LANG_CXX11
  void set_connect(::std::string&& value);
  #endif
  void set_connect(const char* value);
  void set_connect(const char* value, size_t size);
  ::std::string* mutable_connect();
  ::std::string* release_connect();
  void set_allocated_connect(::std::string* connect);

  // @@protoc_insertion_point(class_scope:exec.user.CatalogMetadata)
 private:
  void set_has_catalog_name();
  void clear_has_catalog_name();
  void set_has_description();
  void clear_has_description();
  void set_has_connect();
  void clear_has_connect();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr catalog_name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr connect_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetCatalogsResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.GetCatalogsResp) */ {
 public:
  GetCatalogsResp();
  virtual ~GetCatalogsResp();

  GetCatalogsResp(const GetCatalogsResp& from);

  inline GetCatalogsResp& operator=(const GetCatalogsResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetCatalogsResp(GetCatalogsResp&& from) noexcept
    : GetCatalogsResp() {
    *this = ::std::move(from);
  }

  inline GetCatalogsResp& operator=(GetCatalogsResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCatalogsResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetCatalogsResp* internal_default_instance() {
    return reinterpret_cast<const GetCatalogsResp*>(
               &_GetCatalogsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(GetCatalogsResp* other);
  friend void swap(GetCatalogsResp& a, GetCatalogsResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetCatalogsResp* New() const final {
    return CreateMaybeMessage<GetCatalogsResp>(NULL);
  }

  GetCatalogsResp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetCatalogsResp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetCatalogsResp& from);
  void MergeFrom(const GetCatalogsResp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCatalogsResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .exec.user.CatalogMetadata catalogs = 2;
  int catalogs_size() const;
  void clear_catalogs();
  static const int kCatalogsFieldNumber = 2;
  ::exec::user::CatalogMetadata* mutable_catalogs(int index);
  ::google::protobuf::RepeatedPtrField< ::exec::user::CatalogMetadata >*
      mutable_catalogs();
  const ::exec::user::CatalogMetadata& catalogs(int index) const;
  ::exec::user::CatalogMetadata* add_catalogs();
  const ::google::protobuf::RepeatedPtrField< ::exec::user::CatalogMetadata >&
      catalogs() const;

  // optional .exec.shared.DrillPBError error = 3;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  private:
  const ::exec::shared::DrillPBError& _internal_error() const;
  public:
  const ::exec::shared::DrillPBError& error() const;
  ::exec::shared::DrillPBError* release_error();
  ::exec::shared::DrillPBError* mutable_error();
  void set_allocated_error(::exec::shared::DrillPBError* error);

  // optional .exec.user.RequestStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::exec::user::RequestStatus status() const;
  void set_status(::exec::user::RequestStatus value);

  // @@protoc_insertion_point(class_scope:exec.user.GetCatalogsResp)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::exec::user::CatalogMetadata > catalogs_;
  ::exec::shared::DrillPBError* error_;
  int status_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetSchemasReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.GetSchemasReq) */ {
 public:
  GetSchemasReq();
  virtual ~GetSchemasReq();

  GetSchemasReq(const GetSchemasReq& from);

  inline GetSchemasReq& operator=(const GetSchemasReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSchemasReq(GetSchemasReq&& from) noexcept
    : GetSchemasReq() {
    *this = ::std::move(from);
  }

  inline GetSchemasReq& operator=(GetSchemasReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSchemasReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSchemasReq* internal_default_instance() {
    return reinterpret_cast<const GetSchemasReq*>(
               &_GetSchemasReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(GetSchemasReq* other);
  friend void swap(GetSchemasReq& a, GetSchemasReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSchemasReq* New() const final {
    return CreateMaybeMessage<GetSchemasReq>(NULL);
  }

  GetSchemasReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetSchemasReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetSchemasReq& from);
  void MergeFrom(const GetSchemasReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSchemasReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.user.LikeFilter catalog_name_filter = 1;
  bool has_catalog_name_filter() const;
  void clear_catalog_name_filter();
  static const int kCatalogNameFilterFieldNumber = 1;
  private:
  const ::exec::user::LikeFilter& _internal_catalog_name_filter() const;
  public:
  const ::exec::user::LikeFilter& catalog_name_filter() const;
  ::exec::user::LikeFilter* release_catalog_name_filter();
  ::exec::user::LikeFilter* mutable_catalog_name_filter();
  void set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter);

  // optional .exec.user.LikeFilter schema_name_filter = 2;
  bool has_schema_name_filter() const;
  void clear_schema_name_filter();
  static const int kSchemaNameFilterFieldNumber = 2;
  private:
  const ::exec::user::LikeFilter& _internal_schema_name_filter() const;
  public:
  const ::exec::user::LikeFilter& schema_name_filter() const;
  ::exec::user::LikeFilter* release_schema_name_filter();
  ::exec::user::LikeFilter* mutable_schema_name_filter();
  void set_allocated_schema_name_filter(::exec::user::LikeFilter* schema_name_filter);

  // @@protoc_insertion_point(class_scope:exec.user.GetSchemasReq)
 private:
  void set_has_catalog_name_filter();
  void clear_has_catalog_name_filter();
  void set_has_schema_name_filter();
  void clear_has_schema_name_filter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::exec::user::LikeFilter* catalog_name_filter_;
  ::exec::user::LikeFilter* schema_name_filter_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SchemaMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.SchemaMetadata) */ {
 public:
  SchemaMetadata();
  virtual ~SchemaMetadata();

  SchemaMetadata(const SchemaMetadata& from);

  inline SchemaMetadata& operator=(const SchemaMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SchemaMetadata(SchemaMetadata&& from) noexcept
    : SchemaMetadata() {
    *this = ::std::move(from);
  }

  inline SchemaMetadata& operator=(SchemaMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchemaMetadata* internal_default_instance() {
    return reinterpret_cast<const SchemaMetadata*>(
               &_SchemaMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(SchemaMetadata* other);
  friend void swap(SchemaMetadata& a, SchemaMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SchemaMetadata* New() const final {
    return CreateMaybeMessage<SchemaMetadata>(NULL);
  }

  SchemaMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SchemaMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SchemaMetadata& from);
  void MergeFrom(const SchemaMetadata& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchemaMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string catalog_name = 1;
  bool has_catalog_name() const;
  void clear_catalog_name();
  static const int kCatalogNameFieldNumber = 1;
  const ::std::string& catalog_name() const;
  void set_catalog_name(const ::std::string& value);
  #if LANG_CXX11
  void set_catalog_name(::std::string&& value);
  #endif
  void set_catalog_name(const char* value);
  void set_catalog_name(const char* value, size_t size);
  ::std::string* mutable_catalog_name();
  ::std::string* release_catalog_name();
  void set_allocated_catalog_name(::std::string* catalog_name);

  // optional string schema_name = 2;
  bool has_schema_name() const;
  void clear_schema_name();
  static const int kSchemaNameFieldNumber = 2;
  const ::std::string& schema_name() const;
  void set_schema_name(const ::std::string& value);
  #if LANG_CXX11
  void set_schema_name(::std::string&& value);
  #endif
  void set_schema_name(const char* value);
  void set_schema_name(const char* value, size_t size);
  ::std::string* mutable_schema_name();
  ::std::string* release_schema_name();
  void set_allocated_schema_name(::std::string* schema_name);

  // optional string owner = 3;
  bool has_owner() const;
  void clear_owner();
  static const int kOwnerFieldNumber = 3;
  const ::std::string& owner() const;
  void set_owner(const ::std::string& value);
  #if LANG_CXX11
  void set_owner(::std::string&& value);
  #endif
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  ::std::string* mutable_owner();
  ::std::string* release_owner();
  void set_allocated_owner(::std::string* owner);

  // optional string type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string mutable = 5;
  bool has_mutable_() const;
  void clear_mutable_();
  static const int kMutableFieldNumber = 5;
  const ::std::string& mutable_() const;
  void set_mutable_(const ::std::string& value);
  #if LANG_CXX11
  void set_mutable_(::std::string&& value);
  #endif
  void set_mutable_(const char* value);
  void set_mutable_(const char* value, size_t size);
  ::std::string* mutable_mutable_();
  ::std::string* release_mutable_();
  void set_allocated_mutable_(::std::string* mutable_);

  // @@protoc_insertion_point(class_scope:exec.user.SchemaMetadata)
 private:
  void set_has_catalog_name();
  void clear_has_catalog_name();
  void set_has_schema_name();
  void clear_has_schema_name();
  void set_has_owner();
  void clear_has_owner();
  void set_has_type();
  void clear_has_type();
  void set_has_mutable_();
  void clear_has_mutable_();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr catalog_name_;
  ::google::protobuf::internal::ArenaStringPtr schema_name_;
  ::google::protobuf::internal::ArenaStringPtr owner_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr mutable__;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetSchemasResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.GetSchemasResp) */ {
 public:
  GetSchemasResp();
  virtual ~GetSchemasResp();

  GetSchemasResp(const GetSchemasResp& from);

  inline GetSchemasResp& operator=(const GetSchemasResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSchemasResp(GetSchemasResp&& from) noexcept
    : GetSchemasResp() {
    *this = ::std::move(from);
  }

  inline GetSchemasResp& operator=(GetSchemasResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSchemasResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSchemasResp* internal_default_instance() {
    return reinterpret_cast<const GetSchemasResp*>(
               &_GetSchemasResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(GetSchemasResp* other);
  friend void swap(GetSchemasResp& a, GetSchemasResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSchemasResp* New() const final {
    return CreateMaybeMessage<GetSchemasResp>(NULL);
  }

  GetSchemasResp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetSchemasResp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetSchemasResp& from);
  void MergeFrom(const GetSchemasResp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSchemasResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .exec.user.SchemaMetadata schemas = 2;
  int schemas_size() const;
  void clear_schemas();
  static const int kSchemasFieldNumber = 2;
  ::exec::user::SchemaMetadata* mutable_schemas(int index);
  ::google::protobuf::RepeatedPtrField< ::exec::user::SchemaMetadata >*
      mutable_schemas();
  const ::exec::user::SchemaMetadata& schemas(int index) const;
  ::exec::user::SchemaMetadata* add_schemas();
  const ::google::protobuf::RepeatedPtrField< ::exec::user::SchemaMetadata >&
      schemas() const;

  // optional .exec.shared.DrillPBError error = 3;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  private:
  const ::exec::shared::DrillPBError& _internal_error() const;
  public:
  const ::exec::shared::DrillPBError& error() const;
  ::exec::shared::DrillPBError* release_error();
  ::exec::shared::DrillPBError* mutable_error();
  void set_allocated_error(::exec::shared::DrillPBError* error);

  // optional .exec.user.RequestStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::exec::user::RequestStatus status() const;
  void set_status(::exec::user::RequestStatus value);

  // @@protoc_insertion_point(class_scope:exec.user.GetSchemasResp)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::exec::user::SchemaMetadata > schemas_;
  ::exec::shared::DrillPBError* error_;
  int status_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTablesReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.GetTablesReq) */ {
 public:
  GetTablesReq();
  virtual ~GetTablesReq();

  GetTablesReq(const GetTablesReq& from);

  inline GetTablesReq& operator=(const GetTablesReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTablesReq(GetTablesReq&& from) noexcept
    : GetTablesReq() {
    *this = ::std::move(from);
  }

  inline GetTablesReq& operator=(GetTablesReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTablesReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTablesReq* internal_default_instance() {
    return reinterpret_cast<const GetTablesReq*>(
               &_GetTablesReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(GetTablesReq* other);
  friend void swap(GetTablesReq& a, GetTablesReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTablesReq* New() const final {
    return CreateMaybeMessage<GetTablesReq>(NULL);
  }

  GetTablesReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetTablesReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetTablesReq& from);
  void MergeFrom(const GetTablesReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTablesReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string table_type_filter = 4;
  int table_type_filter_size() const;
  void clear_table_type_filter();
  static const int kTableTypeFilterFieldNumber = 4;
  const ::std::string& table_type_filter(int index) const;
  ::std::string* mutable_table_type_filter(int index);
  void set_table_type_filter(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_table_type_filter(int index, ::std::string&& value);
  #endif
  void set_table_type_filter(int index, const char* value);
  void set_table_type_filter(int index, const char* value, size_t size);
  ::std::string* add_table_type_filter();
  void add_table_type_filter(const ::std::string& value);
  #if LANG_CXX11
  void add_table_type_filter(::std::string&& value);
  #endif
  void add_table_type_filter(const char* value);
  void add_table_type_filter(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& table_type_filter() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_table_type_filter();

  // optional .exec.user.LikeFilter catalog_name_filter = 1;
  bool has_catalog_name_filter() const;
  void clear_catalog_name_filter();
  static const int kCatalogNameFilterFieldNumber = 1;
  private:
  const ::exec::user::LikeFilter& _internal_catalog_name_filter() const;
  public:
  const ::exec::user::LikeFilter& catalog_name_filter() const;
  ::exec::user::LikeFilter* release_catalog_name_filter();
  ::exec::user::LikeFilter* mutable_catalog_name_filter();
  void set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter);

  // optional .exec.user.LikeFilter schema_name_filter = 2;
  bool has_schema_name_filter() const;
  void clear_schema_name_filter();
  static const int kSchemaNameFilterFieldNumber = 2;
  private:
  const ::exec::user::LikeFilter& _internal_schema_name_filter() const;
  public:
  const ::exec::user::LikeFilter& schema_name_filter() const;
  ::exec::user::LikeFilter* release_schema_name_filter();
  ::exec::user::LikeFilter* mutable_schema_name_filter();
  void set_allocated_schema_name_filter(::exec::user::LikeFilter* schema_name_filter);

  // optional .exec.user.LikeFilter table_name_filter = 3;
  bool has_table_name_filter() const;
  void clear_table_name_filter();
  static const int kTableNameFilterFieldNumber = 3;
  private:
  const ::exec::user::LikeFilter& _internal_table_name_filter() const;
  public:
  const ::exec::user::LikeFilter& table_name_filter() const;
  ::exec::user::LikeFilter* release_table_name_filter();
  ::exec::user::LikeFilter* mutable_table_name_filter();
  void set_allocated_table_name_filter(::exec::user::LikeFilter* table_name_filter);

  // @@protoc_insertion_point(class_scope:exec.user.GetTablesReq)
 private:
  void set_has_catalog_name_filter();
  void clear_has_catalog_name_filter();
  void set_has_schema_name_filter();
  void clear_has_schema_name_filter();
  void set_has_table_name_filter();
  void clear_has_table_name_filter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> table_type_filter_;
  ::exec::user::LikeFilter* catalog_name_filter_;
  ::exec::user::LikeFilter* schema_name_filter_;
  ::exec::user::LikeFilter* table_name_filter_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TableMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.TableMetadata) */ {
 public:
  TableMetadata();
  virtual ~TableMetadata();

  TableMetadata(const TableMetadata& from);

  inline TableMetadata& operator=(const TableMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TableMetadata(TableMetadata&& from) noexcept
    : TableMetadata() {
    *this = ::std::move(from);
  }

  inline TableMetadata& operator=(TableMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TableMetadata* internal_default_instance() {
    return reinterpret_cast<const TableMetadata*>(
               &_TableMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(TableMetadata* other);
  friend void swap(TableMetadata& a, TableMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TableMetadata* New() const final {
    return CreateMaybeMessage<TableMetadata>(NULL);
  }

  TableMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TableMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TableMetadata& from);
  void MergeFrom(const TableMetadata& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string catalog_name = 1;
  bool has_catalog_name() const;
  void clear_catalog_name();
  static const int kCatalogNameFieldNumber = 1;
  const ::std::string& catalog_name() const;
  void set_catalog_name(const ::std::string& value);
  #if LANG_CXX11
  void set_catalog_name(::std::string&& value);
  #endif
  void set_catalog_name(const char* value);
  void set_catalog_name(const char* value, size_t size);
  ::std::string* mutable_catalog_name();
  ::std::string* release_catalog_name();
  void set_allocated_catalog_name(::std::string* catalog_name);

  // optional string schema_name = 2;
  bool has_schema_name() const;
  void clear_schema_name();
  static const int kSchemaNameFieldNumber = 2;
  const ::std::string& schema_name() const;
  void set_schema_name(const ::std::string& value);
  #if LANG_CXX11
  void set_schema_name(::std::string&& value);
  #endif
  void set_schema_name(const char* value);
  void set_schema_name(const char* value, size_t size);
  ::std::string* mutable_schema_name();
  ::std::string* release_schema_name();
  void set_allocated_schema_name(::std::string* schema_name);

  // optional string table_name = 3;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 3;
  const ::std::string& table_name() const;
  void set_table_name(const ::std::string& value);
  #if LANG_CXX11
  void set_table_name(::std::string&& value);
  #endif
  void set_table_name(const char* value);
  void set_table_name(const char* value, size_t size);
  ::std::string* mutable_table_name();
  ::std::string* release_table_name();
  void set_allocated_table_name(::std::string* table_name);

  // optional string type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:exec.user.TableMetadata)
 private:
  void set_has_catalog_name();
  void clear_has_catalog_name();
  void set_has_schema_name();
  void clear_has_schema_name();
  void set_has_table_name();
  void clear_has_table_name();
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr catalog_name_;
  ::google::protobuf::internal::ArenaStringPtr schema_name_;
  ::google::protobuf::internal::ArenaStringPtr table_name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTablesResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.GetTablesResp) */ {
 public:
  GetTablesResp();
  virtual ~GetTablesResp();

  GetTablesResp(const GetTablesResp& from);

  inline GetTablesResp& operator=(const GetTablesResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTablesResp(GetTablesResp&& from) noexcept
    : GetTablesResp() {
    *this = ::std::move(from);
  }

  inline GetTablesResp& operator=(GetTablesResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTablesResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTablesResp* internal_default_instance() {
    return reinterpret_cast<const GetTablesResp*>(
               &_GetTablesResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(GetTablesResp* other);
  friend void swap(GetTablesResp& a, GetTablesResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTablesResp* New() const final {
    return CreateMaybeMessage<GetTablesResp>(NULL);
  }

  GetTablesResp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetTablesResp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetTablesResp& from);
  void MergeFrom(const GetTablesResp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTablesResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .exec.user.TableMetadata tables = 2;
  int tables_size() const;
  void clear_tables();
  static const int kTablesFieldNumber = 2;
  ::exec::user::TableMetadata* mutable_tables(int index);
  ::google::protobuf::RepeatedPtrField< ::exec::user::TableMetadata >*
      mutable_tables();
  const ::exec::user::TableMetadata& tables(int index) const;
  ::exec::user::TableMetadata* add_tables();
  const ::google::protobuf::RepeatedPtrField< ::exec::user::TableMetadata >&
      tables() const;

  // optional .exec.shared.DrillPBError error = 3;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  private:
  const ::exec::shared::DrillPBError& _internal_error() const;
  public:
  const ::exec::shared::DrillPBError& error() const;
  ::exec::shared::DrillPBError* release_error();
  ::exec::shared::DrillPBError* mutable_error();
  void set_allocated_error(::exec::shared::DrillPBError* error);

  // optional .exec.user.RequestStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::exec::user::RequestStatus status() const;
  void set_status(::exec::user::RequestStatus value);

  // @@protoc_insertion_point(class_scope:exec.user.GetTablesResp)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::exec::user::TableMetadata > tables_;
  ::exec::shared::DrillPBError* error_;
  int status_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetColumnsReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.GetColumnsReq) */ {
 public:
  GetColumnsReq();
  virtual ~GetColumnsReq();

  GetColumnsReq(const GetColumnsReq& from);

  inline GetColumnsReq& operator=(const GetColumnsReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetColumnsReq(GetColumnsReq&& from) noexcept
    : GetColumnsReq() {
    *this = ::std::move(from);
  }

  inline GetColumnsReq& operator=(GetColumnsReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetColumnsReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetColumnsReq* internal_default_instance() {
    return reinterpret_cast<const GetColumnsReq*>(
               &_GetColumnsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(GetColumnsReq* other);
  friend void swap(GetColumnsReq& a, GetColumnsReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetColumnsReq* New() const final {
    return CreateMaybeMessage<GetColumnsReq>(NULL);
  }

  GetColumnsReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetColumnsReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetColumnsReq& from);
  void MergeFrom(const GetColumnsReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetColumnsReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.user.LikeFilter catalog_name_filter = 1;
  bool has_catalog_name_filter() const;
  void clear_catalog_name_filter();
  static const int kCatalogNameFilterFieldNumber = 1;
  private:
  const ::exec::user::LikeFilter& _internal_catalog_name_filter() const;
  public:
  const ::exec::user::LikeFilter& catalog_name_filter() const;
  ::exec::user::LikeFilter* release_catalog_name_filter();
  ::exec::user::LikeFilter* mutable_catalog_name_filter();
  void set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter);

  // optional .exec.user.LikeFilter schema_name_filter = 2;
  bool has_schema_name_filter() const;
  void clear_schema_name_filter();
  static const int kSchemaNameFilterFieldNumber = 2;
  private:
  const ::exec::user::LikeFilter& _internal_schema_name_filter() const;
  public:
  const ::exec::user::LikeFilter& schema_name_filter() const;
  ::exec::user::LikeFilter* release_schema_name_filter();
  ::exec::user::LikeFilter* mutable_schema_name_filter();
  void set_allocated_schema_name_filter(::exec::user::LikeFilter* schema_name_filter);

  // optional .exec.user.LikeFilter table_name_filter = 3;
  bool has_table_name_filter() const;
  void clear_table_name_filter();
  static const int kTableNameFilterFieldNumber = 3;
  private:
  const ::exec::user::LikeFilter& _internal_table_name_filter() const;
  public:
  const ::exec::user::LikeFilter& table_name_filter() const;
  ::exec::user::LikeFilter* release_table_name_filter();
  ::exec::user::LikeFilter* mutable_table_name_filter();
  void set_allocated_table_name_filter(::exec::user::LikeFilter* table_name_filter);

  // optional .exec.user.LikeFilter column_name_filter = 4;
  bool has_column_name_filter() const;
  void clear_column_name_filter();
  static const int kColumnNameFilterFieldNumber = 4;
  private:
  const ::exec::user::LikeFilter& _internal_column_name_filter() const;
  public:
  const ::exec::user::LikeFilter& column_name_filter() const;
  ::exec::user::LikeFilter* release_column_name_filter();
  ::exec::user::LikeFilter* mutable_column_name_filter();
  void set_allocated_column_name_filter(::exec::user::LikeFilter* column_name_filter);

  // @@protoc_insertion_point(class_scope:exec.user.GetColumnsReq)
 private:
  void set_has_catalog_name_filter();
  void clear_has_catalog_name_filter();
  void set_has_schema_name_filter();
  void clear_has_schema_name_filter();
  void set_has_table_name_filter();
  void clear_has_table_name_filter();
  void set_has_column_name_filter();
  void clear_has_column_name_filter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::exec::user::LikeFilter* catalog_name_filter_;
  ::exec::user::LikeFilter* schema_name_filter_;
  ::exec::user::LikeFilter* table_name_filter_;
  ::exec::user::LikeFilter* column_name_filter_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ColumnMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.ColumnMetadata) */ {
 public:
  ColumnMetadata();
  virtual ~ColumnMetadata();

  ColumnMetadata(const ColumnMetadata& from);

  inline ColumnMetadata& operator=(const ColumnMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ColumnMetadata(ColumnMetadata&& from) noexcept
    : ColumnMetadata() {
    *this = ::std::move(from);
  }

  inline ColumnMetadata& operator=(ColumnMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColumnMetadata* internal_default_instance() {
    return reinterpret_cast<const ColumnMetadata*>(
               &_ColumnMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ColumnMetadata* other);
  friend void swap(ColumnMetadata& a, ColumnMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ColumnMetadata* New() const final {
    return CreateMaybeMessage<ColumnMetadata>(NULL);
  }

  ColumnMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ColumnMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ColumnMetadata& from);
  void MergeFrom(const ColumnMetadata& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string catalog_name = 1;
  bool has_catalog_name() const;
  void clear_catalog_name();
  static const int kCatalogNameFieldNumber = 1;
  const ::std::string& catalog_name() const;
  void set_catalog_name(const ::std::string& value);
  #if LANG_CXX11
  void set_catalog_name(::std::string&& value);
  #endif
  void set_catalog_name(const char* value);
  void set_catalog_name(const char* value, size_t size);
  ::std::string* mutable_catalog_name();
  ::std::string* release_catalog_name();
  void set_allocated_catalog_name(::std::string* catalog_name);

  // optional string schema_name = 2;
  bool has_schema_name() const;
  void clear_schema_name();
  static const int kSchemaNameFieldNumber = 2;
  const ::std::string& schema_name() const;
  void set_schema_name(const ::std::string& value);
  #if LANG_CXX11
  void set_schema_name(::std::string&& value);
  #endif
  void set_schema_name(const char* value);
  void set_schema_name(const char* value, size_t size);
  ::std::string* mutable_schema_name();
  ::std::string* release_schema_name();
  void set_allocated_schema_name(::std::string* schema_name);

  // optional string table_name = 3;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 3;
  const ::std::string& table_name() const;
  void set_table_name(const ::std::string& value);
  #if LANG_CXX11
  void set_table_name(::std::string&& value);
  #endif
  void set_table_name(const char* value);
  void set_table_name(const char* value, size_t size);
  ::std::string* mutable_table_name();
  ::std::string* release_table_name();
  void set_allocated_table_name(::std::string* table_name);

  // optional string column_name = 4;
  bool has_column_name() const;
  void clear_column_name();
  static const int kColumnNameFieldNumber = 4;
  const ::std::string& column_name() const;
  void set_column_name(const ::std::string& value);
  #if LANG_CXX11
  void set_column_name(::std::string&& value);
  #endif
  void set_column_name(const char* value);
  void set_column_name(const char* value, size_t size);
  ::std::string* mutable_column_name();
  ::std::string* release_column_name();
  void set_allocated_column_name(::std::string* column_name);

  // optional string default_value = 6;
  bool has_default_value() const;
  void clear_default_value();
  static const int kDefaultValueFieldNumber = 6;
  const ::std::string& default_value() const;
  void set_default_value(const ::std::string& value);
  #if LANG_CXX11
  void set_default_value(::std::string&& value);
  #endif
  void set_default_value(const char* value);
  void set_default_value(const char* value, size_t size);
  ::std::string* mutable_default_value();
  ::std::string* release_default_value();
  void set_allocated_default_value(::std::string* default_value);

  // optional string data_type = 8;
  bool has_data_type() const;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 8;
  const ::std::string& data_type() const;
  void set_data_type(const ::std::string& value);
  #if LANG_CXX11
  void set_data_type(::std::string&& value);
  #endif
  void set_data_type(const char* value);
  void set_data_type(const char* value, size_t size);
  ::std::string* mutable_data_type();
  ::std::string* release_data_type();
  void set_allocated_data_type(::std::string* data_type);

  // optional string interval_type = 15;
  bool has_interval_type() const;
  void clear_interval_type();
  static const int kIntervalTypeFieldNumber = 15;
  const ::std::string& interval_type() const;
  void set_interval_type(const ::std::string& value);
  #if LANG_CXX11
  void set_interval_type(::std::string&& value);
  #endif
  void set_interval_type(const char* value);
  void set_interval_type(const char* value, size_t size);
  ::std::string* mutable_interval_type();
  ::std::string* release_interval_type();
  void set_allocated_interval_type(::std::string* interval_type);

  // optional int32 ordinal_position = 5;
  bool has_ordinal_position() const;
  void clear_ordinal_position();
  static const int kOrdinalPositionFieldNumber = 5;
  ::google::protobuf::int32 ordinal_position() const;
  void set_ordinal_position(::google::protobuf::int32 value);

  // optional bool is_nullable = 7;
  bool has_is_nullable() const;
  void clear_is_nullable();
  static const int kIsNullableFieldNumber = 7;
  bool is_nullable() const;
  void set_is_nullable(bool value);

  // optional int32 char_max_length = 9;
  bool has_char_max_length() const;
  void clear_char_max_length();
  static const int kCharMaxLengthFieldNumber = 9;
  ::google::protobuf::int32 char_max_length() const;
  void set_char_max_length(::google::protobuf::int32 value);

  // optional int32 char_octet_length = 10;
  bool has_char_octet_length() const;
  void clear_char_octet_length();
  static const int kCharOctetLengthFieldNumber = 10;
  ::google::protobuf::int32 char_octet_length() const;
  void set_char_octet_length(::google::protobuf::int32 value);

  // optional int32 numeric_precision = 11;
  bool has_numeric_precision() const;
  void clear_numeric_precision();
  static const int kNumericPrecisionFieldNumber = 11;
  ::google::protobuf::int32 numeric_precision() const;
  void set_numeric_precision(::google::protobuf::int32 value);

  // optional int32 numeric_precision_radix = 12;
  bool has_numeric_precision_radix() const;
  void clear_numeric_precision_radix();
  static const int kNumericPrecisionRadixFieldNumber = 12;
  ::google::protobuf::int32 numeric_precision_radix() const;
  void set_numeric_precision_radix(::google::protobuf::int32 value);

  // optional int32 numeric_scale = 13;
  bool has_numeric_scale() const;
  void clear_numeric_scale();
  static const int kNumericScaleFieldNumber = 13;
  ::google::protobuf::int32 numeric_scale() const;
  void set_numeric_scale(::google::protobuf::int32 value);

  // optional int32 date_time_precision = 14;
  bool has_date_time_precision() const;
  void clear_date_time_precision();
  static const int kDateTimePrecisionFieldNumber = 14;
  ::google::protobuf::int32 date_time_precision() const;
  void set_date_time_precision(::google::protobuf::int32 value);

  // optional int32 interval_precision = 16;
  bool has_interval_precision() const;
  void clear_interval_precision();
  static const int kIntervalPrecisionFieldNumber = 16;
  ::google::protobuf::int32 interval_precision() const;
  void set_interval_precision(::google::protobuf::int32 value);

  // optional int32 column_size = 17;
  bool has_column_size() const;
  void clear_column_size();
  static const int kColumnSizeFieldNumber = 17;
  ::google::protobuf::int32 column_size() const;
  void set_column_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:exec.user.ColumnMetadata)
 private:
  void set_has_catalog_name();
  void clear_has_catalog_name();
  void set_has_schema_name();
  void clear_has_schema_name();
  void set_has_table_name();
  void clear_has_table_name();
  void set_has_column_name();
  void clear_has_column_name();
  void set_has_ordinal_position();
  void clear_has_ordinal_position();
  void set_has_default_value();
  void clear_has_default_value();
  void set_has_is_nullable();
  void clear_has_is_nullable();
  void set_has_data_type();
  void clear_has_data_type();
  void set_has_char_max_length();
  void clear_has_char_max_length();
  void set_has_char_octet_length();
  void clear_has_char_octet_length();
  void set_has_numeric_precision();
  void clear_has_numeric_precision();
  void set_has_numeric_precision_radix();
  void clear_has_numeric_precision_radix();
  void set_has_numeric_scale();
  void clear_has_numeric_scale();
  void set_has_date_time_precision();
  void clear_has_date_time_precision();
  void set_has_interval_type();
  void clear_has_interval_type();
  void set_has_interval_precision();
  void clear_has_interval_precision();
  void set_has_column_size();
  void clear_has_column_size();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr catalog_name_;
  ::google::protobuf::internal::ArenaStringPtr schema_name_;
  ::google::protobuf::internal::ArenaStringPtr table_name_;
  ::google::protobuf::internal::ArenaStringPtr column_name_;
  ::google::protobuf::internal::ArenaStringPtr default_value_;
  ::google::protobuf::internal::ArenaStringPtr data_type_;
  ::google::protobuf::internal::ArenaStringPtr interval_type_;
  ::google::protobuf::int32 ordinal_position_;
  bool is_nullable_;
  ::google::protobuf::int32 char_max_length_;
  ::google::protobuf::int32 char_octet_length_;
  ::google::protobuf::int32 numeric_precision_;
  ::google::protobuf::int32 numeric_precision_radix_;
  ::google::protobuf::int32 numeric_scale_;
  ::google::protobuf::int32 date_time_precision_;
  ::google::protobuf::int32 interval_precision_;
  ::google::protobuf::int32 column_size_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetColumnsResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.GetColumnsResp) */ {
 public:
  GetColumnsResp();
  virtual ~GetColumnsResp();

  GetColumnsResp(const GetColumnsResp& from);

  inline GetColumnsResp& operator=(const GetColumnsResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetColumnsResp(GetColumnsResp&& from) noexcept
    : GetColumnsResp() {
    *this = ::std::move(from);
  }

  inline GetColumnsResp& operator=(GetColumnsResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetColumnsResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetColumnsResp* internal_default_instance() {
    return reinterpret_cast<const GetColumnsResp*>(
               &_GetColumnsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(GetColumnsResp* other);
  friend void swap(GetColumnsResp& a, GetColumnsResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetColumnsResp* New() const final {
    return CreateMaybeMessage<GetColumnsResp>(NULL);
  }

  GetColumnsResp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetColumnsResp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetColumnsResp& from);
  void MergeFrom(const GetColumnsResp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetColumnsResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .exec.user.ColumnMetadata columns = 2;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 2;
  ::exec::user::ColumnMetadata* mutable_columns(int index);
  ::google::protobuf::RepeatedPtrField< ::exec::user::ColumnMetadata >*
      mutable_columns();
  const ::exec::user::ColumnMetadata& columns(int index) const;
  ::exec::user::ColumnMetadata* add_columns();
  const ::google::protobuf::RepeatedPtrField< ::exec::user::ColumnMetadata >&
      columns() const;

  // optional .exec.shared.DrillPBError error = 3;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  private:
  const ::exec::shared::DrillPBError& _internal_error() const;
  public:
  const ::exec::shared::DrillPBError& error() const;
  ::exec::shared::DrillPBError* release_error();
  ::exec::shared::DrillPBError* mutable_error();
  void set_allocated_error(::exec::shared::DrillPBError* error);

  // optional .exec.user.RequestStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::exec::user::RequestStatus status() const;
  void set_status(::exec::user::RequestStatus value);

  // @@protoc_insertion_point(class_scope:exec.user.GetColumnsResp)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::exec::user::ColumnMetadata > columns_;
  ::exec::shared::DrillPBError* error_;
  int status_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreatePreparedStatementReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.CreatePreparedStatementReq) */ {
 public:
  CreatePreparedStatementReq();
  virtual ~CreatePreparedStatementReq();

  CreatePreparedStatementReq(const CreatePreparedStatementReq& from);

  inline CreatePreparedStatementReq& operator=(const CreatePreparedStatementReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreatePreparedStatementReq(CreatePreparedStatementReq&& from) noexcept
    : CreatePreparedStatementReq() {
    *this = ::std::move(from);
  }

  inline CreatePreparedStatementReq& operator=(CreatePreparedStatementReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreatePreparedStatementReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreatePreparedStatementReq* internal_default_instance() {
    return reinterpret_cast<const CreatePreparedStatementReq*>(
               &_CreatePreparedStatementReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(CreatePreparedStatementReq* other);
  friend void swap(CreatePreparedStatementReq& a, CreatePreparedStatementReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreatePreparedStatementReq* New() const final {
    return CreateMaybeMessage<CreatePreparedStatementReq>(NULL);
  }

  CreatePreparedStatementReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreatePreparedStatementReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreatePreparedStatementReq& from);
  void MergeFrom(const CreatePreparedStatementReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatePreparedStatementReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sql_query = 1;
  bool has_sql_query() const;
  void clear_sql_query();
  static const int kSqlQueryFieldNumber = 1;
  const ::std::string& sql_query() const;
  void set_sql_query(const ::std::string& value);
  #if LANG_CXX11
  void set_sql_query(::std::string&& value);
  #endif
  void set_sql_query(const char* value);
  void set_sql_query(const char* value, size_t size);
  ::std::string* mutable_sql_query();
  ::std::string* release_sql_query();
  void set_allocated_sql_query(::std::string* sql_query);

  // @@protoc_insertion_point(class_scope:exec.user.CreatePreparedStatementReq)
 private:
  void set_has_sql_query();
  void clear_has_sql_query();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sql_query_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResultColumnMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.ResultColumnMetadata) */ {
 public:
  ResultColumnMetadata();
  virtual ~ResultColumnMetadata();

  ResultColumnMetadata(const ResultColumnMetadata& from);

  inline ResultColumnMetadata& operator=(const ResultColumnMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResultColumnMetadata(ResultColumnMetadata&& from) noexcept
    : ResultColumnMetadata() {
    *this = ::std::move(from);
  }

  inline ResultColumnMetadata& operator=(ResultColumnMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultColumnMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResultColumnMetadata* internal_default_instance() {
    return reinterpret_cast<const ResultColumnMetadata*>(
               &_ResultColumnMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(ResultColumnMetadata* other);
  friend void swap(ResultColumnMetadata& a, ResultColumnMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResultColumnMetadata* New() const final {
    return CreateMaybeMessage<ResultColumnMetadata>(NULL);
  }

  ResultColumnMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResultColumnMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResultColumnMetadata& from);
  void MergeFrom(const ResultColumnMetadata& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResultColumnMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string catalog_name = 1;
  bool has_catalog_name() const;
  void clear_catalog_name();
  static const int kCatalogNameFieldNumber = 1;
  const ::std::string& catalog_name() const;
  void set_catalog_name(const ::std::string& value);
  #if LANG_CXX11
  void set_catalog_name(::std::string&& value);
  #endif
  void set_catalog_name(const char* value);
  void set_catalog_name(const char* value, size_t size);
  ::std::string* mutable_catalog_name();
  ::std::string* release_catalog_name();
  void set_allocated_catalog_name(::std::string* catalog_name);

  // optional string schema_name = 2;
  bool has_schema_name() const;
  void clear_schema_name();
  static const int kSchemaNameFieldNumber = 2;
  const ::std::string& schema_name() const;
  void set_schema_name(const ::std::string& value);
  #if LANG_CXX11
  void set_schema_name(::std::string&& value);
  #endif
  void set_schema_name(const char* value);
  void set_schema_name(const char* value, size_t size);
  ::std::string* mutable_schema_name();
  ::std::string* release_schema_name();
  void set_allocated_schema_name(::std::string* schema_name);

  // optional string table_name = 3;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 3;
  const ::std::string& table_name() const;
  void set_table_name(const ::std::string& value);
  #if LANG_CXX11
  void set_table_name(::std::string&& value);
  #endif
  void set_table_name(const char* value);
  void set_table_name(const char* value, size_t size);
  ::std::string* mutable_table_name();
  ::std::string* release_table_name();
  void set_allocated_table_name(::std::string* table_name);

  // optional string column_name = 4;
  bool has_column_name() const;
  void clear_column_name();
  static const int kColumnNameFieldNumber = 4;
  const ::std::string& column_name() const;
  void set_column_name(const ::std::string& value);
  #if LANG_CXX11
  void set_column_name(::std::string&& value);
  #endif
  void set_column_name(const char* value);
  void set_column_name(const char* value, size_t size);
  ::std::string* mutable_column_name();
  ::std::string* release_column_name();
  void set_allocated_column_name(::std::string* column_name);

  // optional string label = 5;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 5;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // optional string data_type = 6;
  bool has_data_type() const;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 6;
  const ::std::string& data_type() const;
  void set_data_type(const ::std::string& value);
  #if LANG_CXX11
  void set_data_type(::std::string&& value);
  #endif
  void set_data_type(const char* value);
  void set_data_type(const char* value, size_t size);
  ::std::string* mutable_data_type();
  ::std::string* release_data_type();
  void set_allocated_data_type(::std::string* data_type);

  // optional string class_name = 18;
  bool has_class_name() const;
  void clear_class_name();
  static const int kClassNameFieldNumber = 18;
  const ::std::string& class_name() const;
  void set_class_name(const ::std::string& value);
  #if LANG_CXX11
  void set_class_name(::std::string&& value);
  #endif
  void set_class_name(const char* value);
  void set_class_name(const char* value, size_t size);
  ::std::string* mutable_class_name();
  ::std::string* release_class_name();
  void set_allocated_class_name(::std::string* class_name);

  // optional int32 precision = 8;
  bool has_precision() const;
  void clear_precision();
  static const int kPrecisionFieldNumber = 8;
  ::google::protobuf::int32 precision() const;
  void set_precision(::google::protobuf::int32 value);

  // optional int32 scale = 9;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 9;
  ::google::protobuf::int32 scale() const;
  void set_scale(::google::protobuf::int32 value);

  // optional int32 display_size = 11;
  bool has_display_size() const;
  void clear_display_size();
  static const int kDisplaySizeFieldNumber = 11;
  ::google::protobuf::int32 display_size() const;
  void set_display_size(::google::protobuf::int32 value);

  // optional bool is_nullable = 7;
  bool has_is_nullable() const;
  void clear_is_nullable();
  static const int kIsNullableFieldNumber = 7;
  bool is_nullable() const;
  void set_is_nullable(bool value);

  // optional bool signed = 10;
  bool has_signed_() const;
  void clear_signed_();
  static const int kSignedFieldNumber = 10;
  bool signed_() const;
  void set_signed_(bool value);

  // optional bool is_aliased = 12;
  bool has_is_aliased() const;
  void clear_is_aliased();
  static const int kIsAliasedFieldNumber = 12;
  bool is_aliased() const;
  void set_is_aliased(bool value);

  // optional bool auto_increment = 15;
  bool has_auto_increment() const;
  void clear_auto_increment();
  static const int kAutoIncrementFieldNumber = 15;
  bool auto_increment() const;
  void set_auto_increment(bool value);

  // optional .exec.user.ColumnSearchability searchability = 13;
  bool has_searchability() const;
  void clear_searchability();
  static const int kSearchabilityFieldNumber = 13;
  ::exec::user::ColumnSearchability searchability() const;
  void set_searchability(::exec::user::ColumnSearchability value);

  // optional .exec.user.ColumnUpdatability updatability = 14;
  bool has_updatability() const;
  void clear_updatability();
  static const int kUpdatabilityFieldNumber = 14;
  ::exec::user::ColumnUpdatability updatability() const;
  void set_updatability(::exec::user::ColumnUpdatability value);

  // optional bool case_sensitivity = 16;
  bool has_case_sensitivity() const;
  void clear_case_sensitivity();
  static const int kCaseSensitivityFieldNumber = 16;
  bool case_sensitivity() const;
  void set_case_sensitivity(bool value);

  // optional bool sortable = 17;
  bool has_sortable() const;
  void clear_sortable();
  static const int kSortableFieldNumber = 17;
  bool sortable() const;
  void set_sortable(bool value);

  // optional bool is_currency = 20;
  bool has_is_currency() const;
  void clear_is_currency();
  static const int kIsCurrencyFieldNumber = 20;
  bool is_currency() const;
  void set_is_currency(bool value);

  // @@protoc_insertion_point(class_scope:exec.user.ResultColumnMetadata)
 private:
  void set_has_catalog_name();
  void clear_has_catalog_name();
  void set_has_schema_name();
  void clear_has_schema_name();
  void set_has_table_name();
  void clear_has_table_name();
  void set_has_column_name();
  void clear_has_column_name();
  void set_has_label();
  void clear_has_label();
  void set_has_data_type();
  void clear_has_data_type();
  void set_has_is_nullable();
  void clear_has_is_nullable();
  void set_has_precision();
  void clear_has_precision();
  void set_has_scale();
  void clear_has_scale();
  void set_has_signed_();
  void clear_has_signed_();
  void set_has_display_size();
  void clear_has_display_size();
  void set_has_is_aliased();
  void clear_has_is_aliased();
  void set_has_searchability();
  void clear_has_searchability();
  void set_has_updatability();
  void clear_has_updatability();
  void set_has_auto_increment();
  void clear_has_auto_increment();
  void set_has_case_sensitivity();
  void clear_has_case_sensitivity();
  void set_has_sortable();
  void clear_has_sortable();
  void set_has_class_name();
  void clear_has_class_name();
  void set_has_is_currency();
  void clear_has_is_currency();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr catalog_name_;
  ::google::protobuf::internal::ArenaStringPtr schema_name_;
  ::google::protobuf::internal::ArenaStringPtr table_name_;
  ::google::protobuf::internal::ArenaStringPtr column_name_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::internal::ArenaStringPtr data_type_;
  ::google::protobuf::internal::ArenaStringPtr class_name_;
  ::google::protobuf::int32 precision_;
  ::google::protobuf::int32 scale_;
  ::google::protobuf::int32 display_size_;
  bool is_nullable_;
  bool signed__;
  bool is_aliased_;
  bool auto_increment_;
  int searchability_;
  int updatability_;
  bool case_sensitivity_;
  bool sortable_;
  bool is_currency_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PreparedStatementHandle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.PreparedStatementHandle) */ {
 public:
  PreparedStatementHandle();
  virtual ~PreparedStatementHandle();

  PreparedStatementHandle(const PreparedStatementHandle& from);

  inline PreparedStatementHandle& operator=(const PreparedStatementHandle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PreparedStatementHandle(PreparedStatementHandle&& from) noexcept
    : PreparedStatementHandle() {
    *this = ::std::move(from);
  }

  inline PreparedStatementHandle& operator=(PreparedStatementHandle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PreparedStatementHandle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PreparedStatementHandle* internal_default_instance() {
    return reinterpret_cast<const PreparedStatementHandle*>(
               &_PreparedStatementHandle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(PreparedStatementHandle* other);
  friend void swap(PreparedStatementHandle& a, PreparedStatementHandle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PreparedStatementHandle* New() const final {
    return CreateMaybeMessage<PreparedStatementHandle>(NULL);
  }

  PreparedStatementHandle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PreparedStatementHandle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PreparedStatementHandle& from);
  void MergeFrom(const PreparedStatementHandle& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PreparedStatementHandle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes server_info = 1;
  bool has_server_info() const;
  void clear_server_info();
  static const int kServerInfoFieldNumber = 1;
  const ::std::string& server_info() const;
  void set_server_info(const ::std::string& value);
  #if LANG_CXX11
  void set_server_info(::std::string&& value);
  #endif
  void set_server_info(const char* value);
  void set_server_info(const void* value, size_t size);
  ::std::string* mutable_server_info();
  ::std::string* release_server_info();
  void set_allocated_server_info(::std::string* server_info);

  // @@protoc_insertion_point(class_scope:exec.user.PreparedStatementHandle)
 private:
  void set_has_server_info();
  void clear_has_server_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr server_info_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PreparedStatement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.PreparedStatement) */ {
 public:
  PreparedStatement();
  virtual ~PreparedStatement();

  PreparedStatement(const PreparedStatement& from);

  inline PreparedStatement& operator=(const PreparedStatement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PreparedStatement(PreparedStatement&& from) noexcept
    : PreparedStatement() {
    *this = ::std::move(from);
  }

  inline PreparedStatement& operator=(PreparedStatement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PreparedStatement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PreparedStatement* internal_default_instance() {
    return reinterpret_cast<const PreparedStatement*>(
               &_PreparedStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(PreparedStatement* other);
  friend void swap(PreparedStatement& a, PreparedStatement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PreparedStatement* New() const final {
    return CreateMaybeMessage<PreparedStatement>(NULL);
  }

  PreparedStatement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PreparedStatement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PreparedStatement& from);
  void MergeFrom(const PreparedStatement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PreparedStatement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .exec.user.ResultColumnMetadata columns = 1;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 1;
  ::exec::user::ResultColumnMetadata* mutable_columns(int index);
  ::google::protobuf::RepeatedPtrField< ::exec::user::ResultColumnMetadata >*
      mutable_columns();
  const ::exec::user::ResultColumnMetadata& columns(int index) const;
  ::exec::user::ResultColumnMetadata* add_columns();
  const ::google::protobuf::RepeatedPtrField< ::exec::user::ResultColumnMetadata >&
      columns() const;

  // optional .exec.user.PreparedStatementHandle server_handle = 2;
  bool has_server_handle() const;
  void clear_server_handle();
  static const int kServerHandleFieldNumber = 2;
  private:
  const ::exec::user::PreparedStatementHandle& _internal_server_handle() const;
  public:
  const ::exec::user::PreparedStatementHandle& server_handle() const;
  ::exec::user::PreparedStatementHandle* release_server_handle();
  ::exec::user::PreparedStatementHandle* mutable_server_handle();
  void set_allocated_server_handle(::exec::user::PreparedStatementHandle* server_handle);

  // @@protoc_insertion_point(class_scope:exec.user.PreparedStatement)
 private:
  void set_has_server_handle();
  void clear_has_server_handle();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::exec::user::ResultColumnMetadata > columns_;
  ::exec::user::PreparedStatementHandle* server_handle_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreatePreparedStatementResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.CreatePreparedStatementResp) */ {
 public:
  CreatePreparedStatementResp();
  virtual ~CreatePreparedStatementResp();

  CreatePreparedStatementResp(const CreatePreparedStatementResp& from);

  inline CreatePreparedStatementResp& operator=(const CreatePreparedStatementResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreatePreparedStatementResp(CreatePreparedStatementResp&& from) noexcept
    : CreatePreparedStatementResp() {
    *this = ::std::move(from);
  }

  inline CreatePreparedStatementResp& operator=(CreatePreparedStatementResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreatePreparedStatementResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreatePreparedStatementResp* internal_default_instance() {
    return reinterpret_cast<const CreatePreparedStatementResp*>(
               &_CreatePreparedStatementResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(CreatePreparedStatementResp* other);
  friend void swap(CreatePreparedStatementResp& a, CreatePreparedStatementResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreatePreparedStatementResp* New() const final {
    return CreateMaybeMessage<CreatePreparedStatementResp>(NULL);
  }

  CreatePreparedStatementResp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreatePreparedStatementResp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreatePreparedStatementResp& from);
  void MergeFrom(const CreatePreparedStatementResp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatePreparedStatementResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.user.PreparedStatement prepared_statement = 2;
  bool has_prepared_statement() const;
  void clear_prepared_statement();
  static const int kPreparedStatementFieldNumber = 2;
  private:
  const ::exec::user::PreparedStatement& _internal_prepared_statement() const;
  public:
  const ::exec::user::PreparedStatement& prepared_statement() const;
  ::exec::user::PreparedStatement* release_prepared_statement();
  ::exec::user::PreparedStatement* mutable_prepared_statement();
  void set_allocated_prepared_statement(::exec::user::PreparedStatement* prepared_statement);

  // optional .exec.shared.DrillPBError error = 3;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  private:
  const ::exec::shared::DrillPBError& _internal_error() const;
  public:
  const ::exec::shared::DrillPBError& error() const;
  ::exec::shared::DrillPBError* release_error();
  ::exec::shared::DrillPBError* mutable_error();
  void set_allocated_error(::exec::shared::DrillPBError* error);

  // optional .exec.user.RequestStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::exec::user::RequestStatus status() const;
  void set_status(::exec::user::RequestStatus value);

  // @@protoc_insertion_point(class_scope:exec.user.CreatePreparedStatementResp)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_prepared_statement();
  void clear_has_prepared_statement();
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::exec::user::PreparedStatement* prepared_statement_;
  ::exec::shared::DrillPBError* error_;
  int status_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetServerMetaReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.GetServerMetaReq) */ {
 public:
  GetServerMetaReq();
  virtual ~GetServerMetaReq();

  GetServerMetaReq(const GetServerMetaReq& from);

  inline GetServerMetaReq& operator=(const GetServerMetaReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetServerMetaReq(GetServerMetaReq&& from) noexcept
    : GetServerMetaReq() {
    *this = ::std::move(from);
  }

  inline GetServerMetaReq& operator=(GetServerMetaReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetServerMetaReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetServerMetaReq* internal_default_instance() {
    return reinterpret_cast<const GetServerMetaReq*>(
               &_GetServerMetaReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(GetServerMetaReq* other);
  friend void swap(GetServerMetaReq& a, GetServerMetaReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetServerMetaReq* New() const final {
    return CreateMaybeMessage<GetServerMetaReq>(NULL);
  }

  GetServerMetaReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetServerMetaReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetServerMetaReq& from);
  void MergeFrom(const GetServerMetaReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetServerMetaReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:exec.user.GetServerMetaReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConvertSupport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.ConvertSupport) */ {
 public:
  ConvertSupport();
  virtual ~ConvertSupport();

  ConvertSupport(const ConvertSupport& from);

  inline ConvertSupport& operator=(const ConvertSupport& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConvertSupport(ConvertSupport&& from) noexcept
    : ConvertSupport() {
    *this = ::std::move(from);
  }

  inline ConvertSupport& operator=(ConvertSupport&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConvertSupport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConvertSupport* internal_default_instance() {
    return reinterpret_cast<const ConvertSupport*>(
               &_ConvertSupport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(ConvertSupport* other);
  friend void swap(ConvertSupport& a, ConvertSupport& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConvertSupport* New() const final {
    return CreateMaybeMessage<ConvertSupport>(NULL);
  }

  ConvertSupport* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConvertSupport>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConvertSupport& from);
  void MergeFrom(const ConvertSupport& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConvertSupport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.MinorType from = 1;
  bool has_from() const;
  void clear_from();
  static const int kFromFieldNumber = 1;
  ::common::MinorType from() const;
  void set_from(::common::MinorType value);

  // required .common.MinorType to = 2;
  bool has_to() const;
  void clear_to();
  static const int kToFieldNumber = 2;
  ::common::MinorType to() const;
  void set_to(::common::MinorType value);

  // @@protoc_insertion_point(class_scope:exec.user.ConvertSupport)
 private:
  void set_has_from();
  void clear_has_from();
  void set_has_to();
  void clear_has_to();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int from_;
  int to_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetServerMetaResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.GetServerMetaResp) */ {
 public:
  GetServerMetaResp();
  virtual ~GetServerMetaResp();

  GetServerMetaResp(const GetServerMetaResp& from);

  inline GetServerMetaResp& operator=(const GetServerMetaResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetServerMetaResp(GetServerMetaResp&& from) noexcept
    : GetServerMetaResp() {
    *this = ::std::move(from);
  }

  inline GetServerMetaResp& operator=(GetServerMetaResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetServerMetaResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetServerMetaResp* internal_default_instance() {
    return reinterpret_cast<const GetServerMetaResp*>(
               &_GetServerMetaResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(GetServerMetaResp* other);
  friend void swap(GetServerMetaResp& a, GetServerMetaResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetServerMetaResp* New() const final {
    return CreateMaybeMessage<GetServerMetaResp>(NULL);
  }

  GetServerMetaResp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetServerMetaResp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetServerMetaResp& from);
  void MergeFrom(const GetServerMetaResp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetServerMetaResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.user.ServerMeta server_meta = 2;
  bool has_server_meta() const;
  void clear_server_meta();
  static const int kServerMetaFieldNumber = 2;
  private:
  const ::exec::user::ServerMeta& _internal_server_meta() const;
  public:
  const ::exec::user::ServerMeta& server_meta() const;
  ::exec::user::ServerMeta* release_server_meta();
  ::exec::user::ServerMeta* mutable_server_meta();
  void set_allocated_server_meta(::exec::user::ServerMeta* server_meta);

  // optional .exec.shared.DrillPBError error = 3;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  private:
  const ::exec::shared::DrillPBError& _internal_error() const;
  public:
  const ::exec::shared::DrillPBError& error() const;
  ::exec::shared::DrillPBError* release_error();
  ::exec::shared::DrillPBError* mutable_error();
  void set_allocated_error(::exec::shared::DrillPBError* error);

  // optional .exec.user.RequestStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::exec::user::RequestStatus status() const;
  void set_status(::exec::user::RequestStatus value);

  // @@protoc_insertion_point(class_scope:exec.user.GetServerMetaResp)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_server_meta();
  void clear_has_server_meta();
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::exec::user::ServerMeta* server_meta_;
  ::exec::shared::DrillPBError* error_;
  int status_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerMeta : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.ServerMeta) */ {
 public:
  ServerMeta();
  virtual ~ServerMeta();

  ServerMeta(const ServerMeta& from);

  inline ServerMeta& operator=(const ServerMeta& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerMeta(ServerMeta&& from) noexcept
    : ServerMeta() {
    *this = ::std::move(from);
  }

  inline ServerMeta& operator=(ServerMeta&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerMeta& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerMeta* internal_default_instance() {
    return reinterpret_cast<const ServerMeta*>(
               &_ServerMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(ServerMeta* other);
  friend void swap(ServerMeta& a, ServerMeta& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerMeta* New() const final {
    return CreateMaybeMessage<ServerMeta>(NULL);
  }

  ServerMeta* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerMeta>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerMeta& from);
  void MergeFrom(const ServerMeta& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerMeta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .exec.user.CollateSupport collate_support = 6;
  int collate_support_size() const;
  void clear_collate_support();
  static const int kCollateSupportFieldNumber = 6;
  ::exec::user::CollateSupport collate_support(int index) const;
  void set_collate_support(int index, ::exec::user::CollateSupport value);
  void add_collate_support(::exec::user::CollateSupport value);
  const ::google::protobuf::RepeatedField<int>& collate_support() const;
  ::google::protobuf::RepeatedField<int>* mutable_collate_support();

  // repeated .exec.user.ConvertSupport convert_support = 8;
  int convert_support_size() const;
  void clear_convert_support();
  static const int kConvertSupportFieldNumber = 8;
  ::exec::user::ConvertSupport* mutable_convert_support(int index);
  ::google::protobuf::RepeatedPtrField< ::exec::user::ConvertSupport >*
      mutable_convert_support();
  const ::exec::user::ConvertSupport& convert_support(int index) const;
  ::exec::user::ConvertSupport* add_convert_support();
  const ::google::protobuf::RepeatedPtrField< ::exec::user::ConvertSupport >&
      convert_support() const;

  // repeated string date_time_functions = 10;
  int date_time_functions_size() const;
  void clear_date_time_functions();
  static const int kDateTimeFunctionsFieldNumber = 10;
  const ::std::string& date_time_functions(int index) const;
  ::std::string* mutable_date_time_functions(int index);
  void set_date_time_functions(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_date_time_functions(int index, ::std::string&& value);
  #endif
  void set_date_time_functions(int index, const char* value);
  void set_date_time_functions(int index, const char* value, size_t size);
  ::std::string* add_date_time_functions();
  void add_date_time_functions(const ::std::string& value);
  #if LANG_CXX11
  void add_date_time_functions(::std::string&& value);
  #endif
  void add_date_time_functions(const char* value);
  void add_date_time_functions(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& date_time_functions() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_date_time_functions();

  // repeated .exec.user.DateTimeLiteralsSupport date_time_literals_support = 11;
  int date_time_literals_support_size() const;
  void clear_date_time_literals_support();
  static const int kDateTimeLiteralsSupportFieldNumber = 11;
  ::exec::user::DateTimeLiteralsSupport date_time_literals_support(int index) const;
  void set_date_time_literals_support(int index, ::exec::user::DateTimeLiteralsSupport value);
  void add_date_time_literals_support(::exec::user::DateTimeLiteralsSupport value);
  const ::google::protobuf::RepeatedField<int>& date_time_literals_support() const;
  ::google::protobuf::RepeatedField<int>* mutable_date_time_literals_support();

  // repeated string numeric_functions = 34;
  int numeric_functions_size() const;
  void clear_numeric_functions();
  static const int kNumericFunctionsFieldNumber = 34;
  const ::std::string& numeric_functions(int index) const;
  ::std::string* mutable_numeric_functions(int index);
  void set_numeric_functions(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_numeric_functions(int index, ::std::string&& value);
  #endif
  void set_numeric_functions(int index, const char* value);
  void set_numeric_functions(int index, const char* value, size_t size);
  ::std::string* add_numeric_functions();
  void add_numeric_functions(const ::std::string& value);
  #if LANG_CXX11
  void add_numeric_functions(::std::string&& value);
  #endif
  void add_numeric_functions(const char* value);
  void add_numeric_functions(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& numeric_functions() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_numeric_functions();

  // repeated .exec.user.OrderBySupport order_by_support = 35;
  int order_by_support_size() const;
  void clear_order_by_support();
  static const int kOrderBySupportFieldNumber = 35;
  ::exec::user::OrderBySupport order_by_support(int index) const;
  void set_order_by_support(int index, ::exec::user::OrderBySupport value);
  void add_order_by_support(::exec::user::OrderBySupport value);
  const ::google::protobuf::RepeatedField<int>& order_by_support() const;
  ::google::protobuf::RepeatedField<int>* mutable_order_by_support();

  // repeated .exec.user.OuterJoinSupport outer_join_support = 36;
  int outer_join_support_size() const;
  void clear_outer_join_support();
  static const int kOuterJoinSupportFieldNumber = 36;
  ::exec::user::OuterJoinSupport outer_join_support(int index) const;
  void set_outer_join_support(int index, ::exec::user::OuterJoinSupport value);
  void add_outer_join_support(::exec::user::OuterJoinSupport value);
  const ::google::protobuf::RepeatedField<int>& outer_join_support() const;
  ::google::protobuf::RepeatedField<int>* mutable_outer_join_support();

  // repeated string sql_keywords = 43;
  int sql_keywords_size() const;
  void clear_sql_keywords();
  static const int kSqlKeywordsFieldNumber = 43;
  const ::std::string& sql_keywords(int index) const;
  ::std::string* mutable_sql_keywords(int index);
  void set_sql_keywords(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_sql_keywords(int index, ::std::string&& value);
  #endif
  void set_sql_keywords(int index, const char* value);
  void set_sql_keywords(int index, const char* value, size_t size);
  ::std::string* add_sql_keywords();
  void add_sql_keywords(const ::std::string& value);
  #if LANG_CXX11
  void add_sql_keywords(::std::string&& value);
  #endif
  void add_sql_keywords(const char* value);
  void add_sql_keywords(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& sql_keywords() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sql_keywords();

  // repeated string string_functions = 44;
  int string_functions_size() const;
  void clear_string_functions();
  static const int kStringFunctionsFieldNumber = 44;
  const ::std::string& string_functions(int index) const;
  ::std::string* mutable_string_functions(int index);
  void set_string_functions(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_string_functions(int index, ::std::string&& value);
  #endif
  void set_string_functions(int index, const char* value);
  void set_string_functions(int index, const char* value, size_t size);
  ::std::string* add_string_functions();
  void add_string_functions(const ::std::string& value);
  #if LANG_CXX11
  void add_string_functions(::std::string&& value);
  #endif
  void add_string_functions(const char* value);
  void add_string_functions(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& string_functions() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_string_functions();

  // repeated .exec.user.SubQuerySupport subquery_support = 45;
  int subquery_support_size() const;
  void clear_subquery_support();
  static const int kSubquerySupportFieldNumber = 45;
  ::exec::user::SubQuerySupport subquery_support(int index) const;
  void set_subquery_support(int index, ::exec::user::SubQuerySupport value);
  void add_subquery_support(::exec::user::SubQuerySupport value);
  const ::google::protobuf::RepeatedField<int>& subquery_support() const;
  ::google::protobuf::RepeatedField<int>* mutable_subquery_support();

  // repeated string system_functions = 46;
  int system_functions_size() const;
  void clear_system_functions();
  static const int kSystemFunctionsFieldNumber = 46;
  const ::std::string& system_functions(int index) const;
  ::std::string* mutable_system_functions(int index);
  void set_system_functions(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_system_functions(int index, ::std::string&& value);
  #endif
  void set_system_functions(int index, const char* value);
  void set_system_functions(int index, const char* value, size_t size);
  ::std::string* add_system_functions();
  void add_system_functions(const ::std::string& value);
  #if LANG_CXX11
  void add_system_functions(::std::string&& value);
  #endif
  void add_system_functions(const char* value);
  void add_system_functions(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& system_functions() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_system_functions();

  // repeated .exec.user.UnionSupport union_support = 49;
  int union_support_size() const;
  void clear_union_support();
  static const int kUnionSupportFieldNumber = 49;
  ::exec::user::UnionSupport union_support(int index) const;
  void set_union_support(int index, ::exec::user::UnionSupport value);
  void add_union_support(::exec::user::UnionSupport value);
  const ::google::protobuf::RepeatedField<int>& union_support() const;
  ::google::protobuf::RepeatedField<int>* mutable_union_support();

  // optional string catalog_separator = 4;
  bool has_catalog_separator() const;
  void clear_catalog_separator();
  static const int kCatalogSeparatorFieldNumber = 4;
  const ::std::string& catalog_separator() const;
  void set_catalog_separator(const ::std::string& value);
  #if LANG_CXX11
  void set_catalog_separator(::std::string&& value);
  #endif
  void set_catalog_separator(const char* value);
  void set_catalog_separator(const char* value, size_t size);
  ::std::string* mutable_catalog_separator();
  ::std::string* release_catalog_separator();
  void set_allocated_catalog_separator(::std::string* catalog_separator);

  // optional string catalog_term = 5;
  bool has_catalog_term() const;
  void clear_catalog_term();
  static const int kCatalogTermFieldNumber = 5;
  const ::std::string& catalog_term() const;
  void set_catalog_term(const ::std::string& value);
  #if LANG_CXX11
  void set_catalog_term(::std::string&& value);
  #endif
  void set_catalog_term(const char* value);
  void set_catalog_term(const char* value, size_t size);
  ::std::string* mutable_catalog_term();
  ::std::string* release_catalog_term();
  void set_allocated_catalog_term(::std::string* catalog_term);

  // optional string identifier_quote_string = 14;
  bool has_identifier_quote_string() const;
  void clear_identifier_quote_string();
  static const int kIdentifierQuoteStringFieldNumber = 14;
  const ::std::string& identifier_quote_string() const;
  void set_identifier_quote_string(const ::std::string& value);
  #if LANG_CXX11
  void set_identifier_quote_string(::std::string&& value);
  #endif
  void set_identifier_quote_string(const char* value);
  void set_identifier_quote_string(const char* value, size_t size);
  ::std::string* mutable_identifier_quote_string();
  ::std::string* release_identifier_quote_string();
  void set_allocated_identifier_quote_string(::std::string* identifier_quote_string);

  // optional string schema_term = 39;
  bool has_schema_term() const;
  void clear_schema_term();
  static const int kSchemaTermFieldNumber = 39;
  const ::std::string& schema_term() const;
  void set_schema_term(const ::std::string& value);
  #if LANG_CXX11
  void set_schema_term(::std::string&& value);
  #endif
  void set_schema_term(const char* value);
  void set_schema_term(const char* value, size_t size);
  ::std::string* mutable_schema_term();
  ::std::string* release_schema_term();
  void set_allocated_schema_term(::std::string* schema_term);

  // optional string search_escape_string = 40;
  bool has_search_escape_string() const;
  void clear_search_escape_string();
  static const int kSearchEscapeStringFieldNumber = 40;
  const ::std::string& search_escape_string() const;
  void set_search_escape_string(const ::std::string& value);
  #if LANG_CXX11
  void set_search_escape_string(::std::string&& value);
  #endif
  void set_search_escape_string(const char* value);
  void set_search_escape_string(const char* value, size_t size);
  ::std::string* mutable_search_escape_string();
  ::std::string* release_search_escape_string();
  void set_allocated_search_escape_string(::std::string* search_escape_string);

  // optional string special_characters = 42;
  bool has_special_characters() const;
  void clear_special_characters();
  static const int kSpecialCharactersFieldNumber = 42;
  const ::std::string& special_characters() const;
  void set_special_characters(const ::std::string& value);
  #if LANG_CXX11
  void set_special_characters(::std::string&& value);
  #endif
  void set_special_characters(const char* value);
  void set_special_characters(const char* value, size_t size);
  ::std::string* mutable_special_characters();
  ::std::string* release_special_characters();
  void set_allocated_special_characters(::std::string* special_characters);

  // optional string table_term = 47;
  bool has_table_term() const;
  void clear_table_term();
  static const int kTableTermFieldNumber = 47;
  const ::std::string& table_term() const;
  void set_table_term(const ::std::string& value);
  #if LANG_CXX11
  void set_table_term(::std::string&& value);
  #endif
  void set_table_term(const char* value);
  void set_table_term(const char* value, size_t size);
  ::std::string* mutable_table_term();
  ::std::string* release_table_term();
  void set_allocated_table_term(::std::string* table_term);

  // optional string current_schema = 50;
  bool has_current_schema() const;
  void clear_current_schema();
  static const int kCurrentSchemaFieldNumber = 50;
  const ::std::string& current_schema() const;
  void set_current_schema(const ::std::string& value);
  #if LANG_CXX11
  void set_current_schema(::std::string&& value);
  #endif
  void set_current_schema(const char* value);
  void set_current_schema(const char* value, size_t size);
  ::std::string* mutable_current_schema();
  ::std::string* release_current_schema();
  void set_allocated_current_schema(::std::string* current_schema);

  // optional bool all_tables_selectable = 1;
  bool has_all_tables_selectable() const;
  void clear_all_tables_selectable();
  static const int kAllTablesSelectableFieldNumber = 1;
  bool all_tables_selectable() const;
  void set_all_tables_selectable(bool value);

  // optional bool blob_included_in_max_row_size = 2;
  bool has_blob_included_in_max_row_size() const;
  void clear_blob_included_in_max_row_size();
  static const int kBlobIncludedInMaxRowSizeFieldNumber = 2;
  bool blob_included_in_max_row_size() const;
  void set_blob_included_in_max_row_size(bool value);

  // optional bool catalog_at_start = 3;
  bool has_catalog_at_start() const;
  void clear_catalog_at_start();
  static const int kCatalogAtStartFieldNumber = 3;
  bool catalog_at_start() const;
  void set_catalog_at_start(bool value);

  // optional bool column_aliasing_supported = 7;
  bool has_column_aliasing_supported() const;
  void clear_column_aliasing_supported();
  static const int kColumnAliasingSupportedFieldNumber = 7;
  bool column_aliasing_supported() const;
  void set_column_aliasing_supported(bool value);

  // optional .exec.user.IdentifierCasing identifier_casing = 13;
  bool has_identifier_casing() const;
  void clear_identifier_casing();
  static const int kIdentifierCasingFieldNumber = 13;
  ::exec::user::IdentifierCasing identifier_casing() const;
  void set_identifier_casing(::exec::user::IdentifierCasing value);

  // optional uint32 max_binary_literal_length = 16;
  bool has_max_binary_literal_length() const;
  void clear_max_binary_literal_length();
  static const int kMaxBinaryLiteralLengthFieldNumber = 16;
  ::google::protobuf::uint32 max_binary_literal_length() const;
  void set_max_binary_literal_length(::google::protobuf::uint32 value);

  // optional uint32 max_catalog_name_length = 17;
  bool has_max_catalog_name_length() const;
  void clear_max_catalog_name_length();
  static const int kMaxCatalogNameLengthFieldNumber = 17;
  ::google::protobuf::uint32 max_catalog_name_length() const;
  void set_max_catalog_name_length(::google::protobuf::uint32 value);

  // optional uint32 max_char_literal_length = 18;
  bool has_max_char_literal_length() const;
  void clear_max_char_literal_length();
  static const int kMaxCharLiteralLengthFieldNumber = 18;
  ::google::protobuf::uint32 max_char_literal_length() const;
  void set_max_char_literal_length(::google::protobuf::uint32 value);

  // optional uint32 max_column_name_length = 19;
  bool has_max_column_name_length() const;
  void clear_max_column_name_length();
  static const int kMaxColumnNameLengthFieldNumber = 19;
  ::google::protobuf::uint32 max_column_name_length() const;
  void set_max_column_name_length(::google::protobuf::uint32 value);

  // optional uint32 max_columns_in_group_by = 20;
  bool has_max_columns_in_group_by() const;
  void clear_max_columns_in_group_by();
  static const int kMaxColumnsInGroupByFieldNumber = 20;
  ::google::protobuf::uint32 max_columns_in_group_by() const;
  void set_max_columns_in_group_by(::google::protobuf::uint32 value);

  // optional uint32 max_columns_in_order_by = 21;
  bool has_max_columns_in_order_by() const;
  void clear_max_columns_in_order_by();
  static const int kMaxColumnsInOrderByFieldNumber = 21;
  ::google::protobuf::uint32 max_columns_in_order_by() const;
  void set_max_columns_in_order_by(::google::protobuf::uint32 value);

  // optional uint32 max_columns_in_select = 22;
  bool has_max_columns_in_select() const;
  void clear_max_columns_in_select();
  static const int kMaxColumnsInSelectFieldNumber = 22;
  ::google::protobuf::uint32 max_columns_in_select() const;
  void set_max_columns_in_select(::google::protobuf::uint32 value);

  // optional uint32 max_cursor_name_length = 23;
  bool has_max_cursor_name_length() const;
  void clear_max_cursor_name_length();
  static const int kMaxCursorNameLengthFieldNumber = 23;
  ::google::protobuf::uint32 max_cursor_name_length() const;
  void set_max_cursor_name_length(::google::protobuf::uint32 value);

  // optional uint32 max_logical_lob_size = 24;
  bool has_max_logical_lob_size() const;
  void clear_max_logical_lob_size();
  static const int kMaxLogicalLobSizeFieldNumber = 24;
  ::google::protobuf::uint32 max_logical_lob_size() const;
  void set_max_logical_lob_size(::google::protobuf::uint32 value);

  // optional uint32 max_row_size = 25;
  bool has_max_row_size() const;
  void clear_max_row_size();
  static const int kMaxRowSizeFieldNumber = 25;
  ::google::protobuf::uint32 max_row_size() const;
  void set_max_row_size(::google::protobuf::uint32 value);

  // optional uint32 max_schema_name_length = 26;
  bool has_max_schema_name_length() const;
  void clear_max_schema_name_length();
  static const int kMaxSchemaNameLengthFieldNumber = 26;
  ::google::protobuf::uint32 max_schema_name_length() const;
  void set_max_schema_name_length(::google::protobuf::uint32 value);

  // optional uint32 max_statement_length = 27;
  bool has_max_statement_length() const;
  void clear_max_statement_length();
  static const int kMaxStatementLengthFieldNumber = 27;
  ::google::protobuf::uint32 max_statement_length() const;
  void set_max_statement_length(::google::protobuf::uint32 value);

  // optional uint32 max_statements = 28;
  bool has_max_statements() const;
  void clear_max_statements();
  static const int kMaxStatementsFieldNumber = 28;
  ::google::protobuf::uint32 max_statements() const;
  void set_max_statements(::google::protobuf::uint32 value);

  // optional uint32 max_table_name_length = 29;
  bool has_max_table_name_length() const;
  void clear_max_table_name_length();
  static const int kMaxTableNameLengthFieldNumber = 29;
  ::google::protobuf::uint32 max_table_name_length() const;
  void set_max_table_name_length(::google::protobuf::uint32 value);

  // optional uint32 max_tables_in_select = 30;
  bool has_max_tables_in_select() const;
  void clear_max_tables_in_select();
  static const int kMaxTablesInSelectFieldNumber = 30;
  ::google::protobuf::uint32 max_tables_in_select() const;
  void set_max_tables_in_select(::google::protobuf::uint32 value);

  // optional uint32 max_user_name_length = 31;
  bool has_max_user_name_length() const;
  void clear_max_user_name_length();
  static const int kMaxUserNameLengthFieldNumber = 31;
  ::google::protobuf::uint32 max_user_name_length() const;
  void set_max_user_name_length(::google::protobuf::uint32 value);

  // optional bool like_escape_clause_supported = 15;
  bool has_like_escape_clause_supported() const;
  void clear_like_escape_clause_supported();
  static const int kLikeEscapeClauseSupportedFieldNumber = 15;
  bool like_escape_clause_supported() const;
  void set_like_escape_clause_supported(bool value);

  // optional bool null_plus_non_null_equals_null = 33;
  bool has_null_plus_non_null_equals_null() const;
  void clear_null_plus_non_null_equals_null();
  static const int kNullPlusNonNullEqualsNullFieldNumber = 33;
  bool null_plus_non_null_equals_null() const;
  void set_null_plus_non_null_equals_null(bool value);

  // optional bool read_only = 38;
  bool has_read_only() const;
  void clear_read_only();
  static const int kReadOnlyFieldNumber = 38;
  bool read_only() const;
  void set_read_only(bool value);

  // optional bool select_for_update_supported = 41;
  bool has_select_for_update_supported() const;
  void clear_select_for_update_supported();
  static const int kSelectForUpdateSupportedFieldNumber = 41;
  bool select_for_update_supported() const;
  void set_select_for_update_supported(bool value);

  // optional .exec.user.NullCollation null_collation = 32;
  bool has_null_collation() const;
  void clear_null_collation();
  static const int kNullCollationFieldNumber = 32;
  ::exec::user::NullCollation null_collation() const;
  void set_null_collation(::exec::user::NullCollation value);

  // optional .exec.user.IdentifierCasing quoted_identifier_casing = 37;
  bool has_quoted_identifier_casing() const;
  void clear_quoted_identifier_casing();
  static const int kQuotedIdentifierCasingFieldNumber = 37;
  ::exec::user::IdentifierCasing quoted_identifier_casing() const;
  void set_quoted_identifier_casing(::exec::user::IdentifierCasing value);

  // optional bool transaction_supported = 48;
  bool has_transaction_supported() const;
  void clear_transaction_supported();
  static const int kTransactionSupportedFieldNumber = 48;
  bool transaction_supported() const;
  void set_transaction_supported(bool value);

  // optional .exec.user.CorrelationNamesSupport correlation_names_support = 9;
  bool has_correlation_names_support() const;
  void clear_correlation_names_support();
  static const int kCorrelationNamesSupportFieldNumber = 9;
  ::exec::user::CorrelationNamesSupport correlation_names_support() const;
  void set_correlation_names_support(::exec::user::CorrelationNamesSupport value);

  // optional .exec.user.GroupBySupport group_by_support = 12;
  bool has_group_by_support() const;
  void clear_group_by_support();
  static const int kGroupBySupportFieldNumber = 12;
  ::exec::user::GroupBySupport group_by_support() const;
  void set_group_by_support(::exec::user::GroupBySupport value);

  // @@protoc_insertion_point(class_scope:exec.user.ServerMeta)
 private:
  void set_has_all_tables_selectable();
  void clear_has_all_tables_selectable();
  void set_has_blob_included_in_max_row_size();
  void clear_has_blob_included_in_max_row_size();
  void set_has_catalog_at_start();
  void clear_has_catalog_at_start();
  void set_has_catalog_separator();
  void clear_has_catalog_separator();
  void set_has_catalog_term();
  void clear_has_catalog_term();
  void set_has_column_aliasing_supported();
  void clear_has_column_aliasing_supported();
  void set_has_correlation_names_support();
  void clear_has_correlation_names_support();
  void set_has_group_by_support();
  void clear_has_group_by_support();
  void set_has_identifier_casing();
  void clear_has_identifier_casing();
  void set_has_identifier_quote_string();
  void clear_has_identifier_quote_string();
  void set_has_like_escape_clause_supported();
  void clear_has_like_escape_clause_supported();
  void set_has_max_binary_literal_length();
  void clear_has_max_binary_literal_length();
  void set_has_max_catalog_name_length();
  void clear_has_max_catalog_name_length();
  void set_has_max_char_literal_length();
  void clear_has_max_char_literal_length();
  void set_has_max_column_name_length();
  void clear_has_max_column_name_length();
  void set_has_max_columns_in_group_by();
  void clear_has_max_columns_in_group_by();
  void set_has_max_columns_in_order_by();
  void clear_has_max_columns_in_order_by();
  void set_has_max_columns_in_select();
  void clear_has_max_columns_in_select();
  void set_has_max_cursor_name_length();
  void clear_has_max_cursor_name_length();
  void set_has_max_logical_lob_size();
  void clear_has_max_logical_lob_size();
  void set_has_max_row_size();
  void clear_has_max_row_size();
  void set_has_max_schema_name_length();
  void clear_has_max_schema_name_length();
  void set_has_max_statement_length();
  void clear_has_max_statement_length();
  void set_has_max_statements();
  void clear_has_max_statements();
  void set_has_max_table_name_length();
  void clear_has_max_table_name_length();
  void set_has_max_tables_in_select();
  void clear_has_max_tables_in_select();
  void set_has_max_user_name_length();
  void clear_has_max_user_name_length();
  void set_has_null_collation();
  void clear_has_null_collation();
  void set_has_null_plus_non_null_equals_null();
  void clear_has_null_plus_non_null_equals_null();
  void set_has_quoted_identifier_casing();
  void clear_has_quoted_identifier_casing();
  void set_has_read_only();
  void clear_has_read_only();
  void set_has_schema_term();
  void clear_has_schema_term();
  void set_has_search_escape_string();
  void clear_has_search_escape_string();
  void set_has_select_for_update_supported();
  void clear_has_select_for_update_supported();
  void set_has_special_characters();
  void clear_has_special_characters();
  void set_has_table_term();
  void clear_has_table_term();
  void set_has_transaction_supported();
  void clear_has_transaction_supported();
  void set_has_current_schema();
  void clear_has_current_schema();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<2> _has_bits_;
  ::google::protobuf::RepeatedField<int> collate_support_;
  ::google::protobuf::RepeatedPtrField< ::exec::user::ConvertSupport > convert_support_;
  ::google::protobuf::RepeatedPtrField< ::std::string> date_time_functions_;
  ::google::protobuf::RepeatedField<int> date_time_literals_support_;
  ::google::protobuf::RepeatedPtrField< ::std::string> numeric_functions_;
  ::google::protobuf::RepeatedField<int> order_by_support_;
  ::google::protobuf::RepeatedField<int> outer_join_support_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sql_keywords_;
  ::google::protobuf::RepeatedPtrField< ::std::string> string_functions_;
  ::google::protobuf::RepeatedField<int> subquery_support_;
  ::google::protobuf::RepeatedPtrField< ::std::string> system_functions_;
  ::google::protobuf::RepeatedField<int> union_support_;
  ::google::protobuf::internal::ArenaStringPtr catalog_separator_;
  ::google::protobuf::internal::ArenaStringPtr catalog_term_;
  ::google::protobuf::internal::ArenaStringPtr identifier_quote_string_;
  ::google::protobuf::internal::ArenaStringPtr schema_term_;
  ::google::protobuf::internal::ArenaStringPtr search_escape_string_;
  ::google::protobuf::internal::ArenaStringPtr special_characters_;
  ::google::protobuf::internal::ArenaStringPtr table_term_;
  ::google::protobuf::internal::ArenaStringPtr current_schema_;
  bool all_tables_selectable_;
  bool blob_included_in_max_row_size_;
  bool catalog_at_start_;
  bool column_aliasing_supported_;
  int identifier_casing_;
  ::google::protobuf::uint32 max_binary_literal_length_;
  ::google::protobuf::uint32 max_catalog_name_length_;
  ::google::protobuf::uint32 max_char_literal_length_;
  ::google::protobuf::uint32 max_column_name_length_;
  ::google::protobuf::uint32 max_columns_in_group_by_;
  ::google::protobuf::uint32 max_columns_in_order_by_;
  ::google::protobuf::uint32 max_columns_in_select_;
  ::google::protobuf::uint32 max_cursor_name_length_;
  ::google::protobuf::uint32 max_logical_lob_size_;
  ::google::protobuf::uint32 max_row_size_;
  ::google::protobuf::uint32 max_schema_name_length_;
  ::google::protobuf::uint32 max_statement_length_;
  ::google::protobuf::uint32 max_statements_;
  ::google::protobuf::uint32 max_table_name_length_;
  ::google::protobuf::uint32 max_tables_in_select_;
  ::google::protobuf::uint32 max_user_name_length_;
  bool like_escape_clause_supported_;
  bool null_plus_non_null_equals_null_;
  bool read_only_;
  bool select_for_update_supported_;
  int null_collation_;
  int quoted_identifier_casing_;
  bool transaction_supported_;
  int correlation_names_support_;
  int group_by_support_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RunQuery : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exec.user.RunQuery) */ {
 public:
  RunQuery();
  virtual ~RunQuery();

  RunQuery(const RunQuery& from);

  inline RunQuery& operator=(const RunQuery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RunQuery(RunQuery&& from) noexcept
    : RunQuery() {
    *this = ::std::move(from);
  }

  inline RunQuery& operator=(RunQuery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RunQuery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RunQuery* internal_default_instance() {
    return reinterpret_cast<const RunQuery*>(
               &_RunQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(RunQuery* other);
  friend void swap(RunQuery& a, RunQuery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RunQuery* New() const final {
    return CreateMaybeMessage<RunQuery>(NULL);
  }

  RunQuery* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RunQuery>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RunQuery& from);
  void MergeFrom(const RunQuery& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunQuery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .exec.bit.control.PlanFragment fragments = 4;
  int fragments_size() const;
  void clear_fragments();
  static const int kFragmentsFieldNumber = 4;
  ::exec::bit::control::PlanFragment* mutable_fragments(int index);
  ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment >*
      mutable_fragments();
  const ::exec::bit::control::PlanFragment& fragments(int index) const;
  ::exec::bit::control::PlanFragment* add_fragments();
  const ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment >&
      fragments() const;

  // optional string plan = 3;
  bool has_plan() const;
  void clear_plan();
  static const int kPlanFieldNumber = 3;
  const ::std::string& plan() const;
  void set_plan(const ::std::string& value);
  #if LANG_CXX11
  void set_plan(::std::string&& value);
  #endif
  void set_plan(const char* value);
  void set_plan(const char* value, size_t size);
  ::std::string* mutable_plan();
  ::std::string* release_plan();
  void set_allocated_plan(::std::string* plan);

  // optional .exec.user.PreparedStatementHandle prepared_statement_handle = 5;
  bool has_prepared_statement_handle() const;
  void clear_prepared_statement_handle();
  static const int kPreparedStatementHandleFieldNumber = 5;
  private:
  const ::exec::user::PreparedStatementHandle& _internal_prepared_statement_handle() const;
  public:
  const ::exec::user::PreparedStatementHandle& prepared_statement_handle() const;
  ::exec::user::PreparedStatementHandle* release_prepared_statement_handle();
  ::exec::user::PreparedStatementHandle* mutable_prepared_statement_handle();
  void set_allocated_prepared_statement_handle(::exec::user::PreparedStatementHandle* prepared_statement_handle);

  // optional int32 autolimit_rowcount = 6;
  bool has_autolimit_rowcount() const;
  void clear_autolimit_rowcount();
  static const int kAutolimitRowcountFieldNumber = 6;
  ::google::protobuf::int32 autolimit_rowcount() const;
  void set_autolimit_rowcount(::google::protobuf::int32 value);

  // optional .exec.user.QueryResultsMode results_mode = 1;
  bool has_results_mode() const;
  void clear_results_mode();
  static const int kResultsModeFieldNumber = 1;
  ::exec::user::QueryResultsMode results_mode() const;
  void set_results_mode(::exec::user::QueryResultsMode value);

  // optional .exec.shared.QueryType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::exec::shared::QueryType type() const;
  void set_type(::exec::shared::QueryType value);

  // @@protoc_insertion_point(class_scope:exec.user.RunQuery)
 private:
  void set_has_results_mode();
  void clear_has_results_mode();
  void set_has_type();
  void clear_has_type();
  void set_has_plan();
  void clear_has_plan();
  void set_has_prepared_statement_handle();
  void clear_has_prepared_statement_handle();
  void set_has_autolimit_rowcount();
  void clear_has_autolimit_rowcount();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment > fragments_;
  ::google::protobuf::internal::ArenaStringPtr plan_;
  ::exec::user::PreparedStatementHandle* prepared_statement_handle_;
  ::google::protobuf::int32 autolimit_rowcount_;
  int results_mode_;
  int type_;
  friend struct ::protobuf_User_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Property

// required string key = 1;
inline bool Property::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Property::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Property::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Property::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& Property::key() const {
  // @@protoc_insertion_point(field_get:exec.user.Property.key)
  return key_.GetNoArena();
}
inline void Property::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.Property.key)
}
#if LANG_CXX11
inline void Property::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.Property.key)
}
#endif
inline void Property::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.Property.key)
}
inline void Property::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.Property.key)
}
inline ::std::string* Property::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:exec.user.Property.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Property::release_key() {
  // @@protoc_insertion_point(field_release:exec.user.Property.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Property::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:exec.user.Property.key)
}

// required string value = 2;
inline bool Property::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Property::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Property::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Property::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& Property::value() const {
  // @@protoc_insertion_point(field_get:exec.user.Property.value)
  return value_.GetNoArena();
}
inline void Property::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.Property.value)
}
#if LANG_CXX11
inline void Property::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.Property.value)
}
#endif
inline void Property::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.Property.value)
}
inline void Property::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.Property.value)
}
inline ::std::string* Property::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:exec.user.Property.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Property::release_value() {
  // @@protoc_insertion_point(field_release:exec.user.Property.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Property::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:exec.user.Property.value)
}

// -------------------------------------------------------------------

// UserProperties

// repeated .exec.user.Property properties = 1;
inline int UserProperties::properties_size() const {
  return properties_.size();
}
inline void UserProperties::clear_properties() {
  properties_.Clear();
}
inline ::exec::user::Property* UserProperties::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.UserProperties.properties)
  return properties_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::exec::user::Property >*
UserProperties::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.UserProperties.properties)
  return &properties_;
}
inline const ::exec::user::Property& UserProperties::properties(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.UserProperties.properties)
  return properties_.Get(index);
}
inline ::exec::user::Property* UserProperties::add_properties() {
  // @@protoc_insertion_point(field_add:exec.user.UserProperties.properties)
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::user::Property >&
UserProperties::properties() const {
  // @@protoc_insertion_point(field_list:exec.user.UserProperties.properties)
  return properties_;
}

// -------------------------------------------------------------------

// RpcEndpointInfos

// optional string name = 1;
inline bool RpcEndpointInfos::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpcEndpointInfos::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpcEndpointInfos::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpcEndpointInfos::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& RpcEndpointInfos::name() const {
  // @@protoc_insertion_point(field_get:exec.user.RpcEndpointInfos.name)
  return name_.GetNoArena();
}
inline void RpcEndpointInfos::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.RpcEndpointInfos.name)
}
#if LANG_CXX11
inline void RpcEndpointInfos::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.RpcEndpointInfos.name)
}
#endif
inline void RpcEndpointInfos::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.RpcEndpointInfos.name)
}
inline void RpcEndpointInfos::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.RpcEndpointInfos.name)
}
inline ::std::string* RpcEndpointInfos::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:exec.user.RpcEndpointInfos.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcEndpointInfos::release_name() {
  // @@protoc_insertion_point(field_release:exec.user.RpcEndpointInfos.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcEndpointInfos::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:exec.user.RpcEndpointInfos.name)
}

// optional string version = 2;
inline bool RpcEndpointInfos::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpcEndpointInfos::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpcEndpointInfos::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpcEndpointInfos::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& RpcEndpointInfos::version() const {
  // @@protoc_insertion_point(field_get:exec.user.RpcEndpointInfos.version)
  return version_.GetNoArena();
}
inline void RpcEndpointInfos::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.RpcEndpointInfos.version)
}
#if LANG_CXX11
inline void RpcEndpointInfos::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.RpcEndpointInfos.version)
}
#endif
inline void RpcEndpointInfos::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.RpcEndpointInfos.version)
}
inline void RpcEndpointInfos::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.RpcEndpointInfos.version)
}
inline ::std::string* RpcEndpointInfos::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:exec.user.RpcEndpointInfos.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcEndpointInfos::release_version() {
  // @@protoc_insertion_point(field_release:exec.user.RpcEndpointInfos.version)
  if (!has_version()) {
    return NULL;
  }
  clear_has_version();
  return version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcEndpointInfos::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:exec.user.RpcEndpointInfos.version)
}

// optional uint32 majorVersion = 3;
inline bool RpcEndpointInfos::has_majorversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpcEndpointInfos::set_has_majorversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpcEndpointInfos::clear_has_majorversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpcEndpointInfos::clear_majorversion() {
  majorversion_ = 0u;
  clear_has_majorversion();
}
inline ::google::protobuf::uint32 RpcEndpointInfos::majorversion() const {
  // @@protoc_insertion_point(field_get:exec.user.RpcEndpointInfos.majorVersion)
  return majorversion_;
}
inline void RpcEndpointInfos::set_majorversion(::google::protobuf::uint32 value) {
  set_has_majorversion();
  majorversion_ = value;
  // @@protoc_insertion_point(field_set:exec.user.RpcEndpointInfos.majorVersion)
}

// optional uint32 minorVersion = 4;
inline bool RpcEndpointInfos::has_minorversion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpcEndpointInfos::set_has_minorversion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpcEndpointInfos::clear_has_minorversion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpcEndpointInfos::clear_minorversion() {
  minorversion_ = 0u;
  clear_has_minorversion();
}
inline ::google::protobuf::uint32 RpcEndpointInfos::minorversion() const {
  // @@protoc_insertion_point(field_get:exec.user.RpcEndpointInfos.minorVersion)
  return minorversion_;
}
inline void RpcEndpointInfos::set_minorversion(::google::protobuf::uint32 value) {
  set_has_minorversion();
  minorversion_ = value;
  // @@protoc_insertion_point(field_set:exec.user.RpcEndpointInfos.minorVersion)
}

// optional uint32 patchVersion = 5;
inline bool RpcEndpointInfos::has_patchversion() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpcEndpointInfos::set_has_patchversion() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpcEndpointInfos::clear_has_patchversion() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpcEndpointInfos::clear_patchversion() {
  patchversion_ = 0u;
  clear_has_patchversion();
}
inline ::google::protobuf::uint32 RpcEndpointInfos::patchversion() const {
  // @@protoc_insertion_point(field_get:exec.user.RpcEndpointInfos.patchVersion)
  return patchversion_;
}
inline void RpcEndpointInfos::set_patchversion(::google::protobuf::uint32 value) {
  set_has_patchversion();
  patchversion_ = value;
  // @@protoc_insertion_point(field_set:exec.user.RpcEndpointInfos.patchVersion)
}

// optional string application = 6;
inline bool RpcEndpointInfos::has_application() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpcEndpointInfos::set_has_application() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpcEndpointInfos::clear_has_application() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpcEndpointInfos::clear_application() {
  application_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_application();
}
inline const ::std::string& RpcEndpointInfos::application() const {
  // @@protoc_insertion_point(field_get:exec.user.RpcEndpointInfos.application)
  return application_.GetNoArena();
}
inline void RpcEndpointInfos::set_application(const ::std::string& value) {
  set_has_application();
  application_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.RpcEndpointInfos.application)
}
#if LANG_CXX11
inline void RpcEndpointInfos::set_application(::std::string&& value) {
  set_has_application();
  application_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.RpcEndpointInfos.application)
}
#endif
inline void RpcEndpointInfos::set_application(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_application();
  application_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.RpcEndpointInfos.application)
}
inline void RpcEndpointInfos::set_application(const char* value, size_t size) {
  set_has_application();
  application_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.RpcEndpointInfos.application)
}
inline ::std::string* RpcEndpointInfos::mutable_application() {
  set_has_application();
  // @@protoc_insertion_point(field_mutable:exec.user.RpcEndpointInfos.application)
  return application_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcEndpointInfos::release_application() {
  // @@protoc_insertion_point(field_release:exec.user.RpcEndpointInfos.application)
  if (!has_application()) {
    return NULL;
  }
  clear_has_application();
  return application_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcEndpointInfos::set_allocated_application(::std::string* application) {
  if (application != NULL) {
    set_has_application();
  } else {
    clear_has_application();
  }
  application_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), application);
  // @@protoc_insertion_point(field_set_allocated:exec.user.RpcEndpointInfos.application)
}

// optional uint32 buildNumber = 7;
inline bool RpcEndpointInfos::has_buildnumber() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpcEndpointInfos::set_has_buildnumber() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpcEndpointInfos::clear_has_buildnumber() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpcEndpointInfos::clear_buildnumber() {
  buildnumber_ = 0u;
  clear_has_buildnumber();
}
inline ::google::protobuf::uint32 RpcEndpointInfos::buildnumber() const {
  // @@protoc_insertion_point(field_get:exec.user.RpcEndpointInfos.buildNumber)
  return buildnumber_;
}
inline void RpcEndpointInfos::set_buildnumber(::google::protobuf::uint32 value) {
  set_has_buildnumber();
  buildnumber_ = value;
  // @@protoc_insertion_point(field_set:exec.user.RpcEndpointInfos.buildNumber)
}

// optional string versionQualifier = 8;
inline bool RpcEndpointInfos::has_versionqualifier() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpcEndpointInfos::set_has_versionqualifier() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpcEndpointInfos::clear_has_versionqualifier() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpcEndpointInfos::clear_versionqualifier() {
  versionqualifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_versionqualifier();
}
inline const ::std::string& RpcEndpointInfos::versionqualifier() const {
  // @@protoc_insertion_point(field_get:exec.user.RpcEndpointInfos.versionQualifier)
  return versionqualifier_.GetNoArena();
}
inline void RpcEndpointInfos::set_versionqualifier(const ::std::string& value) {
  set_has_versionqualifier();
  versionqualifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.RpcEndpointInfos.versionQualifier)
}
#if LANG_CXX11
inline void RpcEndpointInfos::set_versionqualifier(::std::string&& value) {
  set_has_versionqualifier();
  versionqualifier_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.RpcEndpointInfos.versionQualifier)
}
#endif
inline void RpcEndpointInfos::set_versionqualifier(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_versionqualifier();
  versionqualifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.RpcEndpointInfos.versionQualifier)
}
inline void RpcEndpointInfos::set_versionqualifier(const char* value, size_t size) {
  set_has_versionqualifier();
  versionqualifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.RpcEndpointInfos.versionQualifier)
}
inline ::std::string* RpcEndpointInfos::mutable_versionqualifier() {
  set_has_versionqualifier();
  // @@protoc_insertion_point(field_mutable:exec.user.RpcEndpointInfos.versionQualifier)
  return versionqualifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcEndpointInfos::release_versionqualifier() {
  // @@protoc_insertion_point(field_release:exec.user.RpcEndpointInfos.versionQualifier)
  if (!has_versionqualifier()) {
    return NULL;
  }
  clear_has_versionqualifier();
  return versionqualifier_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcEndpointInfos::set_allocated_versionqualifier(::std::string* versionqualifier) {
  if (versionqualifier != NULL) {
    set_has_versionqualifier();
  } else {
    clear_has_versionqualifier();
  }
  versionqualifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), versionqualifier);
  // @@protoc_insertion_point(field_set_allocated:exec.user.RpcEndpointInfos.versionQualifier)
}

// -------------------------------------------------------------------

// UserToBitHandshake

// optional .exec.shared.RpcChannel channel = 1 [default = USER];
inline bool UserToBitHandshake::has_channel() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserToBitHandshake::set_has_channel() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserToBitHandshake::clear_has_channel() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserToBitHandshake::clear_channel() {
  channel_ = 2;
  clear_has_channel();
}
inline ::exec::shared::RpcChannel UserToBitHandshake::channel() const {
  // @@protoc_insertion_point(field_get:exec.user.UserToBitHandshake.channel)
  return static_cast< ::exec::shared::RpcChannel >(channel_);
}
inline void UserToBitHandshake::set_channel(::exec::shared::RpcChannel value) {
  assert(::exec::shared::RpcChannel_IsValid(value));
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:exec.user.UserToBitHandshake.channel)
}

// optional bool support_listening = 2;
inline bool UserToBitHandshake::has_support_listening() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserToBitHandshake::set_has_support_listening() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserToBitHandshake::clear_has_support_listening() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserToBitHandshake::clear_support_listening() {
  support_listening_ = false;
  clear_has_support_listening();
}
inline bool UserToBitHandshake::support_listening() const {
  // @@protoc_insertion_point(field_get:exec.user.UserToBitHandshake.support_listening)
  return support_listening_;
}
inline void UserToBitHandshake::set_support_listening(bool value) {
  set_has_support_listening();
  support_listening_ = value;
  // @@protoc_insertion_point(field_set:exec.user.UserToBitHandshake.support_listening)
}

// optional int32 rpc_version = 3;
inline bool UserToBitHandshake::has_rpc_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserToBitHandshake::set_has_rpc_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserToBitHandshake::clear_has_rpc_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserToBitHandshake::clear_rpc_version() {
  rpc_version_ = 0;
  clear_has_rpc_version();
}
inline ::google::protobuf::int32 UserToBitHandshake::rpc_version() const {
  // @@protoc_insertion_point(field_get:exec.user.UserToBitHandshake.rpc_version)
  return rpc_version_;
}
inline void UserToBitHandshake::set_rpc_version(::google::protobuf::int32 value) {
  set_has_rpc_version();
  rpc_version_ = value;
  // @@protoc_insertion_point(field_set:exec.user.UserToBitHandshake.rpc_version)
}

// optional .exec.shared.UserCredentials credentials = 4;
inline bool UserToBitHandshake::has_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserToBitHandshake::set_has_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserToBitHandshake::clear_has_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::exec::shared::UserCredentials& UserToBitHandshake::_internal_credentials() const {
  return *credentials_;
}
inline const ::exec::shared::UserCredentials& UserToBitHandshake::credentials() const {
  const ::exec::shared::UserCredentials* p = credentials_;
  // @@protoc_insertion_point(field_get:exec.user.UserToBitHandshake.credentials)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::shared::UserCredentials*>(
      &::exec::shared::_UserCredentials_default_instance_);
}
inline ::exec::shared::UserCredentials* UserToBitHandshake::release_credentials() {
  // @@protoc_insertion_point(field_release:exec.user.UserToBitHandshake.credentials)
  clear_has_credentials();
  ::exec::shared::UserCredentials* temp = credentials_;
  credentials_ = NULL;
  return temp;
}
inline ::exec::shared::UserCredentials* UserToBitHandshake::mutable_credentials() {
  set_has_credentials();
  if (credentials_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::shared::UserCredentials>(GetArenaNoVirtual());
    credentials_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.UserToBitHandshake.credentials)
  return credentials_;
}
inline void UserToBitHandshake::set_allocated_credentials(::exec::shared::UserCredentials* credentials) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(credentials_);
  }
  if (credentials) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      credentials = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, credentials, submessage_arena);
    }
    set_has_credentials();
  } else {
    clear_has_credentials();
  }
  credentials_ = credentials;
  // @@protoc_insertion_point(field_set_allocated:exec.user.UserToBitHandshake.credentials)
}

// optional .exec.user.UserProperties properties = 5;
inline bool UserToBitHandshake::has_properties() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserToBitHandshake::set_has_properties() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserToBitHandshake::clear_has_properties() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserToBitHandshake::clear_properties() {
  if (properties_ != NULL) properties_->Clear();
  clear_has_properties();
}
inline const ::exec::user::UserProperties& UserToBitHandshake::_internal_properties() const {
  return *properties_;
}
inline const ::exec::user::UserProperties& UserToBitHandshake::properties() const {
  const ::exec::user::UserProperties* p = properties_;
  // @@protoc_insertion_point(field_get:exec.user.UserToBitHandshake.properties)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::user::UserProperties*>(
      &::exec::user::_UserProperties_default_instance_);
}
inline ::exec::user::UserProperties* UserToBitHandshake::release_properties() {
  // @@protoc_insertion_point(field_release:exec.user.UserToBitHandshake.properties)
  clear_has_properties();
  ::exec::user::UserProperties* temp = properties_;
  properties_ = NULL;
  return temp;
}
inline ::exec::user::UserProperties* UserToBitHandshake::mutable_properties() {
  set_has_properties();
  if (properties_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::user::UserProperties>(GetArenaNoVirtual());
    properties_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.UserToBitHandshake.properties)
  return properties_;
}
inline void UserToBitHandshake::set_allocated_properties(::exec::user::UserProperties* properties) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete properties_;
  }
  if (properties) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      properties = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, properties, submessage_arena);
    }
    set_has_properties();
  } else {
    clear_has_properties();
  }
  properties_ = properties;
  // @@protoc_insertion_point(field_set_allocated:exec.user.UserToBitHandshake.properties)
}

// optional bool support_complex_types = 6 [default = false];
inline bool UserToBitHandshake::has_support_complex_types() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserToBitHandshake::set_has_support_complex_types() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserToBitHandshake::clear_has_support_complex_types() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserToBitHandshake::clear_support_complex_types() {
  support_complex_types_ = false;
  clear_has_support_complex_types();
}
inline bool UserToBitHandshake::support_complex_types() const {
  // @@protoc_insertion_point(field_get:exec.user.UserToBitHandshake.support_complex_types)
  return support_complex_types_;
}
inline void UserToBitHandshake::set_support_complex_types(bool value) {
  set_has_support_complex_types();
  support_complex_types_ = value;
  // @@protoc_insertion_point(field_set:exec.user.UserToBitHandshake.support_complex_types)
}

// optional bool support_timeout = 7 [default = false];
inline bool UserToBitHandshake::has_support_timeout() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserToBitHandshake::set_has_support_timeout() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserToBitHandshake::clear_has_support_timeout() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserToBitHandshake::clear_support_timeout() {
  support_timeout_ = false;
  clear_has_support_timeout();
}
inline bool UserToBitHandshake::support_timeout() const {
  // @@protoc_insertion_point(field_get:exec.user.UserToBitHandshake.support_timeout)
  return support_timeout_;
}
inline void UserToBitHandshake::set_support_timeout(bool value) {
  set_has_support_timeout();
  support_timeout_ = value;
  // @@protoc_insertion_point(field_set:exec.user.UserToBitHandshake.support_timeout)
}

// optional .exec.user.RpcEndpointInfos client_infos = 8;
inline bool UserToBitHandshake::has_client_infos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserToBitHandshake::set_has_client_infos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserToBitHandshake::clear_has_client_infos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserToBitHandshake::clear_client_infos() {
  if (client_infos_ != NULL) client_infos_->Clear();
  clear_has_client_infos();
}
inline const ::exec::user::RpcEndpointInfos& UserToBitHandshake::_internal_client_infos() const {
  return *client_infos_;
}
inline const ::exec::user::RpcEndpointInfos& UserToBitHandshake::client_infos() const {
  const ::exec::user::RpcEndpointInfos* p = client_infos_;
  // @@protoc_insertion_point(field_get:exec.user.UserToBitHandshake.client_infos)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::user::RpcEndpointInfos*>(
      &::exec::user::_RpcEndpointInfos_default_instance_);
}
inline ::exec::user::RpcEndpointInfos* UserToBitHandshake::release_client_infos() {
  // @@protoc_insertion_point(field_release:exec.user.UserToBitHandshake.client_infos)
  clear_has_client_infos();
  ::exec::user::RpcEndpointInfos* temp = client_infos_;
  client_infos_ = NULL;
  return temp;
}
inline ::exec::user::RpcEndpointInfos* UserToBitHandshake::mutable_client_infos() {
  set_has_client_infos();
  if (client_infos_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::user::RpcEndpointInfos>(GetArenaNoVirtual());
    client_infos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.UserToBitHandshake.client_infos)
  return client_infos_;
}
inline void UserToBitHandshake::set_allocated_client_infos(::exec::user::RpcEndpointInfos* client_infos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete client_infos_;
  }
  if (client_infos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client_infos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client_infos, submessage_arena);
    }
    set_has_client_infos();
  } else {
    clear_has_client_infos();
  }
  client_infos_ = client_infos;
  // @@protoc_insertion_point(field_set_allocated:exec.user.UserToBitHandshake.client_infos)
}

// optional .exec.user.SaslSupport sasl_support = 9;
inline bool UserToBitHandshake::has_sasl_support() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserToBitHandshake::set_has_sasl_support() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserToBitHandshake::clear_has_sasl_support() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserToBitHandshake::clear_sasl_support() {
  sasl_support_ = 0;
  clear_has_sasl_support();
}
inline ::exec::user::SaslSupport UserToBitHandshake::sasl_support() const {
  // @@protoc_insertion_point(field_get:exec.user.UserToBitHandshake.sasl_support)
  return static_cast< ::exec::user::SaslSupport >(sasl_support_);
}
inline void UserToBitHandshake::set_sasl_support(::exec::user::SaslSupport value) {
  assert(::exec::user::SaslSupport_IsValid(value));
  set_has_sasl_support();
  sasl_support_ = value;
  // @@protoc_insertion_point(field_set:exec.user.UserToBitHandshake.sasl_support)
}

// -------------------------------------------------------------------

// RequestResults

// optional .exec.shared.QueryId query_id = 1;
inline bool RequestResults::has_query_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestResults::set_has_query_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestResults::clear_has_query_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::exec::shared::QueryId& RequestResults::_internal_query_id() const {
  return *query_id_;
}
inline const ::exec::shared::QueryId& RequestResults::query_id() const {
  const ::exec::shared::QueryId* p = query_id_;
  // @@protoc_insertion_point(field_get:exec.user.RequestResults.query_id)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::shared::QueryId*>(
      &::exec::shared::_QueryId_default_instance_);
}
inline ::exec::shared::QueryId* RequestResults::release_query_id() {
  // @@protoc_insertion_point(field_release:exec.user.RequestResults.query_id)
  clear_has_query_id();
  ::exec::shared::QueryId* temp = query_id_;
  query_id_ = NULL;
  return temp;
}
inline ::exec::shared::QueryId* RequestResults::mutable_query_id() {
  set_has_query_id();
  if (query_id_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::shared::QueryId>(GetArenaNoVirtual());
    query_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.RequestResults.query_id)
  return query_id_;
}
inline void RequestResults::set_allocated_query_id(::exec::shared::QueryId* query_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(query_id_);
  }
  if (query_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      query_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, query_id, submessage_arena);
    }
    set_has_query_id();
  } else {
    clear_has_query_id();
  }
  query_id_ = query_id;
  // @@protoc_insertion_point(field_set_allocated:exec.user.RequestResults.query_id)
}

// optional int32 maximum_responses = 2;
inline bool RequestResults::has_maximum_responses() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestResults::set_has_maximum_responses() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestResults::clear_has_maximum_responses() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestResults::clear_maximum_responses() {
  maximum_responses_ = 0;
  clear_has_maximum_responses();
}
inline ::google::protobuf::int32 RequestResults::maximum_responses() const {
  // @@protoc_insertion_point(field_get:exec.user.RequestResults.maximum_responses)
  return maximum_responses_;
}
inline void RequestResults::set_maximum_responses(::google::protobuf::int32 value) {
  set_has_maximum_responses();
  maximum_responses_ = value;
  // @@protoc_insertion_point(field_set:exec.user.RequestResults.maximum_responses)
}

// -------------------------------------------------------------------

// GetQueryPlanFragments

// required string query = 1;
inline bool GetQueryPlanFragments::has_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetQueryPlanFragments::set_has_query() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetQueryPlanFragments::clear_has_query() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetQueryPlanFragments::clear_query() {
  query_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_query();
}
inline const ::std::string& GetQueryPlanFragments::query() const {
  // @@protoc_insertion_point(field_get:exec.user.GetQueryPlanFragments.query)
  return query_.GetNoArena();
}
inline void GetQueryPlanFragments::set_query(const ::std::string& value) {
  set_has_query();
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.GetQueryPlanFragments.query)
}
#if LANG_CXX11
inline void GetQueryPlanFragments::set_query(::std::string&& value) {
  set_has_query();
  query_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.GetQueryPlanFragments.query)
}
#endif
inline void GetQueryPlanFragments::set_query(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_query();
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.GetQueryPlanFragments.query)
}
inline void GetQueryPlanFragments::set_query(const char* value, size_t size) {
  set_has_query();
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.GetQueryPlanFragments.query)
}
inline ::std::string* GetQueryPlanFragments::mutable_query() {
  set_has_query();
  // @@protoc_insertion_point(field_mutable:exec.user.GetQueryPlanFragments.query)
  return query_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetQueryPlanFragments::release_query() {
  // @@protoc_insertion_point(field_release:exec.user.GetQueryPlanFragments.query)
  if (!has_query()) {
    return NULL;
  }
  clear_has_query();
  return query_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetQueryPlanFragments::set_allocated_query(::std::string* query) {
  if (query != NULL) {
    set_has_query();
  } else {
    clear_has_query();
  }
  query_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), query);
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetQueryPlanFragments.query)
}

// optional .exec.shared.QueryType type = 2;
inline bool GetQueryPlanFragments::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetQueryPlanFragments::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetQueryPlanFragments::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetQueryPlanFragments::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::exec::shared::QueryType GetQueryPlanFragments::type() const {
  // @@protoc_insertion_point(field_get:exec.user.GetQueryPlanFragments.type)
  return static_cast< ::exec::shared::QueryType >(type_);
}
inline void GetQueryPlanFragments::set_type(::exec::shared::QueryType value) {
  assert(::exec::shared::QueryType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:exec.user.GetQueryPlanFragments.type)
}

// optional bool split_plan = 3 [default = false];
inline bool GetQueryPlanFragments::has_split_plan() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetQueryPlanFragments::set_has_split_plan() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetQueryPlanFragments::clear_has_split_plan() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetQueryPlanFragments::clear_split_plan() {
  split_plan_ = false;
  clear_has_split_plan();
}
inline bool GetQueryPlanFragments::split_plan() const {
  // @@protoc_insertion_point(field_get:exec.user.GetQueryPlanFragments.split_plan)
  return split_plan_;
}
inline void GetQueryPlanFragments::set_split_plan(bool value) {
  set_has_split_plan();
  split_plan_ = value;
  // @@protoc_insertion_point(field_set:exec.user.GetQueryPlanFragments.split_plan)
}

// -------------------------------------------------------------------

// QueryPlanFragments

// required .exec.shared.QueryResult.QueryState status = 1;
inline bool QueryPlanFragments::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryPlanFragments::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryPlanFragments::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryPlanFragments::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::exec::shared::QueryResult_QueryState QueryPlanFragments::status() const {
  // @@protoc_insertion_point(field_get:exec.user.QueryPlanFragments.status)
  return static_cast< ::exec::shared::QueryResult_QueryState >(status_);
}
inline void QueryPlanFragments::set_status(::exec::shared::QueryResult_QueryState value) {
  assert(::exec::shared::QueryResult_QueryState_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:exec.user.QueryPlanFragments.status)
}

// optional .exec.shared.QueryId query_id = 2;
inline bool QueryPlanFragments::has_query_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryPlanFragments::set_has_query_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryPlanFragments::clear_has_query_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::exec::shared::QueryId& QueryPlanFragments::_internal_query_id() const {
  return *query_id_;
}
inline const ::exec::shared::QueryId& QueryPlanFragments::query_id() const {
  const ::exec::shared::QueryId* p = query_id_;
  // @@protoc_insertion_point(field_get:exec.user.QueryPlanFragments.query_id)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::shared::QueryId*>(
      &::exec::shared::_QueryId_default_instance_);
}
inline ::exec::shared::QueryId* QueryPlanFragments::release_query_id() {
  // @@protoc_insertion_point(field_release:exec.user.QueryPlanFragments.query_id)
  clear_has_query_id();
  ::exec::shared::QueryId* temp = query_id_;
  query_id_ = NULL;
  return temp;
}
inline ::exec::shared::QueryId* QueryPlanFragments::mutable_query_id() {
  set_has_query_id();
  if (query_id_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::shared::QueryId>(GetArenaNoVirtual());
    query_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.QueryPlanFragments.query_id)
  return query_id_;
}
inline void QueryPlanFragments::set_allocated_query_id(::exec::shared::QueryId* query_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(query_id_);
  }
  if (query_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      query_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, query_id, submessage_arena);
    }
    set_has_query_id();
  } else {
    clear_has_query_id();
  }
  query_id_ = query_id;
  // @@protoc_insertion_point(field_set_allocated:exec.user.QueryPlanFragments.query_id)
}

// repeated .exec.bit.control.PlanFragment fragments = 3;
inline int QueryPlanFragments::fragments_size() const {
  return fragments_.size();
}
inline ::exec::bit::control::PlanFragment* QueryPlanFragments::mutable_fragments(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.QueryPlanFragments.fragments)
  return fragments_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment >*
QueryPlanFragments::mutable_fragments() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.QueryPlanFragments.fragments)
  return &fragments_;
}
inline const ::exec::bit::control::PlanFragment& QueryPlanFragments::fragments(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.QueryPlanFragments.fragments)
  return fragments_.Get(index);
}
inline ::exec::bit::control::PlanFragment* QueryPlanFragments::add_fragments() {
  // @@protoc_insertion_point(field_add:exec.user.QueryPlanFragments.fragments)
  return fragments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment >&
QueryPlanFragments::fragments() const {
  // @@protoc_insertion_point(field_list:exec.user.QueryPlanFragments.fragments)
  return fragments_;
}

// optional .exec.shared.DrillPBError error = 4;
inline bool QueryPlanFragments::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryPlanFragments::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryPlanFragments::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::exec::shared::DrillPBError& QueryPlanFragments::_internal_error() const {
  return *error_;
}
inline const ::exec::shared::DrillPBError& QueryPlanFragments::error() const {
  const ::exec::shared::DrillPBError* p = error_;
  // @@protoc_insertion_point(field_get:exec.user.QueryPlanFragments.error)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::shared::DrillPBError*>(
      &::exec::shared::_DrillPBError_default_instance_);
}
inline ::exec::shared::DrillPBError* QueryPlanFragments::release_error() {
  // @@protoc_insertion_point(field_release:exec.user.QueryPlanFragments.error)
  clear_has_error();
  ::exec::shared::DrillPBError* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::exec::shared::DrillPBError* QueryPlanFragments::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::shared::DrillPBError>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.QueryPlanFragments.error)
  return error_;
}
inline void QueryPlanFragments::set_allocated_error(::exec::shared::DrillPBError* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    set_has_error();
  } else {
    clear_has_error();
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:exec.user.QueryPlanFragments.error)
}

// -------------------------------------------------------------------

// BitToUserHandshake

// optional int32 rpc_version = 2;
inline bool BitToUserHandshake::has_rpc_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BitToUserHandshake::set_has_rpc_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BitToUserHandshake::clear_has_rpc_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BitToUserHandshake::clear_rpc_version() {
  rpc_version_ = 0;
  clear_has_rpc_version();
}
inline ::google::protobuf::int32 BitToUserHandshake::rpc_version() const {
  // @@protoc_insertion_point(field_get:exec.user.BitToUserHandshake.rpc_version)
  return rpc_version_;
}
inline void BitToUserHandshake::set_rpc_version(::google::protobuf::int32 value) {
  set_has_rpc_version();
  rpc_version_ = value;
  // @@protoc_insertion_point(field_set:exec.user.BitToUserHandshake.rpc_version)
}

// optional .exec.user.HandshakeStatus status = 3;
inline bool BitToUserHandshake::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BitToUserHandshake::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BitToUserHandshake::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BitToUserHandshake::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::exec::user::HandshakeStatus BitToUserHandshake::status() const {
  // @@protoc_insertion_point(field_get:exec.user.BitToUserHandshake.status)
  return static_cast< ::exec::user::HandshakeStatus >(status_);
}
inline void BitToUserHandshake::set_status(::exec::user::HandshakeStatus value) {
  assert(::exec::user::HandshakeStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:exec.user.BitToUserHandshake.status)
}

// optional string errorId = 4;
inline bool BitToUserHandshake::has_errorid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BitToUserHandshake::set_has_errorid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BitToUserHandshake::clear_has_errorid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BitToUserHandshake::clear_errorid() {
  errorid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errorid();
}
inline const ::std::string& BitToUserHandshake::errorid() const {
  // @@protoc_insertion_point(field_get:exec.user.BitToUserHandshake.errorId)
  return errorid_.GetNoArena();
}
inline void BitToUserHandshake::set_errorid(const ::std::string& value) {
  set_has_errorid();
  errorid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.BitToUserHandshake.errorId)
}
#if LANG_CXX11
inline void BitToUserHandshake::set_errorid(::std::string&& value) {
  set_has_errorid();
  errorid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.BitToUserHandshake.errorId)
}
#endif
inline void BitToUserHandshake::set_errorid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_errorid();
  errorid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.BitToUserHandshake.errorId)
}
inline void BitToUserHandshake::set_errorid(const char* value, size_t size) {
  set_has_errorid();
  errorid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.BitToUserHandshake.errorId)
}
inline ::std::string* BitToUserHandshake::mutable_errorid() {
  set_has_errorid();
  // @@protoc_insertion_point(field_mutable:exec.user.BitToUserHandshake.errorId)
  return errorid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BitToUserHandshake::release_errorid() {
  // @@protoc_insertion_point(field_release:exec.user.BitToUserHandshake.errorId)
  if (!has_errorid()) {
    return NULL;
  }
  clear_has_errorid();
  return errorid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BitToUserHandshake::set_allocated_errorid(::std::string* errorid) {
  if (errorid != NULL) {
    set_has_errorid();
  } else {
    clear_has_errorid();
  }
  errorid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errorid);
  // @@protoc_insertion_point(field_set_allocated:exec.user.BitToUserHandshake.errorId)
}

// optional string errorMessage = 5;
inline bool BitToUserHandshake::has_errormessage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BitToUserHandshake::set_has_errormessage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BitToUserHandshake::clear_has_errormessage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BitToUserHandshake::clear_errormessage() {
  errormessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errormessage();
}
inline const ::std::string& BitToUserHandshake::errormessage() const {
  // @@protoc_insertion_point(field_get:exec.user.BitToUserHandshake.errorMessage)
  return errormessage_.GetNoArena();
}
inline void BitToUserHandshake::set_errormessage(const ::std::string& value) {
  set_has_errormessage();
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.BitToUserHandshake.errorMessage)
}
#if LANG_CXX11
inline void BitToUserHandshake::set_errormessage(::std::string&& value) {
  set_has_errormessage();
  errormessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.BitToUserHandshake.errorMessage)
}
#endif
inline void BitToUserHandshake::set_errormessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_errormessage();
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.BitToUserHandshake.errorMessage)
}
inline void BitToUserHandshake::set_errormessage(const char* value, size_t size) {
  set_has_errormessage();
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.BitToUserHandshake.errorMessage)
}
inline ::std::string* BitToUserHandshake::mutable_errormessage() {
  set_has_errormessage();
  // @@protoc_insertion_point(field_mutable:exec.user.BitToUserHandshake.errorMessage)
  return errormessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BitToUserHandshake::release_errormessage() {
  // @@protoc_insertion_point(field_release:exec.user.BitToUserHandshake.errorMessage)
  if (!has_errormessage()) {
    return NULL;
  }
  clear_has_errormessage();
  return errormessage_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BitToUserHandshake::set_allocated_errormessage(::std::string* errormessage) {
  if (errormessage != NULL) {
    set_has_errormessage();
  } else {
    clear_has_errormessage();
  }
  errormessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errormessage);
  // @@protoc_insertion_point(field_set_allocated:exec.user.BitToUserHandshake.errorMessage)
}

// optional .exec.user.RpcEndpointInfos server_infos = 6;
inline bool BitToUserHandshake::has_server_infos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BitToUserHandshake::set_has_server_infos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BitToUserHandshake::clear_has_server_infos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BitToUserHandshake::clear_server_infos() {
  if (server_infos_ != NULL) server_infos_->Clear();
  clear_has_server_infos();
}
inline const ::exec::user::RpcEndpointInfos& BitToUserHandshake::_internal_server_infos() const {
  return *server_infos_;
}
inline const ::exec::user::RpcEndpointInfos& BitToUserHandshake::server_infos() const {
  const ::exec::user::RpcEndpointInfos* p = server_infos_;
  // @@protoc_insertion_point(field_get:exec.user.BitToUserHandshake.server_infos)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::user::RpcEndpointInfos*>(
      &::exec::user::_RpcEndpointInfos_default_instance_);
}
inline ::exec::user::RpcEndpointInfos* BitToUserHandshake::release_server_infos() {
  // @@protoc_insertion_point(field_release:exec.user.BitToUserHandshake.server_infos)
  clear_has_server_infos();
  ::exec::user::RpcEndpointInfos* temp = server_infos_;
  server_infos_ = NULL;
  return temp;
}
inline ::exec::user::RpcEndpointInfos* BitToUserHandshake::mutable_server_infos() {
  set_has_server_infos();
  if (server_infos_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::user::RpcEndpointInfos>(GetArenaNoVirtual());
    server_infos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.BitToUserHandshake.server_infos)
  return server_infos_;
}
inline void BitToUserHandshake::set_allocated_server_infos(::exec::user::RpcEndpointInfos* server_infos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_infos_;
  }
  if (server_infos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server_infos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server_infos, submessage_arena);
    }
    set_has_server_infos();
  } else {
    clear_has_server_infos();
  }
  server_infos_ = server_infos;
  // @@protoc_insertion_point(field_set_allocated:exec.user.BitToUserHandshake.server_infos)
}

// repeated string authenticationMechanisms = 7;
inline int BitToUserHandshake::authenticationmechanisms_size() const {
  return authenticationmechanisms_.size();
}
inline void BitToUserHandshake::clear_authenticationmechanisms() {
  authenticationmechanisms_.Clear();
}
inline const ::std::string& BitToUserHandshake::authenticationmechanisms(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.BitToUserHandshake.authenticationMechanisms)
  return authenticationmechanisms_.Get(index);
}
inline ::std::string* BitToUserHandshake::mutable_authenticationmechanisms(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.BitToUserHandshake.authenticationMechanisms)
  return authenticationmechanisms_.Mutable(index);
}
inline void BitToUserHandshake::set_authenticationmechanisms(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:exec.user.BitToUserHandshake.authenticationMechanisms)
  authenticationmechanisms_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BitToUserHandshake::set_authenticationmechanisms(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:exec.user.BitToUserHandshake.authenticationMechanisms)
  authenticationmechanisms_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BitToUserHandshake::set_authenticationmechanisms(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  authenticationmechanisms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:exec.user.BitToUserHandshake.authenticationMechanisms)
}
inline void BitToUserHandshake::set_authenticationmechanisms(int index, const char* value, size_t size) {
  authenticationmechanisms_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:exec.user.BitToUserHandshake.authenticationMechanisms)
}
inline ::std::string* BitToUserHandshake::add_authenticationmechanisms() {
  // @@protoc_insertion_point(field_add_mutable:exec.user.BitToUserHandshake.authenticationMechanisms)
  return authenticationmechanisms_.Add();
}
inline void BitToUserHandshake::add_authenticationmechanisms(const ::std::string& value) {
  authenticationmechanisms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:exec.user.BitToUserHandshake.authenticationMechanisms)
}
#if LANG_CXX11
inline void BitToUserHandshake::add_authenticationmechanisms(::std::string&& value) {
  authenticationmechanisms_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:exec.user.BitToUserHandshake.authenticationMechanisms)
}
#endif
inline void BitToUserHandshake::add_authenticationmechanisms(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  authenticationmechanisms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:exec.user.BitToUserHandshake.authenticationMechanisms)
}
inline void BitToUserHandshake::add_authenticationmechanisms(const char* value, size_t size) {
  authenticationmechanisms_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:exec.user.BitToUserHandshake.authenticationMechanisms)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BitToUserHandshake::authenticationmechanisms() const {
  // @@protoc_insertion_point(field_list:exec.user.BitToUserHandshake.authenticationMechanisms)
  return authenticationmechanisms_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BitToUserHandshake::mutable_authenticationmechanisms() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.BitToUserHandshake.authenticationMechanisms)
  return &authenticationmechanisms_;
}

// repeated .exec.user.RpcType supported_methods = 8;
inline int BitToUserHandshake::supported_methods_size() const {
  return supported_methods_.size();
}
inline void BitToUserHandshake::clear_supported_methods() {
  supported_methods_.Clear();
}
inline ::exec::user::RpcType BitToUserHandshake::supported_methods(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.BitToUserHandshake.supported_methods)
  return static_cast< ::exec::user::RpcType >(supported_methods_.Get(index));
}
inline void BitToUserHandshake::set_supported_methods(int index, ::exec::user::RpcType value) {
  assert(::exec::user::RpcType_IsValid(value));
  supported_methods_.Set(index, value);
  // @@protoc_insertion_point(field_set:exec.user.BitToUserHandshake.supported_methods)
}
inline void BitToUserHandshake::add_supported_methods(::exec::user::RpcType value) {
  assert(::exec::user::RpcType_IsValid(value));
  supported_methods_.Add(value);
  // @@protoc_insertion_point(field_add:exec.user.BitToUserHandshake.supported_methods)
}
inline const ::google::protobuf::RepeatedField<int>&
BitToUserHandshake::supported_methods() const {
  // @@protoc_insertion_point(field_list:exec.user.BitToUserHandshake.supported_methods)
  return supported_methods_;
}
inline ::google::protobuf::RepeatedField<int>*
BitToUserHandshake::mutable_supported_methods() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.BitToUserHandshake.supported_methods)
  return &supported_methods_;
}

// optional bool encrypted = 9;
inline bool BitToUserHandshake::has_encrypted() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BitToUserHandshake::set_has_encrypted() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BitToUserHandshake::clear_has_encrypted() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BitToUserHandshake::clear_encrypted() {
  encrypted_ = false;
  clear_has_encrypted();
}
inline bool BitToUserHandshake::encrypted() const {
  // @@protoc_insertion_point(field_get:exec.user.BitToUserHandshake.encrypted)
  return encrypted_;
}
inline void BitToUserHandshake::set_encrypted(bool value) {
  set_has_encrypted();
  encrypted_ = value;
  // @@protoc_insertion_point(field_set:exec.user.BitToUserHandshake.encrypted)
}

// optional int32 maxWrappedSize = 10;
inline bool BitToUserHandshake::has_maxwrappedsize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BitToUserHandshake::set_has_maxwrappedsize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BitToUserHandshake::clear_has_maxwrappedsize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BitToUserHandshake::clear_maxwrappedsize() {
  maxwrappedsize_ = 0;
  clear_has_maxwrappedsize();
}
inline ::google::protobuf::int32 BitToUserHandshake::maxwrappedsize() const {
  // @@protoc_insertion_point(field_get:exec.user.BitToUserHandshake.maxWrappedSize)
  return maxwrappedsize_;
}
inline void BitToUserHandshake::set_maxwrappedsize(::google::protobuf::int32 value) {
  set_has_maxwrappedsize();
  maxwrappedsize_ = value;
  // @@protoc_insertion_point(field_set:exec.user.BitToUserHandshake.maxWrappedSize)
}

// -------------------------------------------------------------------

// LikeFilter

// optional string pattern = 1;
inline bool LikeFilter::has_pattern() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LikeFilter::set_has_pattern() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LikeFilter::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LikeFilter::clear_pattern() {
  pattern_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pattern();
}
inline const ::std::string& LikeFilter::pattern() const {
  // @@protoc_insertion_point(field_get:exec.user.LikeFilter.pattern)
  return pattern_.GetNoArena();
}
inline void LikeFilter::set_pattern(const ::std::string& value) {
  set_has_pattern();
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.LikeFilter.pattern)
}
#if LANG_CXX11
inline void LikeFilter::set_pattern(::std::string&& value) {
  set_has_pattern();
  pattern_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.LikeFilter.pattern)
}
#endif
inline void LikeFilter::set_pattern(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pattern();
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.LikeFilter.pattern)
}
inline void LikeFilter::set_pattern(const char* value, size_t size) {
  set_has_pattern();
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.LikeFilter.pattern)
}
inline ::std::string* LikeFilter::mutable_pattern() {
  set_has_pattern();
  // @@protoc_insertion_point(field_mutable:exec.user.LikeFilter.pattern)
  return pattern_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LikeFilter::release_pattern() {
  // @@protoc_insertion_point(field_release:exec.user.LikeFilter.pattern)
  if (!has_pattern()) {
    return NULL;
  }
  clear_has_pattern();
  return pattern_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LikeFilter::set_allocated_pattern(::std::string* pattern) {
  if (pattern != NULL) {
    set_has_pattern();
  } else {
    clear_has_pattern();
  }
  pattern_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pattern);
  // @@protoc_insertion_point(field_set_allocated:exec.user.LikeFilter.pattern)
}

// optional string escape = 2;
inline bool LikeFilter::has_escape() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LikeFilter::set_has_escape() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LikeFilter::clear_has_escape() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LikeFilter::clear_escape() {
  escape_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_escape();
}
inline const ::std::string& LikeFilter::escape() const {
  // @@protoc_insertion_point(field_get:exec.user.LikeFilter.escape)
  return escape_.GetNoArena();
}
inline void LikeFilter::set_escape(const ::std::string& value) {
  set_has_escape();
  escape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.LikeFilter.escape)
}
#if LANG_CXX11
inline void LikeFilter::set_escape(::std::string&& value) {
  set_has_escape();
  escape_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.LikeFilter.escape)
}
#endif
inline void LikeFilter::set_escape(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_escape();
  escape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.LikeFilter.escape)
}
inline void LikeFilter::set_escape(const char* value, size_t size) {
  set_has_escape();
  escape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.LikeFilter.escape)
}
inline ::std::string* LikeFilter::mutable_escape() {
  set_has_escape();
  // @@protoc_insertion_point(field_mutable:exec.user.LikeFilter.escape)
  return escape_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LikeFilter::release_escape() {
  // @@protoc_insertion_point(field_release:exec.user.LikeFilter.escape)
  if (!has_escape()) {
    return NULL;
  }
  clear_has_escape();
  return escape_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LikeFilter::set_allocated_escape(::std::string* escape) {
  if (escape != NULL) {
    set_has_escape();
  } else {
    clear_has_escape();
  }
  escape_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), escape);
  // @@protoc_insertion_point(field_set_allocated:exec.user.LikeFilter.escape)
}

// -------------------------------------------------------------------

// GetCatalogsReq

// optional .exec.user.LikeFilter catalog_name_filter = 1;
inline bool GetCatalogsReq::has_catalog_name_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCatalogsReq::set_has_catalog_name_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCatalogsReq::clear_has_catalog_name_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCatalogsReq::clear_catalog_name_filter() {
  if (catalog_name_filter_ != NULL) catalog_name_filter_->Clear();
  clear_has_catalog_name_filter();
}
inline const ::exec::user::LikeFilter& GetCatalogsReq::_internal_catalog_name_filter() const {
  return *catalog_name_filter_;
}
inline const ::exec::user::LikeFilter& GetCatalogsReq::catalog_name_filter() const {
  const ::exec::user::LikeFilter* p = catalog_name_filter_;
  // @@protoc_insertion_point(field_get:exec.user.GetCatalogsReq.catalog_name_filter)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::user::LikeFilter*>(
      &::exec::user::_LikeFilter_default_instance_);
}
inline ::exec::user::LikeFilter* GetCatalogsReq::release_catalog_name_filter() {
  // @@protoc_insertion_point(field_release:exec.user.GetCatalogsReq.catalog_name_filter)
  clear_has_catalog_name_filter();
  ::exec::user::LikeFilter* temp = catalog_name_filter_;
  catalog_name_filter_ = NULL;
  return temp;
}
inline ::exec::user::LikeFilter* GetCatalogsReq::mutable_catalog_name_filter() {
  set_has_catalog_name_filter();
  if (catalog_name_filter_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::user::LikeFilter>(GetArenaNoVirtual());
    catalog_name_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.GetCatalogsReq.catalog_name_filter)
  return catalog_name_filter_;
}
inline void GetCatalogsReq::set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete catalog_name_filter_;
  }
  if (catalog_name_filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      catalog_name_filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, catalog_name_filter, submessage_arena);
    }
    set_has_catalog_name_filter();
  } else {
    clear_has_catalog_name_filter();
  }
  catalog_name_filter_ = catalog_name_filter;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetCatalogsReq.catalog_name_filter)
}

// -------------------------------------------------------------------

// CatalogMetadata

// optional string catalog_name = 1;
inline bool CatalogMetadata::has_catalog_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CatalogMetadata::set_has_catalog_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CatalogMetadata::clear_has_catalog_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CatalogMetadata::clear_catalog_name() {
  catalog_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_catalog_name();
}
inline const ::std::string& CatalogMetadata::catalog_name() const {
  // @@protoc_insertion_point(field_get:exec.user.CatalogMetadata.catalog_name)
  return catalog_name_.GetNoArena();
}
inline void CatalogMetadata::set_catalog_name(const ::std::string& value) {
  set_has_catalog_name();
  catalog_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.CatalogMetadata.catalog_name)
}
#if LANG_CXX11
inline void CatalogMetadata::set_catalog_name(::std::string&& value) {
  set_has_catalog_name();
  catalog_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.CatalogMetadata.catalog_name)
}
#endif
inline void CatalogMetadata::set_catalog_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_catalog_name();
  catalog_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.CatalogMetadata.catalog_name)
}
inline void CatalogMetadata::set_catalog_name(const char* value, size_t size) {
  set_has_catalog_name();
  catalog_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.CatalogMetadata.catalog_name)
}
inline ::std::string* CatalogMetadata::mutable_catalog_name() {
  set_has_catalog_name();
  // @@protoc_insertion_point(field_mutable:exec.user.CatalogMetadata.catalog_name)
  return catalog_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CatalogMetadata::release_catalog_name() {
  // @@protoc_insertion_point(field_release:exec.user.CatalogMetadata.catalog_name)
  if (!has_catalog_name()) {
    return NULL;
  }
  clear_has_catalog_name();
  return catalog_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CatalogMetadata::set_allocated_catalog_name(::std::string* catalog_name) {
  if (catalog_name != NULL) {
    set_has_catalog_name();
  } else {
    clear_has_catalog_name();
  }
  catalog_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), catalog_name);
  // @@protoc_insertion_point(field_set_allocated:exec.user.CatalogMetadata.catalog_name)
}

// optional string description = 2;
inline bool CatalogMetadata::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CatalogMetadata::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CatalogMetadata::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CatalogMetadata::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& CatalogMetadata::description() const {
  // @@protoc_insertion_point(field_get:exec.user.CatalogMetadata.description)
  return description_.GetNoArena();
}
inline void CatalogMetadata::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.CatalogMetadata.description)
}
#if LANG_CXX11
inline void CatalogMetadata::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.CatalogMetadata.description)
}
#endif
inline void CatalogMetadata::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.CatalogMetadata.description)
}
inline void CatalogMetadata::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.CatalogMetadata.description)
}
inline ::std::string* CatalogMetadata::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:exec.user.CatalogMetadata.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CatalogMetadata::release_description() {
  // @@protoc_insertion_point(field_release:exec.user.CatalogMetadata.description)
  if (!has_description()) {
    return NULL;
  }
  clear_has_description();
  return description_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CatalogMetadata::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:exec.user.CatalogMetadata.description)
}

// optional string connect = 3;
inline bool CatalogMetadata::has_connect() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CatalogMetadata::set_has_connect() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CatalogMetadata::clear_has_connect() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CatalogMetadata::clear_connect() {
  connect_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_connect();
}
inline const ::std::string& CatalogMetadata::connect() const {
  // @@protoc_insertion_point(field_get:exec.user.CatalogMetadata.connect)
  return connect_.GetNoArena();
}
inline void CatalogMetadata::set_connect(const ::std::string& value) {
  set_has_connect();
  connect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.CatalogMetadata.connect)
}
#if LANG_CXX11
inline void CatalogMetadata::set_connect(::std::string&& value) {
  set_has_connect();
  connect_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.CatalogMetadata.connect)
}
#endif
inline void CatalogMetadata::set_connect(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_connect();
  connect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.CatalogMetadata.connect)
}
inline void CatalogMetadata::set_connect(const char* value, size_t size) {
  set_has_connect();
  connect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.CatalogMetadata.connect)
}
inline ::std::string* CatalogMetadata::mutable_connect() {
  set_has_connect();
  // @@protoc_insertion_point(field_mutable:exec.user.CatalogMetadata.connect)
  return connect_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CatalogMetadata::release_connect() {
  // @@protoc_insertion_point(field_release:exec.user.CatalogMetadata.connect)
  if (!has_connect()) {
    return NULL;
  }
  clear_has_connect();
  return connect_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CatalogMetadata::set_allocated_connect(::std::string* connect) {
  if (connect != NULL) {
    set_has_connect();
  } else {
    clear_has_connect();
  }
  connect_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), connect);
  // @@protoc_insertion_point(field_set_allocated:exec.user.CatalogMetadata.connect)
}

// -------------------------------------------------------------------

// GetCatalogsResp

// optional .exec.user.RequestStatus status = 1;
inline bool GetCatalogsResp::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetCatalogsResp::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetCatalogsResp::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetCatalogsResp::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::exec::user::RequestStatus GetCatalogsResp::status() const {
  // @@protoc_insertion_point(field_get:exec.user.GetCatalogsResp.status)
  return static_cast< ::exec::user::RequestStatus >(status_);
}
inline void GetCatalogsResp::set_status(::exec::user::RequestStatus value) {
  assert(::exec::user::RequestStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:exec.user.GetCatalogsResp.status)
}

// repeated .exec.user.CatalogMetadata catalogs = 2;
inline int GetCatalogsResp::catalogs_size() const {
  return catalogs_.size();
}
inline void GetCatalogsResp::clear_catalogs() {
  catalogs_.Clear();
}
inline ::exec::user::CatalogMetadata* GetCatalogsResp::mutable_catalogs(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.GetCatalogsResp.catalogs)
  return catalogs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::exec::user::CatalogMetadata >*
GetCatalogsResp::mutable_catalogs() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.GetCatalogsResp.catalogs)
  return &catalogs_;
}
inline const ::exec::user::CatalogMetadata& GetCatalogsResp::catalogs(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.GetCatalogsResp.catalogs)
  return catalogs_.Get(index);
}
inline ::exec::user::CatalogMetadata* GetCatalogsResp::add_catalogs() {
  // @@protoc_insertion_point(field_add:exec.user.GetCatalogsResp.catalogs)
  return catalogs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::user::CatalogMetadata >&
GetCatalogsResp::catalogs() const {
  // @@protoc_insertion_point(field_list:exec.user.GetCatalogsResp.catalogs)
  return catalogs_;
}

// optional .exec.shared.DrillPBError error = 3;
inline bool GetCatalogsResp::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCatalogsResp::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCatalogsResp::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::exec::shared::DrillPBError& GetCatalogsResp::_internal_error() const {
  return *error_;
}
inline const ::exec::shared::DrillPBError& GetCatalogsResp::error() const {
  const ::exec::shared::DrillPBError* p = error_;
  // @@protoc_insertion_point(field_get:exec.user.GetCatalogsResp.error)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::shared::DrillPBError*>(
      &::exec::shared::_DrillPBError_default_instance_);
}
inline ::exec::shared::DrillPBError* GetCatalogsResp::release_error() {
  // @@protoc_insertion_point(field_release:exec.user.GetCatalogsResp.error)
  clear_has_error();
  ::exec::shared::DrillPBError* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::exec::shared::DrillPBError* GetCatalogsResp::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::shared::DrillPBError>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.GetCatalogsResp.error)
  return error_;
}
inline void GetCatalogsResp::set_allocated_error(::exec::shared::DrillPBError* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    set_has_error();
  } else {
    clear_has_error();
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetCatalogsResp.error)
}

// -------------------------------------------------------------------

// GetSchemasReq

// optional .exec.user.LikeFilter catalog_name_filter = 1;
inline bool GetSchemasReq::has_catalog_name_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSchemasReq::set_has_catalog_name_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSchemasReq::clear_has_catalog_name_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSchemasReq::clear_catalog_name_filter() {
  if (catalog_name_filter_ != NULL) catalog_name_filter_->Clear();
  clear_has_catalog_name_filter();
}
inline const ::exec::user::LikeFilter& GetSchemasReq::_internal_catalog_name_filter() const {
  return *catalog_name_filter_;
}
inline const ::exec::user::LikeFilter& GetSchemasReq::catalog_name_filter() const {
  const ::exec::user::LikeFilter* p = catalog_name_filter_;
  // @@protoc_insertion_point(field_get:exec.user.GetSchemasReq.catalog_name_filter)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::user::LikeFilter*>(
      &::exec::user::_LikeFilter_default_instance_);
}
inline ::exec::user::LikeFilter* GetSchemasReq::release_catalog_name_filter() {
  // @@protoc_insertion_point(field_release:exec.user.GetSchemasReq.catalog_name_filter)
  clear_has_catalog_name_filter();
  ::exec::user::LikeFilter* temp = catalog_name_filter_;
  catalog_name_filter_ = NULL;
  return temp;
}
inline ::exec::user::LikeFilter* GetSchemasReq::mutable_catalog_name_filter() {
  set_has_catalog_name_filter();
  if (catalog_name_filter_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::user::LikeFilter>(GetArenaNoVirtual());
    catalog_name_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.GetSchemasReq.catalog_name_filter)
  return catalog_name_filter_;
}
inline void GetSchemasReq::set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete catalog_name_filter_;
  }
  if (catalog_name_filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      catalog_name_filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, catalog_name_filter, submessage_arena);
    }
    set_has_catalog_name_filter();
  } else {
    clear_has_catalog_name_filter();
  }
  catalog_name_filter_ = catalog_name_filter;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetSchemasReq.catalog_name_filter)
}

// optional .exec.user.LikeFilter schema_name_filter = 2;
inline bool GetSchemasReq::has_schema_name_filter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSchemasReq::set_has_schema_name_filter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetSchemasReq::clear_has_schema_name_filter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetSchemasReq::clear_schema_name_filter() {
  if (schema_name_filter_ != NULL) schema_name_filter_->Clear();
  clear_has_schema_name_filter();
}
inline const ::exec::user::LikeFilter& GetSchemasReq::_internal_schema_name_filter() const {
  return *schema_name_filter_;
}
inline const ::exec::user::LikeFilter& GetSchemasReq::schema_name_filter() const {
  const ::exec::user::LikeFilter* p = schema_name_filter_;
  // @@protoc_insertion_point(field_get:exec.user.GetSchemasReq.schema_name_filter)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::user::LikeFilter*>(
      &::exec::user::_LikeFilter_default_instance_);
}
inline ::exec::user::LikeFilter* GetSchemasReq::release_schema_name_filter() {
  // @@protoc_insertion_point(field_release:exec.user.GetSchemasReq.schema_name_filter)
  clear_has_schema_name_filter();
  ::exec::user::LikeFilter* temp = schema_name_filter_;
  schema_name_filter_ = NULL;
  return temp;
}
inline ::exec::user::LikeFilter* GetSchemasReq::mutable_schema_name_filter() {
  set_has_schema_name_filter();
  if (schema_name_filter_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::user::LikeFilter>(GetArenaNoVirtual());
    schema_name_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.GetSchemasReq.schema_name_filter)
  return schema_name_filter_;
}
inline void GetSchemasReq::set_allocated_schema_name_filter(::exec::user::LikeFilter* schema_name_filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete schema_name_filter_;
  }
  if (schema_name_filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      schema_name_filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, schema_name_filter, submessage_arena);
    }
    set_has_schema_name_filter();
  } else {
    clear_has_schema_name_filter();
  }
  schema_name_filter_ = schema_name_filter;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetSchemasReq.schema_name_filter)
}

// -------------------------------------------------------------------

// SchemaMetadata

// optional string catalog_name = 1;
inline bool SchemaMetadata::has_catalog_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaMetadata::set_has_catalog_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaMetadata::clear_has_catalog_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaMetadata::clear_catalog_name() {
  catalog_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_catalog_name();
}
inline const ::std::string& SchemaMetadata::catalog_name() const {
  // @@protoc_insertion_point(field_get:exec.user.SchemaMetadata.catalog_name)
  return catalog_name_.GetNoArena();
}
inline void SchemaMetadata::set_catalog_name(const ::std::string& value) {
  set_has_catalog_name();
  catalog_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.SchemaMetadata.catalog_name)
}
#if LANG_CXX11
inline void SchemaMetadata::set_catalog_name(::std::string&& value) {
  set_has_catalog_name();
  catalog_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.SchemaMetadata.catalog_name)
}
#endif
inline void SchemaMetadata::set_catalog_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_catalog_name();
  catalog_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.SchemaMetadata.catalog_name)
}
inline void SchemaMetadata::set_catalog_name(const char* value, size_t size) {
  set_has_catalog_name();
  catalog_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.SchemaMetadata.catalog_name)
}
inline ::std::string* SchemaMetadata::mutable_catalog_name() {
  set_has_catalog_name();
  // @@protoc_insertion_point(field_mutable:exec.user.SchemaMetadata.catalog_name)
  return catalog_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SchemaMetadata::release_catalog_name() {
  // @@protoc_insertion_point(field_release:exec.user.SchemaMetadata.catalog_name)
  if (!has_catalog_name()) {
    return NULL;
  }
  clear_has_catalog_name();
  return catalog_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SchemaMetadata::set_allocated_catalog_name(::std::string* catalog_name) {
  if (catalog_name != NULL) {
    set_has_catalog_name();
  } else {
    clear_has_catalog_name();
  }
  catalog_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), catalog_name);
  // @@protoc_insertion_point(field_set_allocated:exec.user.SchemaMetadata.catalog_name)
}

// optional string schema_name = 2;
inline bool SchemaMetadata::has_schema_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaMetadata::set_has_schema_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaMetadata::clear_has_schema_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaMetadata::clear_schema_name() {
  schema_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_schema_name();
}
inline const ::std::string& SchemaMetadata::schema_name() const {
  // @@protoc_insertion_point(field_get:exec.user.SchemaMetadata.schema_name)
  return schema_name_.GetNoArena();
}
inline void SchemaMetadata::set_schema_name(const ::std::string& value) {
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.SchemaMetadata.schema_name)
}
#if LANG_CXX11
inline void SchemaMetadata::set_schema_name(::std::string&& value) {
  set_has_schema_name();
  schema_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.SchemaMetadata.schema_name)
}
#endif
inline void SchemaMetadata::set_schema_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.SchemaMetadata.schema_name)
}
inline void SchemaMetadata::set_schema_name(const char* value, size_t size) {
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.SchemaMetadata.schema_name)
}
inline ::std::string* SchemaMetadata::mutable_schema_name() {
  set_has_schema_name();
  // @@protoc_insertion_point(field_mutable:exec.user.SchemaMetadata.schema_name)
  return schema_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SchemaMetadata::release_schema_name() {
  // @@protoc_insertion_point(field_release:exec.user.SchemaMetadata.schema_name)
  if (!has_schema_name()) {
    return NULL;
  }
  clear_has_schema_name();
  return schema_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SchemaMetadata::set_allocated_schema_name(::std::string* schema_name) {
  if (schema_name != NULL) {
    set_has_schema_name();
  } else {
    clear_has_schema_name();
  }
  schema_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schema_name);
  // @@protoc_insertion_point(field_set_allocated:exec.user.SchemaMetadata.schema_name)
}

// optional string owner = 3;
inline bool SchemaMetadata::has_owner() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaMetadata::set_has_owner() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaMetadata::clear_has_owner() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaMetadata::clear_owner() {
  owner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_owner();
}
inline const ::std::string& SchemaMetadata::owner() const {
  // @@protoc_insertion_point(field_get:exec.user.SchemaMetadata.owner)
  return owner_.GetNoArena();
}
inline void SchemaMetadata::set_owner(const ::std::string& value) {
  set_has_owner();
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.SchemaMetadata.owner)
}
#if LANG_CXX11
inline void SchemaMetadata::set_owner(::std::string&& value) {
  set_has_owner();
  owner_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.SchemaMetadata.owner)
}
#endif
inline void SchemaMetadata::set_owner(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_owner();
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.SchemaMetadata.owner)
}
inline void SchemaMetadata::set_owner(const char* value, size_t size) {
  set_has_owner();
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.SchemaMetadata.owner)
}
inline ::std::string* SchemaMetadata::mutable_owner() {
  set_has_owner();
  // @@protoc_insertion_point(field_mutable:exec.user.SchemaMetadata.owner)
  return owner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SchemaMetadata::release_owner() {
  // @@protoc_insertion_point(field_release:exec.user.SchemaMetadata.owner)
  if (!has_owner()) {
    return NULL;
  }
  clear_has_owner();
  return owner_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SchemaMetadata::set_allocated_owner(::std::string* owner) {
  if (owner != NULL) {
    set_has_owner();
  } else {
    clear_has_owner();
  }
  owner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:exec.user.SchemaMetadata.owner)
}

// optional string type = 4;
inline bool SchemaMetadata::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemaMetadata::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SchemaMetadata::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SchemaMetadata::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& SchemaMetadata::type() const {
  // @@protoc_insertion_point(field_get:exec.user.SchemaMetadata.type)
  return type_.GetNoArena();
}
inline void SchemaMetadata::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.SchemaMetadata.type)
}
#if LANG_CXX11
inline void SchemaMetadata::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.SchemaMetadata.type)
}
#endif
inline void SchemaMetadata::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.SchemaMetadata.type)
}
inline void SchemaMetadata::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.SchemaMetadata.type)
}
inline ::std::string* SchemaMetadata::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:exec.user.SchemaMetadata.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SchemaMetadata::release_type() {
  // @@protoc_insertion_point(field_release:exec.user.SchemaMetadata.type)
  if (!has_type()) {
    return NULL;
  }
  clear_has_type();
  return type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SchemaMetadata::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:exec.user.SchemaMetadata.type)
}

// optional string mutable = 5;
inline bool SchemaMetadata::has_mutable_() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchemaMetadata::set_has_mutable_() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SchemaMetadata::clear_has_mutable_() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SchemaMetadata::clear_mutable_() {
  mutable__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mutable_();
}
inline const ::std::string& SchemaMetadata::mutable_() const {
  // @@protoc_insertion_point(field_get:exec.user.SchemaMetadata.mutable)
  return mutable__.GetNoArena();
}
inline void SchemaMetadata::set_mutable_(const ::std::string& value) {
  set_has_mutable_();
  mutable__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.SchemaMetadata.mutable)
}
#if LANG_CXX11
inline void SchemaMetadata::set_mutable_(::std::string&& value) {
  set_has_mutable_();
  mutable__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.SchemaMetadata.mutable)
}
#endif
inline void SchemaMetadata::set_mutable_(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mutable_();
  mutable__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.SchemaMetadata.mutable)
}
inline void SchemaMetadata::set_mutable_(const char* value, size_t size) {
  set_has_mutable_();
  mutable__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.SchemaMetadata.mutable)
}
inline ::std::string* SchemaMetadata::mutable_mutable_() {
  set_has_mutable_();
  // @@protoc_insertion_point(field_mutable:exec.user.SchemaMetadata.mutable)
  return mutable__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SchemaMetadata::release_mutable_() {
  // @@protoc_insertion_point(field_release:exec.user.SchemaMetadata.mutable)
  if (!has_mutable_()) {
    return NULL;
  }
  clear_has_mutable_();
  return mutable__.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SchemaMetadata::set_allocated_mutable_(::std::string* mutable_) {
  if (mutable_ != NULL) {
    set_has_mutable_();
  } else {
    clear_has_mutable_();
  }
  mutable__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mutable_);
  // @@protoc_insertion_point(field_set_allocated:exec.user.SchemaMetadata.mutable)
}

// -------------------------------------------------------------------

// GetSchemasResp

// optional .exec.user.RequestStatus status = 1;
inline bool GetSchemasResp::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSchemasResp::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetSchemasResp::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetSchemasResp::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::exec::user::RequestStatus GetSchemasResp::status() const {
  // @@protoc_insertion_point(field_get:exec.user.GetSchemasResp.status)
  return static_cast< ::exec::user::RequestStatus >(status_);
}
inline void GetSchemasResp::set_status(::exec::user::RequestStatus value) {
  assert(::exec::user::RequestStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:exec.user.GetSchemasResp.status)
}

// repeated .exec.user.SchemaMetadata schemas = 2;
inline int GetSchemasResp::schemas_size() const {
  return schemas_.size();
}
inline void GetSchemasResp::clear_schemas() {
  schemas_.Clear();
}
inline ::exec::user::SchemaMetadata* GetSchemasResp::mutable_schemas(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.GetSchemasResp.schemas)
  return schemas_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::exec::user::SchemaMetadata >*
GetSchemasResp::mutable_schemas() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.GetSchemasResp.schemas)
  return &schemas_;
}
inline const ::exec::user::SchemaMetadata& GetSchemasResp::schemas(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.GetSchemasResp.schemas)
  return schemas_.Get(index);
}
inline ::exec::user::SchemaMetadata* GetSchemasResp::add_schemas() {
  // @@protoc_insertion_point(field_add:exec.user.GetSchemasResp.schemas)
  return schemas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::user::SchemaMetadata >&
GetSchemasResp::schemas() const {
  // @@protoc_insertion_point(field_list:exec.user.GetSchemasResp.schemas)
  return schemas_;
}

// optional .exec.shared.DrillPBError error = 3;
inline bool GetSchemasResp::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSchemasResp::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSchemasResp::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::exec::shared::DrillPBError& GetSchemasResp::_internal_error() const {
  return *error_;
}
inline const ::exec::shared::DrillPBError& GetSchemasResp::error() const {
  const ::exec::shared::DrillPBError* p = error_;
  // @@protoc_insertion_point(field_get:exec.user.GetSchemasResp.error)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::shared::DrillPBError*>(
      &::exec::shared::_DrillPBError_default_instance_);
}
inline ::exec::shared::DrillPBError* GetSchemasResp::release_error() {
  // @@protoc_insertion_point(field_release:exec.user.GetSchemasResp.error)
  clear_has_error();
  ::exec::shared::DrillPBError* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::exec::shared::DrillPBError* GetSchemasResp::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::shared::DrillPBError>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.GetSchemasResp.error)
  return error_;
}
inline void GetSchemasResp::set_allocated_error(::exec::shared::DrillPBError* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    set_has_error();
  } else {
    clear_has_error();
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetSchemasResp.error)
}

// -------------------------------------------------------------------

// GetTablesReq

// optional .exec.user.LikeFilter catalog_name_filter = 1;
inline bool GetTablesReq::has_catalog_name_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTablesReq::set_has_catalog_name_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTablesReq::clear_has_catalog_name_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTablesReq::clear_catalog_name_filter() {
  if (catalog_name_filter_ != NULL) catalog_name_filter_->Clear();
  clear_has_catalog_name_filter();
}
inline const ::exec::user::LikeFilter& GetTablesReq::_internal_catalog_name_filter() const {
  return *catalog_name_filter_;
}
inline const ::exec::user::LikeFilter& GetTablesReq::catalog_name_filter() const {
  const ::exec::user::LikeFilter* p = catalog_name_filter_;
  // @@protoc_insertion_point(field_get:exec.user.GetTablesReq.catalog_name_filter)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::user::LikeFilter*>(
      &::exec::user::_LikeFilter_default_instance_);
}
inline ::exec::user::LikeFilter* GetTablesReq::release_catalog_name_filter() {
  // @@protoc_insertion_point(field_release:exec.user.GetTablesReq.catalog_name_filter)
  clear_has_catalog_name_filter();
  ::exec::user::LikeFilter* temp = catalog_name_filter_;
  catalog_name_filter_ = NULL;
  return temp;
}
inline ::exec::user::LikeFilter* GetTablesReq::mutable_catalog_name_filter() {
  set_has_catalog_name_filter();
  if (catalog_name_filter_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::user::LikeFilter>(GetArenaNoVirtual());
    catalog_name_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.GetTablesReq.catalog_name_filter)
  return catalog_name_filter_;
}
inline void GetTablesReq::set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete catalog_name_filter_;
  }
  if (catalog_name_filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      catalog_name_filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, catalog_name_filter, submessage_arena);
    }
    set_has_catalog_name_filter();
  } else {
    clear_has_catalog_name_filter();
  }
  catalog_name_filter_ = catalog_name_filter;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetTablesReq.catalog_name_filter)
}

// optional .exec.user.LikeFilter schema_name_filter = 2;
inline bool GetTablesReq::has_schema_name_filter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTablesReq::set_has_schema_name_filter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTablesReq::clear_has_schema_name_filter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTablesReq::clear_schema_name_filter() {
  if (schema_name_filter_ != NULL) schema_name_filter_->Clear();
  clear_has_schema_name_filter();
}
inline const ::exec::user::LikeFilter& GetTablesReq::_internal_schema_name_filter() const {
  return *schema_name_filter_;
}
inline const ::exec::user::LikeFilter& GetTablesReq::schema_name_filter() const {
  const ::exec::user::LikeFilter* p = schema_name_filter_;
  // @@protoc_insertion_point(field_get:exec.user.GetTablesReq.schema_name_filter)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::user::LikeFilter*>(
      &::exec::user::_LikeFilter_default_instance_);
}
inline ::exec::user::LikeFilter* GetTablesReq::release_schema_name_filter() {
  // @@protoc_insertion_point(field_release:exec.user.GetTablesReq.schema_name_filter)
  clear_has_schema_name_filter();
  ::exec::user::LikeFilter* temp = schema_name_filter_;
  schema_name_filter_ = NULL;
  return temp;
}
inline ::exec::user::LikeFilter* GetTablesReq::mutable_schema_name_filter() {
  set_has_schema_name_filter();
  if (schema_name_filter_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::user::LikeFilter>(GetArenaNoVirtual());
    schema_name_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.GetTablesReq.schema_name_filter)
  return schema_name_filter_;
}
inline void GetTablesReq::set_allocated_schema_name_filter(::exec::user::LikeFilter* schema_name_filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete schema_name_filter_;
  }
  if (schema_name_filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      schema_name_filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, schema_name_filter, submessage_arena);
    }
    set_has_schema_name_filter();
  } else {
    clear_has_schema_name_filter();
  }
  schema_name_filter_ = schema_name_filter;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetTablesReq.schema_name_filter)
}

// optional .exec.user.LikeFilter table_name_filter = 3;
inline bool GetTablesReq::has_table_name_filter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetTablesReq::set_has_table_name_filter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetTablesReq::clear_has_table_name_filter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetTablesReq::clear_table_name_filter() {
  if (table_name_filter_ != NULL) table_name_filter_->Clear();
  clear_has_table_name_filter();
}
inline const ::exec::user::LikeFilter& GetTablesReq::_internal_table_name_filter() const {
  return *table_name_filter_;
}
inline const ::exec::user::LikeFilter& GetTablesReq::table_name_filter() const {
  const ::exec::user::LikeFilter* p = table_name_filter_;
  // @@protoc_insertion_point(field_get:exec.user.GetTablesReq.table_name_filter)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::user::LikeFilter*>(
      &::exec::user::_LikeFilter_default_instance_);
}
inline ::exec::user::LikeFilter* GetTablesReq::release_table_name_filter() {
  // @@protoc_insertion_point(field_release:exec.user.GetTablesReq.table_name_filter)
  clear_has_table_name_filter();
  ::exec::user::LikeFilter* temp = table_name_filter_;
  table_name_filter_ = NULL;
  return temp;
}
inline ::exec::user::LikeFilter* GetTablesReq::mutable_table_name_filter() {
  set_has_table_name_filter();
  if (table_name_filter_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::user::LikeFilter>(GetArenaNoVirtual());
    table_name_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.GetTablesReq.table_name_filter)
  return table_name_filter_;
}
inline void GetTablesReq::set_allocated_table_name_filter(::exec::user::LikeFilter* table_name_filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete table_name_filter_;
  }
  if (table_name_filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      table_name_filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, table_name_filter, submessage_arena);
    }
    set_has_table_name_filter();
  } else {
    clear_has_table_name_filter();
  }
  table_name_filter_ = table_name_filter;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetTablesReq.table_name_filter)
}

// repeated string table_type_filter = 4;
inline int GetTablesReq::table_type_filter_size() const {
  return table_type_filter_.size();
}
inline void GetTablesReq::clear_table_type_filter() {
  table_type_filter_.Clear();
}
inline const ::std::string& GetTablesReq::table_type_filter(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.GetTablesReq.table_type_filter)
  return table_type_filter_.Get(index);
}
inline ::std::string* GetTablesReq::mutable_table_type_filter(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.GetTablesReq.table_type_filter)
  return table_type_filter_.Mutable(index);
}
inline void GetTablesReq::set_table_type_filter(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:exec.user.GetTablesReq.table_type_filter)
  table_type_filter_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GetTablesReq::set_table_type_filter(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:exec.user.GetTablesReq.table_type_filter)
  table_type_filter_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GetTablesReq::set_table_type_filter(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  table_type_filter_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:exec.user.GetTablesReq.table_type_filter)
}
inline void GetTablesReq::set_table_type_filter(int index, const char* value, size_t size) {
  table_type_filter_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:exec.user.GetTablesReq.table_type_filter)
}
inline ::std::string* GetTablesReq::add_table_type_filter() {
  // @@protoc_insertion_point(field_add_mutable:exec.user.GetTablesReq.table_type_filter)
  return table_type_filter_.Add();
}
inline void GetTablesReq::add_table_type_filter(const ::std::string& value) {
  table_type_filter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:exec.user.GetTablesReq.table_type_filter)
}
#if LANG_CXX11
inline void GetTablesReq::add_table_type_filter(::std::string&& value) {
  table_type_filter_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:exec.user.GetTablesReq.table_type_filter)
}
#endif
inline void GetTablesReq::add_table_type_filter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  table_type_filter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:exec.user.GetTablesReq.table_type_filter)
}
inline void GetTablesReq::add_table_type_filter(const char* value, size_t size) {
  table_type_filter_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:exec.user.GetTablesReq.table_type_filter)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetTablesReq::table_type_filter() const {
  // @@protoc_insertion_point(field_list:exec.user.GetTablesReq.table_type_filter)
  return table_type_filter_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetTablesReq::mutable_table_type_filter() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.GetTablesReq.table_type_filter)
  return &table_type_filter_;
}

// -------------------------------------------------------------------

// TableMetadata

// optional string catalog_name = 1;
inline bool TableMetadata::has_catalog_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableMetadata::set_has_catalog_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableMetadata::clear_has_catalog_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableMetadata::clear_catalog_name() {
  catalog_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_catalog_name();
}
inline const ::std::string& TableMetadata::catalog_name() const {
  // @@protoc_insertion_point(field_get:exec.user.TableMetadata.catalog_name)
  return catalog_name_.GetNoArena();
}
inline void TableMetadata::set_catalog_name(const ::std::string& value) {
  set_has_catalog_name();
  catalog_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.TableMetadata.catalog_name)
}
#if LANG_CXX11
inline void TableMetadata::set_catalog_name(::std::string&& value) {
  set_has_catalog_name();
  catalog_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.TableMetadata.catalog_name)
}
#endif
inline void TableMetadata::set_catalog_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_catalog_name();
  catalog_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.TableMetadata.catalog_name)
}
inline void TableMetadata::set_catalog_name(const char* value, size_t size) {
  set_has_catalog_name();
  catalog_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.TableMetadata.catalog_name)
}
inline ::std::string* TableMetadata::mutable_catalog_name() {
  set_has_catalog_name();
  // @@protoc_insertion_point(field_mutable:exec.user.TableMetadata.catalog_name)
  return catalog_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TableMetadata::release_catalog_name() {
  // @@protoc_insertion_point(field_release:exec.user.TableMetadata.catalog_name)
  if (!has_catalog_name()) {
    return NULL;
  }
  clear_has_catalog_name();
  return catalog_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TableMetadata::set_allocated_catalog_name(::std::string* catalog_name) {
  if (catalog_name != NULL) {
    set_has_catalog_name();
  } else {
    clear_has_catalog_name();
  }
  catalog_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), catalog_name);
  // @@protoc_insertion_point(field_set_allocated:exec.user.TableMetadata.catalog_name)
}

// optional string schema_name = 2;
inline bool TableMetadata::has_schema_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableMetadata::set_has_schema_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableMetadata::clear_has_schema_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableMetadata::clear_schema_name() {
  schema_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_schema_name();
}
inline const ::std::string& TableMetadata::schema_name() const {
  // @@protoc_insertion_point(field_get:exec.user.TableMetadata.schema_name)
  return schema_name_.GetNoArena();
}
inline void TableMetadata::set_schema_name(const ::std::string& value) {
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.TableMetadata.schema_name)
}
#if LANG_CXX11
inline void TableMetadata::set_schema_name(::std::string&& value) {
  set_has_schema_name();
  schema_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.TableMetadata.schema_name)
}
#endif
inline void TableMetadata::set_schema_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.TableMetadata.schema_name)
}
inline void TableMetadata::set_schema_name(const char* value, size_t size) {
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.TableMetadata.schema_name)
}
inline ::std::string* TableMetadata::mutable_schema_name() {
  set_has_schema_name();
  // @@protoc_insertion_point(field_mutable:exec.user.TableMetadata.schema_name)
  return schema_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TableMetadata::release_schema_name() {
  // @@protoc_insertion_point(field_release:exec.user.TableMetadata.schema_name)
  if (!has_schema_name()) {
    return NULL;
  }
  clear_has_schema_name();
  return schema_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TableMetadata::set_allocated_schema_name(::std::string* schema_name) {
  if (schema_name != NULL) {
    set_has_schema_name();
  } else {
    clear_has_schema_name();
  }
  schema_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schema_name);
  // @@protoc_insertion_point(field_set_allocated:exec.user.TableMetadata.schema_name)
}

// optional string table_name = 3;
inline bool TableMetadata::has_table_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TableMetadata::set_has_table_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TableMetadata::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TableMetadata::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_table_name();
}
inline const ::std::string& TableMetadata::table_name() const {
  // @@protoc_insertion_point(field_get:exec.user.TableMetadata.table_name)
  return table_name_.GetNoArena();
}
inline void TableMetadata::set_table_name(const ::std::string& value) {
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.TableMetadata.table_name)
}
#if LANG_CXX11
inline void TableMetadata::set_table_name(::std::string&& value) {
  set_has_table_name();
  table_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.TableMetadata.table_name)
}
#endif
inline void TableMetadata::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.TableMetadata.table_name)
}
inline void TableMetadata::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.TableMetadata.table_name)
}
inline ::std::string* TableMetadata::mutable_table_name() {
  set_has_table_name();
  // @@protoc_insertion_point(field_mutable:exec.user.TableMetadata.table_name)
  return table_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TableMetadata::release_table_name() {
  // @@protoc_insertion_point(field_release:exec.user.TableMetadata.table_name)
  if (!has_table_name()) {
    return NULL;
  }
  clear_has_table_name();
  return table_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TableMetadata::set_allocated_table_name(::std::string* table_name) {
  if (table_name != NULL) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
  table_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:exec.user.TableMetadata.table_name)
}

// optional string type = 4;
inline bool TableMetadata::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TableMetadata::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TableMetadata::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TableMetadata::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& TableMetadata::type() const {
  // @@protoc_insertion_point(field_get:exec.user.TableMetadata.type)
  return type_.GetNoArena();
}
inline void TableMetadata::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.TableMetadata.type)
}
#if LANG_CXX11
inline void TableMetadata::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.TableMetadata.type)
}
#endif
inline void TableMetadata::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.TableMetadata.type)
}
inline void TableMetadata::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.TableMetadata.type)
}
inline ::std::string* TableMetadata::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:exec.user.TableMetadata.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TableMetadata::release_type() {
  // @@protoc_insertion_point(field_release:exec.user.TableMetadata.type)
  if (!has_type()) {
    return NULL;
  }
  clear_has_type();
  return type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TableMetadata::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:exec.user.TableMetadata.type)
}

// -------------------------------------------------------------------

// GetTablesResp

// optional .exec.user.RequestStatus status = 1;
inline bool GetTablesResp::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTablesResp::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTablesResp::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTablesResp::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::exec::user::RequestStatus GetTablesResp::status() const {
  // @@protoc_insertion_point(field_get:exec.user.GetTablesResp.status)
  return static_cast< ::exec::user::RequestStatus >(status_);
}
inline void GetTablesResp::set_status(::exec::user::RequestStatus value) {
  assert(::exec::user::RequestStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:exec.user.GetTablesResp.status)
}

// repeated .exec.user.TableMetadata tables = 2;
inline int GetTablesResp::tables_size() const {
  return tables_.size();
}
inline void GetTablesResp::clear_tables() {
  tables_.Clear();
}
inline ::exec::user::TableMetadata* GetTablesResp::mutable_tables(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.GetTablesResp.tables)
  return tables_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::exec::user::TableMetadata >*
GetTablesResp::mutable_tables() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.GetTablesResp.tables)
  return &tables_;
}
inline const ::exec::user::TableMetadata& GetTablesResp::tables(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.GetTablesResp.tables)
  return tables_.Get(index);
}
inline ::exec::user::TableMetadata* GetTablesResp::add_tables() {
  // @@protoc_insertion_point(field_add:exec.user.GetTablesResp.tables)
  return tables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::user::TableMetadata >&
GetTablesResp::tables() const {
  // @@protoc_insertion_point(field_list:exec.user.GetTablesResp.tables)
  return tables_;
}

// optional .exec.shared.DrillPBError error = 3;
inline bool GetTablesResp::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTablesResp::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTablesResp::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::exec::shared::DrillPBError& GetTablesResp::_internal_error() const {
  return *error_;
}
inline const ::exec::shared::DrillPBError& GetTablesResp::error() const {
  const ::exec::shared::DrillPBError* p = error_;
  // @@protoc_insertion_point(field_get:exec.user.GetTablesResp.error)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::shared::DrillPBError*>(
      &::exec::shared::_DrillPBError_default_instance_);
}
inline ::exec::shared::DrillPBError* GetTablesResp::release_error() {
  // @@protoc_insertion_point(field_release:exec.user.GetTablesResp.error)
  clear_has_error();
  ::exec::shared::DrillPBError* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::exec::shared::DrillPBError* GetTablesResp::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::shared::DrillPBError>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.GetTablesResp.error)
  return error_;
}
inline void GetTablesResp::set_allocated_error(::exec::shared::DrillPBError* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    set_has_error();
  } else {
    clear_has_error();
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetTablesResp.error)
}

// -------------------------------------------------------------------

// GetColumnsReq

// optional .exec.user.LikeFilter catalog_name_filter = 1;
inline bool GetColumnsReq::has_catalog_name_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetColumnsReq::set_has_catalog_name_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetColumnsReq::clear_has_catalog_name_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetColumnsReq::clear_catalog_name_filter() {
  if (catalog_name_filter_ != NULL) catalog_name_filter_->Clear();
  clear_has_catalog_name_filter();
}
inline const ::exec::user::LikeFilter& GetColumnsReq::_internal_catalog_name_filter() const {
  return *catalog_name_filter_;
}
inline const ::exec::user::LikeFilter& GetColumnsReq::catalog_name_filter() const {
  const ::exec::user::LikeFilter* p = catalog_name_filter_;
  // @@protoc_insertion_point(field_get:exec.user.GetColumnsReq.catalog_name_filter)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::user::LikeFilter*>(
      &::exec::user::_LikeFilter_default_instance_);
}
inline ::exec::user::LikeFilter* GetColumnsReq::release_catalog_name_filter() {
  // @@protoc_insertion_point(field_release:exec.user.GetColumnsReq.catalog_name_filter)
  clear_has_catalog_name_filter();
  ::exec::user::LikeFilter* temp = catalog_name_filter_;
  catalog_name_filter_ = NULL;
  return temp;
}
inline ::exec::user::LikeFilter* GetColumnsReq::mutable_catalog_name_filter() {
  set_has_catalog_name_filter();
  if (catalog_name_filter_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::user::LikeFilter>(GetArenaNoVirtual());
    catalog_name_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.GetColumnsReq.catalog_name_filter)
  return catalog_name_filter_;
}
inline void GetColumnsReq::set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete catalog_name_filter_;
  }
  if (catalog_name_filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      catalog_name_filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, catalog_name_filter, submessage_arena);
    }
    set_has_catalog_name_filter();
  } else {
    clear_has_catalog_name_filter();
  }
  catalog_name_filter_ = catalog_name_filter;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetColumnsReq.catalog_name_filter)
}

// optional .exec.user.LikeFilter schema_name_filter = 2;
inline bool GetColumnsReq::has_schema_name_filter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetColumnsReq::set_has_schema_name_filter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetColumnsReq::clear_has_schema_name_filter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetColumnsReq::clear_schema_name_filter() {
  if (schema_name_filter_ != NULL) schema_name_filter_->Clear();
  clear_has_schema_name_filter();
}
inline const ::exec::user::LikeFilter& GetColumnsReq::_internal_schema_name_filter() const {
  return *schema_name_filter_;
}
inline const ::exec::user::LikeFilter& GetColumnsReq::schema_name_filter() const {
  const ::exec::user::LikeFilter* p = schema_name_filter_;
  // @@protoc_insertion_point(field_get:exec.user.GetColumnsReq.schema_name_filter)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::user::LikeFilter*>(
      &::exec::user::_LikeFilter_default_instance_);
}
inline ::exec::user::LikeFilter* GetColumnsReq::release_schema_name_filter() {
  // @@protoc_insertion_point(field_release:exec.user.GetColumnsReq.schema_name_filter)
  clear_has_schema_name_filter();
  ::exec::user::LikeFilter* temp = schema_name_filter_;
  schema_name_filter_ = NULL;
  return temp;
}
inline ::exec::user::LikeFilter* GetColumnsReq::mutable_schema_name_filter() {
  set_has_schema_name_filter();
  if (schema_name_filter_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::user::LikeFilter>(GetArenaNoVirtual());
    schema_name_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.GetColumnsReq.schema_name_filter)
  return schema_name_filter_;
}
inline void GetColumnsReq::set_allocated_schema_name_filter(::exec::user::LikeFilter* schema_name_filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete schema_name_filter_;
  }
  if (schema_name_filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      schema_name_filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, schema_name_filter, submessage_arena);
    }
    set_has_schema_name_filter();
  } else {
    clear_has_schema_name_filter();
  }
  schema_name_filter_ = schema_name_filter;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetColumnsReq.schema_name_filter)
}

// optional .exec.user.LikeFilter table_name_filter = 3;
inline bool GetColumnsReq::has_table_name_filter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetColumnsReq::set_has_table_name_filter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetColumnsReq::clear_has_table_name_filter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetColumnsReq::clear_table_name_filter() {
  if (table_name_filter_ != NULL) table_name_filter_->Clear();
  clear_has_table_name_filter();
}
inline const ::exec::user::LikeFilter& GetColumnsReq::_internal_table_name_filter() const {
  return *table_name_filter_;
}
inline const ::exec::user::LikeFilter& GetColumnsReq::table_name_filter() const {
  const ::exec::user::LikeFilter* p = table_name_filter_;
  // @@protoc_insertion_point(field_get:exec.user.GetColumnsReq.table_name_filter)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::user::LikeFilter*>(
      &::exec::user::_LikeFilter_default_instance_);
}
inline ::exec::user::LikeFilter* GetColumnsReq::release_table_name_filter() {
  // @@protoc_insertion_point(field_release:exec.user.GetColumnsReq.table_name_filter)
  clear_has_table_name_filter();
  ::exec::user::LikeFilter* temp = table_name_filter_;
  table_name_filter_ = NULL;
  return temp;
}
inline ::exec::user::LikeFilter* GetColumnsReq::mutable_table_name_filter() {
  set_has_table_name_filter();
  if (table_name_filter_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::user::LikeFilter>(GetArenaNoVirtual());
    table_name_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.GetColumnsReq.table_name_filter)
  return table_name_filter_;
}
inline void GetColumnsReq::set_allocated_table_name_filter(::exec::user::LikeFilter* table_name_filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete table_name_filter_;
  }
  if (table_name_filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      table_name_filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, table_name_filter, submessage_arena);
    }
    set_has_table_name_filter();
  } else {
    clear_has_table_name_filter();
  }
  table_name_filter_ = table_name_filter;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetColumnsReq.table_name_filter)
}

// optional .exec.user.LikeFilter column_name_filter = 4;
inline bool GetColumnsReq::has_column_name_filter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetColumnsReq::set_has_column_name_filter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetColumnsReq::clear_has_column_name_filter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetColumnsReq::clear_column_name_filter() {
  if (column_name_filter_ != NULL) column_name_filter_->Clear();
  clear_has_column_name_filter();
}
inline const ::exec::user::LikeFilter& GetColumnsReq::_internal_column_name_filter() const {
  return *column_name_filter_;
}
inline const ::exec::user::LikeFilter& GetColumnsReq::column_name_filter() const {
  const ::exec::user::LikeFilter* p = column_name_filter_;
  // @@protoc_insertion_point(field_get:exec.user.GetColumnsReq.column_name_filter)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::user::LikeFilter*>(
      &::exec::user::_LikeFilter_default_instance_);
}
inline ::exec::user::LikeFilter* GetColumnsReq::release_column_name_filter() {
  // @@protoc_insertion_point(field_release:exec.user.GetColumnsReq.column_name_filter)
  clear_has_column_name_filter();
  ::exec::user::LikeFilter* temp = column_name_filter_;
  column_name_filter_ = NULL;
  return temp;
}
inline ::exec::user::LikeFilter* GetColumnsReq::mutable_column_name_filter() {
  set_has_column_name_filter();
  if (column_name_filter_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::user::LikeFilter>(GetArenaNoVirtual());
    column_name_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.GetColumnsReq.column_name_filter)
  return column_name_filter_;
}
inline void GetColumnsReq::set_allocated_column_name_filter(::exec::user::LikeFilter* column_name_filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete column_name_filter_;
  }
  if (column_name_filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      column_name_filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, column_name_filter, submessage_arena);
    }
    set_has_column_name_filter();
  } else {
    clear_has_column_name_filter();
  }
  column_name_filter_ = column_name_filter;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetColumnsReq.column_name_filter)
}

// -------------------------------------------------------------------

// ColumnMetadata

// optional string catalog_name = 1;
inline bool ColumnMetadata::has_catalog_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnMetadata::set_has_catalog_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnMetadata::clear_has_catalog_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnMetadata::clear_catalog_name() {
  catalog_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_catalog_name();
}
inline const ::std::string& ColumnMetadata::catalog_name() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.catalog_name)
  return catalog_name_.GetNoArena();
}
inline void ColumnMetadata::set_catalog_name(const ::std::string& value) {
  set_has_catalog_name();
  catalog_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.catalog_name)
}
#if LANG_CXX11
inline void ColumnMetadata::set_catalog_name(::std::string&& value) {
  set_has_catalog_name();
  catalog_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ColumnMetadata.catalog_name)
}
#endif
inline void ColumnMetadata::set_catalog_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_catalog_name();
  catalog_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ColumnMetadata.catalog_name)
}
inline void ColumnMetadata::set_catalog_name(const char* value, size_t size) {
  set_has_catalog_name();
  catalog_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ColumnMetadata.catalog_name)
}
inline ::std::string* ColumnMetadata::mutable_catalog_name() {
  set_has_catalog_name();
  // @@protoc_insertion_point(field_mutable:exec.user.ColumnMetadata.catalog_name)
  return catalog_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ColumnMetadata::release_catalog_name() {
  // @@protoc_insertion_point(field_release:exec.user.ColumnMetadata.catalog_name)
  if (!has_catalog_name()) {
    return NULL;
  }
  clear_has_catalog_name();
  return catalog_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnMetadata::set_allocated_catalog_name(::std::string* catalog_name) {
  if (catalog_name != NULL) {
    set_has_catalog_name();
  } else {
    clear_has_catalog_name();
  }
  catalog_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), catalog_name);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ColumnMetadata.catalog_name)
}

// optional string schema_name = 2;
inline bool ColumnMetadata::has_schema_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnMetadata::set_has_schema_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColumnMetadata::clear_has_schema_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColumnMetadata::clear_schema_name() {
  schema_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_schema_name();
}
inline const ::std::string& ColumnMetadata::schema_name() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.schema_name)
  return schema_name_.GetNoArena();
}
inline void ColumnMetadata::set_schema_name(const ::std::string& value) {
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.schema_name)
}
#if LANG_CXX11
inline void ColumnMetadata::set_schema_name(::std::string&& value) {
  set_has_schema_name();
  schema_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ColumnMetadata.schema_name)
}
#endif
inline void ColumnMetadata::set_schema_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ColumnMetadata.schema_name)
}
inline void ColumnMetadata::set_schema_name(const char* value, size_t size) {
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ColumnMetadata.schema_name)
}
inline ::std::string* ColumnMetadata::mutable_schema_name() {
  set_has_schema_name();
  // @@protoc_insertion_point(field_mutable:exec.user.ColumnMetadata.schema_name)
  return schema_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ColumnMetadata::release_schema_name() {
  // @@protoc_insertion_point(field_release:exec.user.ColumnMetadata.schema_name)
  if (!has_schema_name()) {
    return NULL;
  }
  clear_has_schema_name();
  return schema_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnMetadata::set_allocated_schema_name(::std::string* schema_name) {
  if (schema_name != NULL) {
    set_has_schema_name();
  } else {
    clear_has_schema_name();
  }
  schema_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schema_name);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ColumnMetadata.schema_name)
}

// optional string table_name = 3;
inline bool ColumnMetadata::has_table_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ColumnMetadata::set_has_table_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ColumnMetadata::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ColumnMetadata::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_table_name();
}
inline const ::std::string& ColumnMetadata::table_name() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.table_name)
  return table_name_.GetNoArena();
}
inline void ColumnMetadata::set_table_name(const ::std::string& value) {
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.table_name)
}
#if LANG_CXX11
inline void ColumnMetadata::set_table_name(::std::string&& value) {
  set_has_table_name();
  table_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ColumnMetadata.table_name)
}
#endif
inline void ColumnMetadata::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ColumnMetadata.table_name)
}
inline void ColumnMetadata::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ColumnMetadata.table_name)
}
inline ::std::string* ColumnMetadata::mutable_table_name() {
  set_has_table_name();
  // @@protoc_insertion_point(field_mutable:exec.user.ColumnMetadata.table_name)
  return table_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ColumnMetadata::release_table_name() {
  // @@protoc_insertion_point(field_release:exec.user.ColumnMetadata.table_name)
  if (!has_table_name()) {
    return NULL;
  }
  clear_has_table_name();
  return table_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnMetadata::set_allocated_table_name(::std::string* table_name) {
  if (table_name != NULL) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
  table_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ColumnMetadata.table_name)
}

// optional string column_name = 4;
inline bool ColumnMetadata::has_column_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ColumnMetadata::set_has_column_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ColumnMetadata::clear_has_column_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ColumnMetadata::clear_column_name() {
  column_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_column_name();
}
inline const ::std::string& ColumnMetadata::column_name() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.column_name)
  return column_name_.GetNoArena();
}
inline void ColumnMetadata::set_column_name(const ::std::string& value) {
  set_has_column_name();
  column_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.column_name)
}
#if LANG_CXX11
inline void ColumnMetadata::set_column_name(::std::string&& value) {
  set_has_column_name();
  column_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ColumnMetadata.column_name)
}
#endif
inline void ColumnMetadata::set_column_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_column_name();
  column_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ColumnMetadata.column_name)
}
inline void ColumnMetadata::set_column_name(const char* value, size_t size) {
  set_has_column_name();
  column_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ColumnMetadata.column_name)
}
inline ::std::string* ColumnMetadata::mutable_column_name() {
  set_has_column_name();
  // @@protoc_insertion_point(field_mutable:exec.user.ColumnMetadata.column_name)
  return column_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ColumnMetadata::release_column_name() {
  // @@protoc_insertion_point(field_release:exec.user.ColumnMetadata.column_name)
  if (!has_column_name()) {
    return NULL;
  }
  clear_has_column_name();
  return column_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnMetadata::set_allocated_column_name(::std::string* column_name) {
  if (column_name != NULL) {
    set_has_column_name();
  } else {
    clear_has_column_name();
  }
  column_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), column_name);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ColumnMetadata.column_name)
}

// optional int32 ordinal_position = 5;
inline bool ColumnMetadata::has_ordinal_position() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ColumnMetadata::set_has_ordinal_position() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ColumnMetadata::clear_has_ordinal_position() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ColumnMetadata::clear_ordinal_position() {
  ordinal_position_ = 0;
  clear_has_ordinal_position();
}
inline ::google::protobuf::int32 ColumnMetadata::ordinal_position() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.ordinal_position)
  return ordinal_position_;
}
inline void ColumnMetadata::set_ordinal_position(::google::protobuf::int32 value) {
  set_has_ordinal_position();
  ordinal_position_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.ordinal_position)
}

// optional string default_value = 6;
inline bool ColumnMetadata::has_default_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ColumnMetadata::set_has_default_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ColumnMetadata::clear_has_default_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ColumnMetadata::clear_default_value() {
  default_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_default_value();
}
inline const ::std::string& ColumnMetadata::default_value() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.default_value)
  return default_value_.GetNoArena();
}
inline void ColumnMetadata::set_default_value(const ::std::string& value) {
  set_has_default_value();
  default_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.default_value)
}
#if LANG_CXX11
inline void ColumnMetadata::set_default_value(::std::string&& value) {
  set_has_default_value();
  default_value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ColumnMetadata.default_value)
}
#endif
inline void ColumnMetadata::set_default_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_default_value();
  default_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ColumnMetadata.default_value)
}
inline void ColumnMetadata::set_default_value(const char* value, size_t size) {
  set_has_default_value();
  default_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ColumnMetadata.default_value)
}
inline ::std::string* ColumnMetadata::mutable_default_value() {
  set_has_default_value();
  // @@protoc_insertion_point(field_mutable:exec.user.ColumnMetadata.default_value)
  return default_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ColumnMetadata::release_default_value() {
  // @@protoc_insertion_point(field_release:exec.user.ColumnMetadata.default_value)
  if (!has_default_value()) {
    return NULL;
  }
  clear_has_default_value();
  return default_value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnMetadata::set_allocated_default_value(::std::string* default_value) {
  if (default_value != NULL) {
    set_has_default_value();
  } else {
    clear_has_default_value();
  }
  default_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), default_value);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ColumnMetadata.default_value)
}

// optional bool is_nullable = 7;
inline bool ColumnMetadata::has_is_nullable() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ColumnMetadata::set_has_is_nullable() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ColumnMetadata::clear_has_is_nullable() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ColumnMetadata::clear_is_nullable() {
  is_nullable_ = false;
  clear_has_is_nullable();
}
inline bool ColumnMetadata::is_nullable() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.is_nullable)
  return is_nullable_;
}
inline void ColumnMetadata::set_is_nullable(bool value) {
  set_has_is_nullable();
  is_nullable_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.is_nullable)
}

// optional string data_type = 8;
inline bool ColumnMetadata::has_data_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ColumnMetadata::set_has_data_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ColumnMetadata::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ColumnMetadata::clear_data_type() {
  data_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_type();
}
inline const ::std::string& ColumnMetadata::data_type() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.data_type)
  return data_type_.GetNoArena();
}
inline void ColumnMetadata::set_data_type(const ::std::string& value) {
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.data_type)
}
#if LANG_CXX11
inline void ColumnMetadata::set_data_type(::std::string&& value) {
  set_has_data_type();
  data_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ColumnMetadata.data_type)
}
#endif
inline void ColumnMetadata::set_data_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ColumnMetadata.data_type)
}
inline void ColumnMetadata::set_data_type(const char* value, size_t size) {
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ColumnMetadata.data_type)
}
inline ::std::string* ColumnMetadata::mutable_data_type() {
  set_has_data_type();
  // @@protoc_insertion_point(field_mutable:exec.user.ColumnMetadata.data_type)
  return data_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ColumnMetadata::release_data_type() {
  // @@protoc_insertion_point(field_release:exec.user.ColumnMetadata.data_type)
  if (!has_data_type()) {
    return NULL;
  }
  clear_has_data_type();
  return data_type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnMetadata::set_allocated_data_type(::std::string* data_type) {
  if (data_type != NULL) {
    set_has_data_type();
  } else {
    clear_has_data_type();
  }
  data_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_type);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ColumnMetadata.data_type)
}

// optional int32 char_max_length = 9;
inline bool ColumnMetadata::has_char_max_length() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ColumnMetadata::set_has_char_max_length() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ColumnMetadata::clear_has_char_max_length() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ColumnMetadata::clear_char_max_length() {
  char_max_length_ = 0;
  clear_has_char_max_length();
}
inline ::google::protobuf::int32 ColumnMetadata::char_max_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.char_max_length)
  return char_max_length_;
}
inline void ColumnMetadata::set_char_max_length(::google::protobuf::int32 value) {
  set_has_char_max_length();
  char_max_length_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.char_max_length)
}

// optional int32 char_octet_length = 10;
inline bool ColumnMetadata::has_char_octet_length() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ColumnMetadata::set_has_char_octet_length() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ColumnMetadata::clear_has_char_octet_length() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ColumnMetadata::clear_char_octet_length() {
  char_octet_length_ = 0;
  clear_has_char_octet_length();
}
inline ::google::protobuf::int32 ColumnMetadata::char_octet_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.char_octet_length)
  return char_octet_length_;
}
inline void ColumnMetadata::set_char_octet_length(::google::protobuf::int32 value) {
  set_has_char_octet_length();
  char_octet_length_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.char_octet_length)
}

// optional int32 numeric_precision = 11;
inline bool ColumnMetadata::has_numeric_precision() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ColumnMetadata::set_has_numeric_precision() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ColumnMetadata::clear_has_numeric_precision() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ColumnMetadata::clear_numeric_precision() {
  numeric_precision_ = 0;
  clear_has_numeric_precision();
}
inline ::google::protobuf::int32 ColumnMetadata::numeric_precision() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.numeric_precision)
  return numeric_precision_;
}
inline void ColumnMetadata::set_numeric_precision(::google::protobuf::int32 value) {
  set_has_numeric_precision();
  numeric_precision_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.numeric_precision)
}

// optional int32 numeric_precision_radix = 12;
inline bool ColumnMetadata::has_numeric_precision_radix() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ColumnMetadata::set_has_numeric_precision_radix() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ColumnMetadata::clear_has_numeric_precision_radix() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ColumnMetadata::clear_numeric_precision_radix() {
  numeric_precision_radix_ = 0;
  clear_has_numeric_precision_radix();
}
inline ::google::protobuf::int32 ColumnMetadata::numeric_precision_radix() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.numeric_precision_radix)
  return numeric_precision_radix_;
}
inline void ColumnMetadata::set_numeric_precision_radix(::google::protobuf::int32 value) {
  set_has_numeric_precision_radix();
  numeric_precision_radix_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.numeric_precision_radix)
}

// optional int32 numeric_scale = 13;
inline bool ColumnMetadata::has_numeric_scale() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ColumnMetadata::set_has_numeric_scale() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ColumnMetadata::clear_has_numeric_scale() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ColumnMetadata::clear_numeric_scale() {
  numeric_scale_ = 0;
  clear_has_numeric_scale();
}
inline ::google::protobuf::int32 ColumnMetadata::numeric_scale() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.numeric_scale)
  return numeric_scale_;
}
inline void ColumnMetadata::set_numeric_scale(::google::protobuf::int32 value) {
  set_has_numeric_scale();
  numeric_scale_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.numeric_scale)
}

// optional int32 date_time_precision = 14;
inline bool ColumnMetadata::has_date_time_precision() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ColumnMetadata::set_has_date_time_precision() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ColumnMetadata::clear_has_date_time_precision() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ColumnMetadata::clear_date_time_precision() {
  date_time_precision_ = 0;
  clear_has_date_time_precision();
}
inline ::google::protobuf::int32 ColumnMetadata::date_time_precision() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.date_time_precision)
  return date_time_precision_;
}
inline void ColumnMetadata::set_date_time_precision(::google::protobuf::int32 value) {
  set_has_date_time_precision();
  date_time_precision_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.date_time_precision)
}

// optional string interval_type = 15;
inline bool ColumnMetadata::has_interval_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ColumnMetadata::set_has_interval_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ColumnMetadata::clear_has_interval_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ColumnMetadata::clear_interval_type() {
  interval_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_interval_type();
}
inline const ::std::string& ColumnMetadata::interval_type() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.interval_type)
  return interval_type_.GetNoArena();
}
inline void ColumnMetadata::set_interval_type(const ::std::string& value) {
  set_has_interval_type();
  interval_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.interval_type)
}
#if LANG_CXX11
inline void ColumnMetadata::set_interval_type(::std::string&& value) {
  set_has_interval_type();
  interval_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ColumnMetadata.interval_type)
}
#endif
inline void ColumnMetadata::set_interval_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_interval_type();
  interval_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ColumnMetadata.interval_type)
}
inline void ColumnMetadata::set_interval_type(const char* value, size_t size) {
  set_has_interval_type();
  interval_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ColumnMetadata.interval_type)
}
inline ::std::string* ColumnMetadata::mutable_interval_type() {
  set_has_interval_type();
  // @@protoc_insertion_point(field_mutable:exec.user.ColumnMetadata.interval_type)
  return interval_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ColumnMetadata::release_interval_type() {
  // @@protoc_insertion_point(field_release:exec.user.ColumnMetadata.interval_type)
  if (!has_interval_type()) {
    return NULL;
  }
  clear_has_interval_type();
  return interval_type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnMetadata::set_allocated_interval_type(::std::string* interval_type) {
  if (interval_type != NULL) {
    set_has_interval_type();
  } else {
    clear_has_interval_type();
  }
  interval_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), interval_type);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ColumnMetadata.interval_type)
}

// optional int32 interval_precision = 16;
inline bool ColumnMetadata::has_interval_precision() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ColumnMetadata::set_has_interval_precision() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ColumnMetadata::clear_has_interval_precision() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ColumnMetadata::clear_interval_precision() {
  interval_precision_ = 0;
  clear_has_interval_precision();
}
inline ::google::protobuf::int32 ColumnMetadata::interval_precision() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.interval_precision)
  return interval_precision_;
}
inline void ColumnMetadata::set_interval_precision(::google::protobuf::int32 value) {
  set_has_interval_precision();
  interval_precision_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.interval_precision)
}

// optional int32 column_size = 17;
inline bool ColumnMetadata::has_column_size() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ColumnMetadata::set_has_column_size() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ColumnMetadata::clear_has_column_size() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ColumnMetadata::clear_column_size() {
  column_size_ = 0;
  clear_has_column_size();
}
inline ::google::protobuf::int32 ColumnMetadata::column_size() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.column_size)
  return column_size_;
}
inline void ColumnMetadata::set_column_size(::google::protobuf::int32 value) {
  set_has_column_size();
  column_size_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.column_size)
}

// -------------------------------------------------------------------

// GetColumnsResp

// optional .exec.user.RequestStatus status = 1;
inline bool GetColumnsResp::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetColumnsResp::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetColumnsResp::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetColumnsResp::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::exec::user::RequestStatus GetColumnsResp::status() const {
  // @@protoc_insertion_point(field_get:exec.user.GetColumnsResp.status)
  return static_cast< ::exec::user::RequestStatus >(status_);
}
inline void GetColumnsResp::set_status(::exec::user::RequestStatus value) {
  assert(::exec::user::RequestStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:exec.user.GetColumnsResp.status)
}

// repeated .exec.user.ColumnMetadata columns = 2;
inline int GetColumnsResp::columns_size() const {
  return columns_.size();
}
inline void GetColumnsResp::clear_columns() {
  columns_.Clear();
}
inline ::exec::user::ColumnMetadata* GetColumnsResp::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.GetColumnsResp.columns)
  return columns_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::exec::user::ColumnMetadata >*
GetColumnsResp::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.GetColumnsResp.columns)
  return &columns_;
}
inline const ::exec::user::ColumnMetadata& GetColumnsResp::columns(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.GetColumnsResp.columns)
  return columns_.Get(index);
}
inline ::exec::user::ColumnMetadata* GetColumnsResp::add_columns() {
  // @@protoc_insertion_point(field_add:exec.user.GetColumnsResp.columns)
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::user::ColumnMetadata >&
GetColumnsResp::columns() const {
  // @@protoc_insertion_point(field_list:exec.user.GetColumnsResp.columns)
  return columns_;
}

// optional .exec.shared.DrillPBError error = 3;
inline bool GetColumnsResp::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetColumnsResp::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetColumnsResp::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::exec::shared::DrillPBError& GetColumnsResp::_internal_error() const {
  return *error_;
}
inline const ::exec::shared::DrillPBError& GetColumnsResp::error() const {
  const ::exec::shared::DrillPBError* p = error_;
  // @@protoc_insertion_point(field_get:exec.user.GetColumnsResp.error)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::shared::DrillPBError*>(
      &::exec::shared::_DrillPBError_default_instance_);
}
inline ::exec::shared::DrillPBError* GetColumnsResp::release_error() {
  // @@protoc_insertion_point(field_release:exec.user.GetColumnsResp.error)
  clear_has_error();
  ::exec::shared::DrillPBError* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::exec::shared::DrillPBError* GetColumnsResp::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::shared::DrillPBError>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.GetColumnsResp.error)
  return error_;
}
inline void GetColumnsResp::set_allocated_error(::exec::shared::DrillPBError* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    set_has_error();
  } else {
    clear_has_error();
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetColumnsResp.error)
}

// -------------------------------------------------------------------

// CreatePreparedStatementReq

// optional string sql_query = 1;
inline bool CreatePreparedStatementReq::has_sql_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreatePreparedStatementReq::set_has_sql_query() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreatePreparedStatementReq::clear_has_sql_query() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreatePreparedStatementReq::clear_sql_query() {
  sql_query_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sql_query();
}
inline const ::std::string& CreatePreparedStatementReq::sql_query() const {
  // @@protoc_insertion_point(field_get:exec.user.CreatePreparedStatementReq.sql_query)
  return sql_query_.GetNoArena();
}
inline void CreatePreparedStatementReq::set_sql_query(const ::std::string& value) {
  set_has_sql_query();
  sql_query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.CreatePreparedStatementReq.sql_query)
}
#if LANG_CXX11
inline void CreatePreparedStatementReq::set_sql_query(::std::string&& value) {
  set_has_sql_query();
  sql_query_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.CreatePreparedStatementReq.sql_query)
}
#endif
inline void CreatePreparedStatementReq::set_sql_query(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sql_query();
  sql_query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.CreatePreparedStatementReq.sql_query)
}
inline void CreatePreparedStatementReq::set_sql_query(const char* value, size_t size) {
  set_has_sql_query();
  sql_query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.CreatePreparedStatementReq.sql_query)
}
inline ::std::string* CreatePreparedStatementReq::mutable_sql_query() {
  set_has_sql_query();
  // @@protoc_insertion_point(field_mutable:exec.user.CreatePreparedStatementReq.sql_query)
  return sql_query_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreatePreparedStatementReq::release_sql_query() {
  // @@protoc_insertion_point(field_release:exec.user.CreatePreparedStatementReq.sql_query)
  if (!has_sql_query()) {
    return NULL;
  }
  clear_has_sql_query();
  return sql_query_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreatePreparedStatementReq::set_allocated_sql_query(::std::string* sql_query) {
  if (sql_query != NULL) {
    set_has_sql_query();
  } else {
    clear_has_sql_query();
  }
  sql_query_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sql_query);
  // @@protoc_insertion_point(field_set_allocated:exec.user.CreatePreparedStatementReq.sql_query)
}

// -------------------------------------------------------------------

// ResultColumnMetadata

// optional string catalog_name = 1;
inline bool ResultColumnMetadata::has_catalog_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResultColumnMetadata::set_has_catalog_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResultColumnMetadata::clear_has_catalog_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResultColumnMetadata::clear_catalog_name() {
  catalog_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_catalog_name();
}
inline const ::std::string& ResultColumnMetadata::catalog_name() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.catalog_name)
  return catalog_name_.GetNoArena();
}
inline void ResultColumnMetadata::set_catalog_name(const ::std::string& value) {
  set_has_catalog_name();
  catalog_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.catalog_name)
}
#if LANG_CXX11
inline void ResultColumnMetadata::set_catalog_name(::std::string&& value) {
  set_has_catalog_name();
  catalog_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ResultColumnMetadata.catalog_name)
}
#endif
inline void ResultColumnMetadata::set_catalog_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_catalog_name();
  catalog_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ResultColumnMetadata.catalog_name)
}
inline void ResultColumnMetadata::set_catalog_name(const char* value, size_t size) {
  set_has_catalog_name();
  catalog_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ResultColumnMetadata.catalog_name)
}
inline ::std::string* ResultColumnMetadata::mutable_catalog_name() {
  set_has_catalog_name();
  // @@protoc_insertion_point(field_mutable:exec.user.ResultColumnMetadata.catalog_name)
  return catalog_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResultColumnMetadata::release_catalog_name() {
  // @@protoc_insertion_point(field_release:exec.user.ResultColumnMetadata.catalog_name)
  if (!has_catalog_name()) {
    return NULL;
  }
  clear_has_catalog_name();
  return catalog_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResultColumnMetadata::set_allocated_catalog_name(::std::string* catalog_name) {
  if (catalog_name != NULL) {
    set_has_catalog_name();
  } else {
    clear_has_catalog_name();
  }
  catalog_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), catalog_name);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ResultColumnMetadata.catalog_name)
}

// optional string schema_name = 2;
inline bool ResultColumnMetadata::has_schema_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResultColumnMetadata::set_has_schema_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResultColumnMetadata::clear_has_schema_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResultColumnMetadata::clear_schema_name() {
  schema_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_schema_name();
}
inline const ::std::string& ResultColumnMetadata::schema_name() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.schema_name)
  return schema_name_.GetNoArena();
}
inline void ResultColumnMetadata::set_schema_name(const ::std::string& value) {
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.schema_name)
}
#if LANG_CXX11
inline void ResultColumnMetadata::set_schema_name(::std::string&& value) {
  set_has_schema_name();
  schema_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ResultColumnMetadata.schema_name)
}
#endif
inline void ResultColumnMetadata::set_schema_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ResultColumnMetadata.schema_name)
}
inline void ResultColumnMetadata::set_schema_name(const char* value, size_t size) {
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ResultColumnMetadata.schema_name)
}
inline ::std::string* ResultColumnMetadata::mutable_schema_name() {
  set_has_schema_name();
  // @@protoc_insertion_point(field_mutable:exec.user.ResultColumnMetadata.schema_name)
  return schema_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResultColumnMetadata::release_schema_name() {
  // @@protoc_insertion_point(field_release:exec.user.ResultColumnMetadata.schema_name)
  if (!has_schema_name()) {
    return NULL;
  }
  clear_has_schema_name();
  return schema_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResultColumnMetadata::set_allocated_schema_name(::std::string* schema_name) {
  if (schema_name != NULL) {
    set_has_schema_name();
  } else {
    clear_has_schema_name();
  }
  schema_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schema_name);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ResultColumnMetadata.schema_name)
}

// optional string table_name = 3;
inline bool ResultColumnMetadata::has_table_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResultColumnMetadata::set_has_table_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResultColumnMetadata::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResultColumnMetadata::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_table_name();
}
inline const ::std::string& ResultColumnMetadata::table_name() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.table_name)
  return table_name_.GetNoArena();
}
inline void ResultColumnMetadata::set_table_name(const ::std::string& value) {
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.table_name)
}
#if LANG_CXX11
inline void ResultColumnMetadata::set_table_name(::std::string&& value) {
  set_has_table_name();
  table_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ResultColumnMetadata.table_name)
}
#endif
inline void ResultColumnMetadata::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ResultColumnMetadata.table_name)
}
inline void ResultColumnMetadata::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ResultColumnMetadata.table_name)
}
inline ::std::string* ResultColumnMetadata::mutable_table_name() {
  set_has_table_name();
  // @@protoc_insertion_point(field_mutable:exec.user.ResultColumnMetadata.table_name)
  return table_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResultColumnMetadata::release_table_name() {
  // @@protoc_insertion_point(field_release:exec.user.ResultColumnMetadata.table_name)
  if (!has_table_name()) {
    return NULL;
  }
  clear_has_table_name();
  return table_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResultColumnMetadata::set_allocated_table_name(::std::string* table_name) {
  if (table_name != NULL) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
  table_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ResultColumnMetadata.table_name)
}

// optional string column_name = 4;
inline bool ResultColumnMetadata::has_column_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResultColumnMetadata::set_has_column_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResultColumnMetadata::clear_has_column_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResultColumnMetadata::clear_column_name() {
  column_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_column_name();
}
inline const ::std::string& ResultColumnMetadata::column_name() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.column_name)
  return column_name_.GetNoArena();
}
inline void ResultColumnMetadata::set_column_name(const ::std::string& value) {
  set_has_column_name();
  column_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.column_name)
}
#if LANG_CXX11
inline void ResultColumnMetadata::set_column_name(::std::string&& value) {
  set_has_column_name();
  column_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ResultColumnMetadata.column_name)
}
#endif
inline void ResultColumnMetadata::set_column_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_column_name();
  column_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ResultColumnMetadata.column_name)
}
inline void ResultColumnMetadata::set_column_name(const char* value, size_t size) {
  set_has_column_name();
  column_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ResultColumnMetadata.column_name)
}
inline ::std::string* ResultColumnMetadata::mutable_column_name() {
  set_has_column_name();
  // @@protoc_insertion_point(field_mutable:exec.user.ResultColumnMetadata.column_name)
  return column_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResultColumnMetadata::release_column_name() {
  // @@protoc_insertion_point(field_release:exec.user.ResultColumnMetadata.column_name)
  if (!has_column_name()) {
    return NULL;
  }
  clear_has_column_name();
  return column_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResultColumnMetadata::set_allocated_column_name(::std::string* column_name) {
  if (column_name != NULL) {
    set_has_column_name();
  } else {
    clear_has_column_name();
  }
  column_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), column_name);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ResultColumnMetadata.column_name)
}

// optional string label = 5;
inline bool ResultColumnMetadata::has_label() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResultColumnMetadata::set_has_label() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResultColumnMetadata::clear_has_label() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResultColumnMetadata::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
inline const ::std::string& ResultColumnMetadata::label() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.label)
  return label_.GetNoArena();
}
inline void ResultColumnMetadata::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.label)
}
#if LANG_CXX11
inline void ResultColumnMetadata::set_label(::std::string&& value) {
  set_has_label();
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ResultColumnMetadata.label)
}
#endif
inline void ResultColumnMetadata::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ResultColumnMetadata.label)
}
inline void ResultColumnMetadata::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ResultColumnMetadata.label)
}
inline ::std::string* ResultColumnMetadata::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:exec.user.ResultColumnMetadata.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResultColumnMetadata::release_label() {
  // @@protoc_insertion_point(field_release:exec.user.ResultColumnMetadata.label)
  if (!has_label()) {
    return NULL;
  }
  clear_has_label();
  return label_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResultColumnMetadata::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ResultColumnMetadata.label)
}

// optional string data_type = 6;
inline bool ResultColumnMetadata::has_data_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResultColumnMetadata::set_has_data_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResultColumnMetadata::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResultColumnMetadata::clear_data_type() {
  data_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_type();
}
inline const ::std::string& ResultColumnMetadata::data_type() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.data_type)
  return data_type_.GetNoArena();
}
inline void ResultColumnMetadata::set_data_type(const ::std::string& value) {
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.data_type)
}
#if LANG_CXX11
inline void ResultColumnMetadata::set_data_type(::std::string&& value) {
  set_has_data_type();
  data_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ResultColumnMetadata.data_type)
}
#endif
inline void ResultColumnMetadata::set_data_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ResultColumnMetadata.data_type)
}
inline void ResultColumnMetadata::set_data_type(const char* value, size_t size) {
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ResultColumnMetadata.data_type)
}
inline ::std::string* ResultColumnMetadata::mutable_data_type() {
  set_has_data_type();
  // @@protoc_insertion_point(field_mutable:exec.user.ResultColumnMetadata.data_type)
  return data_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResultColumnMetadata::release_data_type() {
  // @@protoc_insertion_point(field_release:exec.user.ResultColumnMetadata.data_type)
  if (!has_data_type()) {
    return NULL;
  }
  clear_has_data_type();
  return data_type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResultColumnMetadata::set_allocated_data_type(::std::string* data_type) {
  if (data_type != NULL) {
    set_has_data_type();
  } else {
    clear_has_data_type();
  }
  data_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_type);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ResultColumnMetadata.data_type)
}

// optional bool is_nullable = 7;
inline bool ResultColumnMetadata::has_is_nullable() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ResultColumnMetadata::set_has_is_nullable() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ResultColumnMetadata::clear_has_is_nullable() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ResultColumnMetadata::clear_is_nullable() {
  is_nullable_ = false;
  clear_has_is_nullable();
}
inline bool ResultColumnMetadata::is_nullable() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.is_nullable)
  return is_nullable_;
}
inline void ResultColumnMetadata::set_is_nullable(bool value) {
  set_has_is_nullable();
  is_nullable_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.is_nullable)
}

// optional int32 precision = 8;
inline bool ResultColumnMetadata::has_precision() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResultColumnMetadata::set_has_precision() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResultColumnMetadata::clear_has_precision() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResultColumnMetadata::clear_precision() {
  precision_ = 0;
  clear_has_precision();
}
inline ::google::protobuf::int32 ResultColumnMetadata::precision() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.precision)
  return precision_;
}
inline void ResultColumnMetadata::set_precision(::google::protobuf::int32 value) {
  set_has_precision();
  precision_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.precision)
}

// optional int32 scale = 9;
inline bool ResultColumnMetadata::has_scale() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResultColumnMetadata::set_has_scale() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResultColumnMetadata::clear_has_scale() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResultColumnMetadata::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline ::google::protobuf::int32 ResultColumnMetadata::scale() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.scale)
  return scale_;
}
inline void ResultColumnMetadata::set_scale(::google::protobuf::int32 value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.scale)
}

// optional bool signed = 10;
inline bool ResultColumnMetadata::has_signed_() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ResultColumnMetadata::set_has_signed_() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ResultColumnMetadata::clear_has_signed_() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ResultColumnMetadata::clear_signed_() {
  signed__ = false;
  clear_has_signed_();
}
inline bool ResultColumnMetadata::signed_() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.signed)
  return signed__;
}
inline void ResultColumnMetadata::set_signed_(bool value) {
  set_has_signed_();
  signed__ = value;
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.signed)
}

// optional int32 display_size = 11;
inline bool ResultColumnMetadata::has_display_size() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResultColumnMetadata::set_has_display_size() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResultColumnMetadata::clear_has_display_size() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResultColumnMetadata::clear_display_size() {
  display_size_ = 0;
  clear_has_display_size();
}
inline ::google::protobuf::int32 ResultColumnMetadata::display_size() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.display_size)
  return display_size_;
}
inline void ResultColumnMetadata::set_display_size(::google::protobuf::int32 value) {
  set_has_display_size();
  display_size_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.display_size)
}

// optional bool is_aliased = 12;
inline bool ResultColumnMetadata::has_is_aliased() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ResultColumnMetadata::set_has_is_aliased() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ResultColumnMetadata::clear_has_is_aliased() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ResultColumnMetadata::clear_is_aliased() {
  is_aliased_ = false;
  clear_has_is_aliased();
}
inline bool ResultColumnMetadata::is_aliased() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.is_aliased)
  return is_aliased_;
}
inline void ResultColumnMetadata::set_is_aliased(bool value) {
  set_has_is_aliased();
  is_aliased_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.is_aliased)
}

// optional .exec.user.ColumnSearchability searchability = 13;
inline bool ResultColumnMetadata::has_searchability() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ResultColumnMetadata::set_has_searchability() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ResultColumnMetadata::clear_has_searchability() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ResultColumnMetadata::clear_searchability() {
  searchability_ = 0;
  clear_has_searchability();
}
inline ::exec::user::ColumnSearchability ResultColumnMetadata::searchability() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.searchability)
  return static_cast< ::exec::user::ColumnSearchability >(searchability_);
}
inline void ResultColumnMetadata::set_searchability(::exec::user::ColumnSearchability value) {
  assert(::exec::user::ColumnSearchability_IsValid(value));
  set_has_searchability();
  searchability_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.searchability)
}

// optional .exec.user.ColumnUpdatability updatability = 14;
inline bool ResultColumnMetadata::has_updatability() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ResultColumnMetadata::set_has_updatability() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ResultColumnMetadata::clear_has_updatability() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ResultColumnMetadata::clear_updatability() {
  updatability_ = 0;
  clear_has_updatability();
}
inline ::exec::user::ColumnUpdatability ResultColumnMetadata::updatability() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.updatability)
  return static_cast< ::exec::user::ColumnUpdatability >(updatability_);
}
inline void ResultColumnMetadata::set_updatability(::exec::user::ColumnUpdatability value) {
  assert(::exec::user::ColumnUpdatability_IsValid(value));
  set_has_updatability();
  updatability_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.updatability)
}

// optional bool auto_increment = 15;
inline bool ResultColumnMetadata::has_auto_increment() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ResultColumnMetadata::set_has_auto_increment() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ResultColumnMetadata::clear_has_auto_increment() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ResultColumnMetadata::clear_auto_increment() {
  auto_increment_ = false;
  clear_has_auto_increment();
}
inline bool ResultColumnMetadata::auto_increment() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.auto_increment)
  return auto_increment_;
}
inline void ResultColumnMetadata::set_auto_increment(bool value) {
  set_has_auto_increment();
  auto_increment_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.auto_increment)
}

// optional bool case_sensitivity = 16;
inline bool ResultColumnMetadata::has_case_sensitivity() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ResultColumnMetadata::set_has_case_sensitivity() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ResultColumnMetadata::clear_has_case_sensitivity() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ResultColumnMetadata::clear_case_sensitivity() {
  case_sensitivity_ = false;
  clear_has_case_sensitivity();
}
inline bool ResultColumnMetadata::case_sensitivity() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.case_sensitivity)
  return case_sensitivity_;
}
inline void ResultColumnMetadata::set_case_sensitivity(bool value) {
  set_has_case_sensitivity();
  case_sensitivity_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.case_sensitivity)
}

// optional bool sortable = 17;
inline bool ResultColumnMetadata::has_sortable() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ResultColumnMetadata::set_has_sortable() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ResultColumnMetadata::clear_has_sortable() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ResultColumnMetadata::clear_sortable() {
  sortable_ = false;
  clear_has_sortable();
}
inline bool ResultColumnMetadata::sortable() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.sortable)
  return sortable_;
}
inline void ResultColumnMetadata::set_sortable(bool value) {
  set_has_sortable();
  sortable_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.sortable)
}

// optional string class_name = 18;
inline bool ResultColumnMetadata::has_class_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResultColumnMetadata::set_has_class_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResultColumnMetadata::clear_has_class_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResultColumnMetadata::clear_class_name() {
  class_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_class_name();
}
inline const ::std::string& ResultColumnMetadata::class_name() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.class_name)
  return class_name_.GetNoArena();
}
inline void ResultColumnMetadata::set_class_name(const ::std::string& value) {
  set_has_class_name();
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.class_name)
}
#if LANG_CXX11
inline void ResultColumnMetadata::set_class_name(::std::string&& value) {
  set_has_class_name();
  class_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ResultColumnMetadata.class_name)
}
#endif
inline void ResultColumnMetadata::set_class_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_class_name();
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ResultColumnMetadata.class_name)
}
inline void ResultColumnMetadata::set_class_name(const char* value, size_t size) {
  set_has_class_name();
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ResultColumnMetadata.class_name)
}
inline ::std::string* ResultColumnMetadata::mutable_class_name() {
  set_has_class_name();
  // @@protoc_insertion_point(field_mutable:exec.user.ResultColumnMetadata.class_name)
  return class_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResultColumnMetadata::release_class_name() {
  // @@protoc_insertion_point(field_release:exec.user.ResultColumnMetadata.class_name)
  if (!has_class_name()) {
    return NULL;
  }
  clear_has_class_name();
  return class_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResultColumnMetadata::set_allocated_class_name(::std::string* class_name) {
  if (class_name != NULL) {
    set_has_class_name();
  } else {
    clear_has_class_name();
  }
  class_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), class_name);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ResultColumnMetadata.class_name)
}

// optional bool is_currency = 20;
inline bool ResultColumnMetadata::has_is_currency() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ResultColumnMetadata::set_has_is_currency() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ResultColumnMetadata::clear_has_is_currency() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ResultColumnMetadata::clear_is_currency() {
  is_currency_ = false;
  clear_has_is_currency();
}
inline bool ResultColumnMetadata::is_currency() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.is_currency)
  return is_currency_;
}
inline void ResultColumnMetadata::set_is_currency(bool value) {
  set_has_is_currency();
  is_currency_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.is_currency)
}

// -------------------------------------------------------------------

// PreparedStatementHandle

// optional bytes server_info = 1;
inline bool PreparedStatementHandle::has_server_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PreparedStatementHandle::set_has_server_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PreparedStatementHandle::clear_has_server_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PreparedStatementHandle::clear_server_info() {
  server_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_server_info();
}
inline const ::std::string& PreparedStatementHandle::server_info() const {
  // @@protoc_insertion_point(field_get:exec.user.PreparedStatementHandle.server_info)
  return server_info_.GetNoArena();
}
inline void PreparedStatementHandle::set_server_info(const ::std::string& value) {
  set_has_server_info();
  server_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.PreparedStatementHandle.server_info)
}
#if LANG_CXX11
inline void PreparedStatementHandle::set_server_info(::std::string&& value) {
  set_has_server_info();
  server_info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.PreparedStatementHandle.server_info)
}
#endif
inline void PreparedStatementHandle::set_server_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_server_info();
  server_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.PreparedStatementHandle.server_info)
}
inline void PreparedStatementHandle::set_server_info(const void* value, size_t size) {
  set_has_server_info();
  server_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.PreparedStatementHandle.server_info)
}
inline ::std::string* PreparedStatementHandle::mutable_server_info() {
  set_has_server_info();
  // @@protoc_insertion_point(field_mutable:exec.user.PreparedStatementHandle.server_info)
  return server_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PreparedStatementHandle::release_server_info() {
  // @@protoc_insertion_point(field_release:exec.user.PreparedStatementHandle.server_info)
  if (!has_server_info()) {
    return NULL;
  }
  clear_has_server_info();
  return server_info_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PreparedStatementHandle::set_allocated_server_info(::std::string* server_info) {
  if (server_info != NULL) {
    set_has_server_info();
  } else {
    clear_has_server_info();
  }
  server_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server_info);
  // @@protoc_insertion_point(field_set_allocated:exec.user.PreparedStatementHandle.server_info)
}

// -------------------------------------------------------------------

// PreparedStatement

// repeated .exec.user.ResultColumnMetadata columns = 1;
inline int PreparedStatement::columns_size() const {
  return columns_.size();
}
inline void PreparedStatement::clear_columns() {
  columns_.Clear();
}
inline ::exec::user::ResultColumnMetadata* PreparedStatement::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.PreparedStatement.columns)
  return columns_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::exec::user::ResultColumnMetadata >*
PreparedStatement::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.PreparedStatement.columns)
  return &columns_;
}
inline const ::exec::user::ResultColumnMetadata& PreparedStatement::columns(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.PreparedStatement.columns)
  return columns_.Get(index);
}
inline ::exec::user::ResultColumnMetadata* PreparedStatement::add_columns() {
  // @@protoc_insertion_point(field_add:exec.user.PreparedStatement.columns)
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::user::ResultColumnMetadata >&
PreparedStatement::columns() const {
  // @@protoc_insertion_point(field_list:exec.user.PreparedStatement.columns)
  return columns_;
}

// optional .exec.user.PreparedStatementHandle server_handle = 2;
inline bool PreparedStatement::has_server_handle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PreparedStatement::set_has_server_handle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PreparedStatement::clear_has_server_handle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PreparedStatement::clear_server_handle() {
  if (server_handle_ != NULL) server_handle_->Clear();
  clear_has_server_handle();
}
inline const ::exec::user::PreparedStatementHandle& PreparedStatement::_internal_server_handle() const {
  return *server_handle_;
}
inline const ::exec::user::PreparedStatementHandle& PreparedStatement::server_handle() const {
  const ::exec::user::PreparedStatementHandle* p = server_handle_;
  // @@protoc_insertion_point(field_get:exec.user.PreparedStatement.server_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::user::PreparedStatementHandle*>(
      &::exec::user::_PreparedStatementHandle_default_instance_);
}
inline ::exec::user::PreparedStatementHandle* PreparedStatement::release_server_handle() {
  // @@protoc_insertion_point(field_release:exec.user.PreparedStatement.server_handle)
  clear_has_server_handle();
  ::exec::user::PreparedStatementHandle* temp = server_handle_;
  server_handle_ = NULL;
  return temp;
}
inline ::exec::user::PreparedStatementHandle* PreparedStatement::mutable_server_handle() {
  set_has_server_handle();
  if (server_handle_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::user::PreparedStatementHandle>(GetArenaNoVirtual());
    server_handle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.PreparedStatement.server_handle)
  return server_handle_;
}
inline void PreparedStatement::set_allocated_server_handle(::exec::user::PreparedStatementHandle* server_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_handle_;
  }
  if (server_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server_handle, submessage_arena);
    }
    set_has_server_handle();
  } else {
    clear_has_server_handle();
  }
  server_handle_ = server_handle;
  // @@protoc_insertion_point(field_set_allocated:exec.user.PreparedStatement.server_handle)
}

// -------------------------------------------------------------------

// CreatePreparedStatementResp

// optional .exec.user.RequestStatus status = 1;
inline bool CreatePreparedStatementResp::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreatePreparedStatementResp::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreatePreparedStatementResp::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreatePreparedStatementResp::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::exec::user::RequestStatus CreatePreparedStatementResp::status() const {
  // @@protoc_insertion_point(field_get:exec.user.CreatePreparedStatementResp.status)
  return static_cast< ::exec::user::RequestStatus >(status_);
}
inline void CreatePreparedStatementResp::set_status(::exec::user::RequestStatus value) {
  assert(::exec::user::RequestStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:exec.user.CreatePreparedStatementResp.status)
}

// optional .exec.user.PreparedStatement prepared_statement = 2;
inline bool CreatePreparedStatementResp::has_prepared_statement() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreatePreparedStatementResp::set_has_prepared_statement() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreatePreparedStatementResp::clear_has_prepared_statement() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreatePreparedStatementResp::clear_prepared_statement() {
  if (prepared_statement_ != NULL) prepared_statement_->Clear();
  clear_has_prepared_statement();
}
inline const ::exec::user::PreparedStatement& CreatePreparedStatementResp::_internal_prepared_statement() const {
  return *prepared_statement_;
}
inline const ::exec::user::PreparedStatement& CreatePreparedStatementResp::prepared_statement() const {
  const ::exec::user::PreparedStatement* p = prepared_statement_;
  // @@protoc_insertion_point(field_get:exec.user.CreatePreparedStatementResp.prepared_statement)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::user::PreparedStatement*>(
      &::exec::user::_PreparedStatement_default_instance_);
}
inline ::exec::user::PreparedStatement* CreatePreparedStatementResp::release_prepared_statement() {
  // @@protoc_insertion_point(field_release:exec.user.CreatePreparedStatementResp.prepared_statement)
  clear_has_prepared_statement();
  ::exec::user::PreparedStatement* temp = prepared_statement_;
  prepared_statement_ = NULL;
  return temp;
}
inline ::exec::user::PreparedStatement* CreatePreparedStatementResp::mutable_prepared_statement() {
  set_has_prepared_statement();
  if (prepared_statement_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::user::PreparedStatement>(GetArenaNoVirtual());
    prepared_statement_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.CreatePreparedStatementResp.prepared_statement)
  return prepared_statement_;
}
inline void CreatePreparedStatementResp::set_allocated_prepared_statement(::exec::user::PreparedStatement* prepared_statement) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete prepared_statement_;
  }
  if (prepared_statement) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      prepared_statement = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prepared_statement, submessage_arena);
    }
    set_has_prepared_statement();
  } else {
    clear_has_prepared_statement();
  }
  prepared_statement_ = prepared_statement;
  // @@protoc_insertion_point(field_set_allocated:exec.user.CreatePreparedStatementResp.prepared_statement)
}

// optional .exec.shared.DrillPBError error = 3;
inline bool CreatePreparedStatementResp::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreatePreparedStatementResp::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreatePreparedStatementResp::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::exec::shared::DrillPBError& CreatePreparedStatementResp::_internal_error() const {
  return *error_;
}
inline const ::exec::shared::DrillPBError& CreatePreparedStatementResp::error() const {
  const ::exec::shared::DrillPBError* p = error_;
  // @@protoc_insertion_point(field_get:exec.user.CreatePreparedStatementResp.error)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::shared::DrillPBError*>(
      &::exec::shared::_DrillPBError_default_instance_);
}
inline ::exec::shared::DrillPBError* CreatePreparedStatementResp::release_error() {
  // @@protoc_insertion_point(field_release:exec.user.CreatePreparedStatementResp.error)
  clear_has_error();
  ::exec::shared::DrillPBError* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::exec::shared::DrillPBError* CreatePreparedStatementResp::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::shared::DrillPBError>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.CreatePreparedStatementResp.error)
  return error_;
}
inline void CreatePreparedStatementResp::set_allocated_error(::exec::shared::DrillPBError* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    set_has_error();
  } else {
    clear_has_error();
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:exec.user.CreatePreparedStatementResp.error)
}

// -------------------------------------------------------------------

// GetServerMetaReq

// -------------------------------------------------------------------

// ConvertSupport

// required .common.MinorType from = 1;
inline bool ConvertSupport::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConvertSupport::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConvertSupport::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConvertSupport::clear_from() {
  from_ = 0;
  clear_has_from();
}
inline ::common::MinorType ConvertSupport::from() const {
  // @@protoc_insertion_point(field_get:exec.user.ConvertSupport.from)
  return static_cast< ::common::MinorType >(from_);
}
inline void ConvertSupport::set_from(::common::MinorType value) {
  assert(::common::MinorType_IsValid(value));
  set_has_from();
  from_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ConvertSupport.from)
}

// required .common.MinorType to = 2;
inline bool ConvertSupport::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConvertSupport::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConvertSupport::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConvertSupport::clear_to() {
  to_ = 0;
  clear_has_to();
}
inline ::common::MinorType ConvertSupport::to() const {
  // @@protoc_insertion_point(field_get:exec.user.ConvertSupport.to)
  return static_cast< ::common::MinorType >(to_);
}
inline void ConvertSupport::set_to(::common::MinorType value) {
  assert(::common::MinorType_IsValid(value));
  set_has_to();
  to_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ConvertSupport.to)
}

// -------------------------------------------------------------------

// GetServerMetaResp

// optional .exec.user.RequestStatus status = 1;
inline bool GetServerMetaResp::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetServerMetaResp::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetServerMetaResp::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetServerMetaResp::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::exec::user::RequestStatus GetServerMetaResp::status() const {
  // @@protoc_insertion_point(field_get:exec.user.GetServerMetaResp.status)
  return static_cast< ::exec::user::RequestStatus >(status_);
}
inline void GetServerMetaResp::set_status(::exec::user::RequestStatus value) {
  assert(::exec::user::RequestStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:exec.user.GetServerMetaResp.status)
}

// optional .exec.user.ServerMeta server_meta = 2;
inline bool GetServerMetaResp::has_server_meta() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetServerMetaResp::set_has_server_meta() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetServerMetaResp::clear_has_server_meta() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetServerMetaResp::clear_server_meta() {
  if (server_meta_ != NULL) server_meta_->Clear();
  clear_has_server_meta();
}
inline const ::exec::user::ServerMeta& GetServerMetaResp::_internal_server_meta() const {
  return *server_meta_;
}
inline const ::exec::user::ServerMeta& GetServerMetaResp::server_meta() const {
  const ::exec::user::ServerMeta* p = server_meta_;
  // @@protoc_insertion_point(field_get:exec.user.GetServerMetaResp.server_meta)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::user::ServerMeta*>(
      &::exec::user::_ServerMeta_default_instance_);
}
inline ::exec::user::ServerMeta* GetServerMetaResp::release_server_meta() {
  // @@protoc_insertion_point(field_release:exec.user.GetServerMetaResp.server_meta)
  clear_has_server_meta();
  ::exec::user::ServerMeta* temp = server_meta_;
  server_meta_ = NULL;
  return temp;
}
inline ::exec::user::ServerMeta* GetServerMetaResp::mutable_server_meta() {
  set_has_server_meta();
  if (server_meta_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::user::ServerMeta>(GetArenaNoVirtual());
    server_meta_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.GetServerMetaResp.server_meta)
  return server_meta_;
}
inline void GetServerMetaResp::set_allocated_server_meta(::exec::user::ServerMeta* server_meta) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_meta_;
  }
  if (server_meta) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server_meta = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server_meta, submessage_arena);
    }
    set_has_server_meta();
  } else {
    clear_has_server_meta();
  }
  server_meta_ = server_meta;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetServerMetaResp.server_meta)
}

// optional .exec.shared.DrillPBError error = 3;
inline bool GetServerMetaResp::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetServerMetaResp::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetServerMetaResp::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::exec::shared::DrillPBError& GetServerMetaResp::_internal_error() const {
  return *error_;
}
inline const ::exec::shared::DrillPBError& GetServerMetaResp::error() const {
  const ::exec::shared::DrillPBError* p = error_;
  // @@protoc_insertion_point(field_get:exec.user.GetServerMetaResp.error)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::shared::DrillPBError*>(
      &::exec::shared::_DrillPBError_default_instance_);
}
inline ::exec::shared::DrillPBError* GetServerMetaResp::release_error() {
  // @@protoc_insertion_point(field_release:exec.user.GetServerMetaResp.error)
  clear_has_error();
  ::exec::shared::DrillPBError* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::exec::shared::DrillPBError* GetServerMetaResp::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::shared::DrillPBError>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.GetServerMetaResp.error)
  return error_;
}
inline void GetServerMetaResp::set_allocated_error(::exec::shared::DrillPBError* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    set_has_error();
  } else {
    clear_has_error();
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetServerMetaResp.error)
}

// -------------------------------------------------------------------

// ServerMeta

// optional bool all_tables_selectable = 1;
inline bool ServerMeta::has_all_tables_selectable() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ServerMeta::set_has_all_tables_selectable() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ServerMeta::clear_has_all_tables_selectable() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ServerMeta::clear_all_tables_selectable() {
  all_tables_selectable_ = false;
  clear_has_all_tables_selectable();
}
inline bool ServerMeta::all_tables_selectable() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.all_tables_selectable)
  return all_tables_selectable_;
}
inline void ServerMeta::set_all_tables_selectable(bool value) {
  set_has_all_tables_selectable();
  all_tables_selectable_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.all_tables_selectable)
}

// optional bool blob_included_in_max_row_size = 2;
inline bool ServerMeta::has_blob_included_in_max_row_size() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ServerMeta::set_has_blob_included_in_max_row_size() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ServerMeta::clear_has_blob_included_in_max_row_size() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ServerMeta::clear_blob_included_in_max_row_size() {
  blob_included_in_max_row_size_ = false;
  clear_has_blob_included_in_max_row_size();
}
inline bool ServerMeta::blob_included_in_max_row_size() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.blob_included_in_max_row_size)
  return blob_included_in_max_row_size_;
}
inline void ServerMeta::set_blob_included_in_max_row_size(bool value) {
  set_has_blob_included_in_max_row_size();
  blob_included_in_max_row_size_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.blob_included_in_max_row_size)
}

// optional bool catalog_at_start = 3;
inline bool ServerMeta::has_catalog_at_start() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ServerMeta::set_has_catalog_at_start() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ServerMeta::clear_has_catalog_at_start() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ServerMeta::clear_catalog_at_start() {
  catalog_at_start_ = false;
  clear_has_catalog_at_start();
}
inline bool ServerMeta::catalog_at_start() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.catalog_at_start)
  return catalog_at_start_;
}
inline void ServerMeta::set_catalog_at_start(bool value) {
  set_has_catalog_at_start();
  catalog_at_start_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.catalog_at_start)
}

// optional string catalog_separator = 4;
inline bool ServerMeta::has_catalog_separator() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerMeta::set_has_catalog_separator() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerMeta::clear_has_catalog_separator() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerMeta::clear_catalog_separator() {
  catalog_separator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_catalog_separator();
}
inline const ::std::string& ServerMeta::catalog_separator() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.catalog_separator)
  return catalog_separator_.GetNoArena();
}
inline void ServerMeta::set_catalog_separator(const ::std::string& value) {
  set_has_catalog_separator();
  catalog_separator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.catalog_separator)
}
#if LANG_CXX11
inline void ServerMeta::set_catalog_separator(::std::string&& value) {
  set_has_catalog_separator();
  catalog_separator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ServerMeta.catalog_separator)
}
#endif
inline void ServerMeta::set_catalog_separator(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_catalog_separator();
  catalog_separator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ServerMeta.catalog_separator)
}
inline void ServerMeta::set_catalog_separator(const char* value, size_t size) {
  set_has_catalog_separator();
  catalog_separator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ServerMeta.catalog_separator)
}
inline ::std::string* ServerMeta::mutable_catalog_separator() {
  set_has_catalog_separator();
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.catalog_separator)
  return catalog_separator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerMeta::release_catalog_separator() {
  // @@protoc_insertion_point(field_release:exec.user.ServerMeta.catalog_separator)
  if (!has_catalog_separator()) {
    return NULL;
  }
  clear_has_catalog_separator();
  return catalog_separator_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerMeta::set_allocated_catalog_separator(::std::string* catalog_separator) {
  if (catalog_separator != NULL) {
    set_has_catalog_separator();
  } else {
    clear_has_catalog_separator();
  }
  catalog_separator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), catalog_separator);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ServerMeta.catalog_separator)
}

// optional string catalog_term = 5;
inline bool ServerMeta::has_catalog_term() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerMeta::set_has_catalog_term() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerMeta::clear_has_catalog_term() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerMeta::clear_catalog_term() {
  catalog_term_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_catalog_term();
}
inline const ::std::string& ServerMeta::catalog_term() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.catalog_term)
  return catalog_term_.GetNoArena();
}
inline void ServerMeta::set_catalog_term(const ::std::string& value) {
  set_has_catalog_term();
  catalog_term_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.catalog_term)
}
#if LANG_CXX11
inline void ServerMeta::set_catalog_term(::std::string&& value) {
  set_has_catalog_term();
  catalog_term_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ServerMeta.catalog_term)
}
#endif
inline void ServerMeta::set_catalog_term(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_catalog_term();
  catalog_term_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ServerMeta.catalog_term)
}
inline void ServerMeta::set_catalog_term(const char* value, size_t size) {
  set_has_catalog_term();
  catalog_term_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ServerMeta.catalog_term)
}
inline ::std::string* ServerMeta::mutable_catalog_term() {
  set_has_catalog_term();
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.catalog_term)
  return catalog_term_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerMeta::release_catalog_term() {
  // @@protoc_insertion_point(field_release:exec.user.ServerMeta.catalog_term)
  if (!has_catalog_term()) {
    return NULL;
  }
  clear_has_catalog_term();
  return catalog_term_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerMeta::set_allocated_catalog_term(::std::string* catalog_term) {
  if (catalog_term != NULL) {
    set_has_catalog_term();
  } else {
    clear_has_catalog_term();
  }
  catalog_term_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), catalog_term);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ServerMeta.catalog_term)
}

// repeated .exec.user.CollateSupport collate_support = 6;
inline int ServerMeta::collate_support_size() const {
  return collate_support_.size();
}
inline void ServerMeta::clear_collate_support() {
  collate_support_.Clear();
}
inline ::exec::user::CollateSupport ServerMeta::collate_support(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.collate_support)
  return static_cast< ::exec::user::CollateSupport >(collate_support_.Get(index));
}
inline void ServerMeta::set_collate_support(int index, ::exec::user::CollateSupport value) {
  assert(::exec::user::CollateSupport_IsValid(value));
  collate_support_.Set(index, value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.collate_support)
}
inline void ServerMeta::add_collate_support(::exec::user::CollateSupport value) {
  assert(::exec::user::CollateSupport_IsValid(value));
  collate_support_.Add(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.collate_support)
}
inline const ::google::protobuf::RepeatedField<int>&
ServerMeta::collate_support() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.collate_support)
  return collate_support_;
}
inline ::google::protobuf::RepeatedField<int>*
ServerMeta::mutable_collate_support() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.collate_support)
  return &collate_support_;
}

// optional bool column_aliasing_supported = 7;
inline bool ServerMeta::has_column_aliasing_supported() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ServerMeta::set_has_column_aliasing_supported() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ServerMeta::clear_has_column_aliasing_supported() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ServerMeta::clear_column_aliasing_supported() {
  column_aliasing_supported_ = false;
  clear_has_column_aliasing_supported();
}
inline bool ServerMeta::column_aliasing_supported() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.column_aliasing_supported)
  return column_aliasing_supported_;
}
inline void ServerMeta::set_column_aliasing_supported(bool value) {
  set_has_column_aliasing_supported();
  column_aliasing_supported_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.column_aliasing_supported)
}

// repeated .exec.user.ConvertSupport convert_support = 8;
inline int ServerMeta::convert_support_size() const {
  return convert_support_.size();
}
inline void ServerMeta::clear_convert_support() {
  convert_support_.Clear();
}
inline ::exec::user::ConvertSupport* ServerMeta::mutable_convert_support(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.convert_support)
  return convert_support_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::exec::user::ConvertSupport >*
ServerMeta::mutable_convert_support() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.convert_support)
  return &convert_support_;
}
inline const ::exec::user::ConvertSupport& ServerMeta::convert_support(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.convert_support)
  return convert_support_.Get(index);
}
inline ::exec::user::ConvertSupport* ServerMeta::add_convert_support() {
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.convert_support)
  return convert_support_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::user::ConvertSupport >&
ServerMeta::convert_support() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.convert_support)
  return convert_support_;
}

// optional .exec.user.CorrelationNamesSupport correlation_names_support = 9;
inline bool ServerMeta::has_correlation_names_support() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void ServerMeta::set_has_correlation_names_support() {
  _has_bits_[1] |= 0x00000010u;
}
inline void ServerMeta::clear_has_correlation_names_support() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void ServerMeta::clear_correlation_names_support() {
  correlation_names_support_ = 1;
  clear_has_correlation_names_support();
}
inline ::exec::user::CorrelationNamesSupport ServerMeta::correlation_names_support() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.correlation_names_support)
  return static_cast< ::exec::user::CorrelationNamesSupport >(correlation_names_support_);
}
inline void ServerMeta::set_correlation_names_support(::exec::user::CorrelationNamesSupport value) {
  assert(::exec::user::CorrelationNamesSupport_IsValid(value));
  set_has_correlation_names_support();
  correlation_names_support_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.correlation_names_support)
}

// repeated string date_time_functions = 10;
inline int ServerMeta::date_time_functions_size() const {
  return date_time_functions_.size();
}
inline void ServerMeta::clear_date_time_functions() {
  date_time_functions_.Clear();
}
inline const ::std::string& ServerMeta::date_time_functions(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.date_time_functions)
  return date_time_functions_.Get(index);
}
inline ::std::string* ServerMeta::mutable_date_time_functions(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.date_time_functions)
  return date_time_functions_.Mutable(index);
}
inline void ServerMeta::set_date_time_functions(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.date_time_functions)
  date_time_functions_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ServerMeta::set_date_time_functions(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.date_time_functions)
  date_time_functions_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ServerMeta::set_date_time_functions(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  date_time_functions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:exec.user.ServerMeta.date_time_functions)
}
inline void ServerMeta::set_date_time_functions(int index, const char* value, size_t size) {
  date_time_functions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:exec.user.ServerMeta.date_time_functions)
}
inline ::std::string* ServerMeta::add_date_time_functions() {
  // @@protoc_insertion_point(field_add_mutable:exec.user.ServerMeta.date_time_functions)
  return date_time_functions_.Add();
}
inline void ServerMeta::add_date_time_functions(const ::std::string& value) {
  date_time_functions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.date_time_functions)
}
#if LANG_CXX11
inline void ServerMeta::add_date_time_functions(::std::string&& value) {
  date_time_functions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.date_time_functions)
}
#endif
inline void ServerMeta::add_date_time_functions(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  date_time_functions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:exec.user.ServerMeta.date_time_functions)
}
inline void ServerMeta::add_date_time_functions(const char* value, size_t size) {
  date_time_functions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:exec.user.ServerMeta.date_time_functions)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ServerMeta::date_time_functions() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.date_time_functions)
  return date_time_functions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ServerMeta::mutable_date_time_functions() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.date_time_functions)
  return &date_time_functions_;
}

// repeated .exec.user.DateTimeLiteralsSupport date_time_literals_support = 11;
inline int ServerMeta::date_time_literals_support_size() const {
  return date_time_literals_support_.size();
}
inline void ServerMeta::clear_date_time_literals_support() {
  date_time_literals_support_.Clear();
}
inline ::exec::user::DateTimeLiteralsSupport ServerMeta::date_time_literals_support(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.date_time_literals_support)
  return static_cast< ::exec::user::DateTimeLiteralsSupport >(date_time_literals_support_.Get(index));
}
inline void ServerMeta::set_date_time_literals_support(int index, ::exec::user::DateTimeLiteralsSupport value) {
  assert(::exec::user::DateTimeLiteralsSupport_IsValid(value));
  date_time_literals_support_.Set(index, value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.date_time_literals_support)
}
inline void ServerMeta::add_date_time_literals_support(::exec::user::DateTimeLiteralsSupport value) {
  assert(::exec::user::DateTimeLiteralsSupport_IsValid(value));
  date_time_literals_support_.Add(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.date_time_literals_support)
}
inline const ::google::protobuf::RepeatedField<int>&
ServerMeta::date_time_literals_support() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.date_time_literals_support)
  return date_time_literals_support_;
}
inline ::google::protobuf::RepeatedField<int>*
ServerMeta::mutable_date_time_literals_support() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.date_time_literals_support)
  return &date_time_literals_support_;
}

// optional .exec.user.GroupBySupport group_by_support = 12;
inline bool ServerMeta::has_group_by_support() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void ServerMeta::set_has_group_by_support() {
  _has_bits_[1] |= 0x00000020u;
}
inline void ServerMeta::clear_has_group_by_support() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void ServerMeta::clear_group_by_support() {
  group_by_support_ = 1;
  clear_has_group_by_support();
}
inline ::exec::user::GroupBySupport ServerMeta::group_by_support() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.group_by_support)
  return static_cast< ::exec::user::GroupBySupport >(group_by_support_);
}
inline void ServerMeta::set_group_by_support(::exec::user::GroupBySupport value) {
  assert(::exec::user::GroupBySupport_IsValid(value));
  set_has_group_by_support();
  group_by_support_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.group_by_support)
}

// optional .exec.user.IdentifierCasing identifier_casing = 13;
inline bool ServerMeta::has_identifier_casing() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ServerMeta::set_has_identifier_casing() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ServerMeta::clear_has_identifier_casing() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ServerMeta::clear_identifier_casing() {
  identifier_casing_ = 0;
  clear_has_identifier_casing();
}
inline ::exec::user::IdentifierCasing ServerMeta::identifier_casing() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.identifier_casing)
  return static_cast< ::exec::user::IdentifierCasing >(identifier_casing_);
}
inline void ServerMeta::set_identifier_casing(::exec::user::IdentifierCasing value) {
  assert(::exec::user::IdentifierCasing_IsValid(value));
  set_has_identifier_casing();
  identifier_casing_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.identifier_casing)
}

// optional string identifier_quote_string = 14;
inline bool ServerMeta::has_identifier_quote_string() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerMeta::set_has_identifier_quote_string() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerMeta::clear_has_identifier_quote_string() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerMeta::clear_identifier_quote_string() {
  identifier_quote_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_identifier_quote_string();
}
inline const ::std::string& ServerMeta::identifier_quote_string() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.identifier_quote_string)
  return identifier_quote_string_.GetNoArena();
}
inline void ServerMeta::set_identifier_quote_string(const ::std::string& value) {
  set_has_identifier_quote_string();
  identifier_quote_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.identifier_quote_string)
}
#if LANG_CXX11
inline void ServerMeta::set_identifier_quote_string(::std::string&& value) {
  set_has_identifier_quote_string();
  identifier_quote_string_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ServerMeta.identifier_quote_string)
}
#endif
inline void ServerMeta::set_identifier_quote_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_identifier_quote_string();
  identifier_quote_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ServerMeta.identifier_quote_string)
}
inline void ServerMeta::set_identifier_quote_string(const char* value, size_t size) {
  set_has_identifier_quote_string();
  identifier_quote_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ServerMeta.identifier_quote_string)
}
inline ::std::string* ServerMeta::mutable_identifier_quote_string() {
  set_has_identifier_quote_string();
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.identifier_quote_string)
  return identifier_quote_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerMeta::release_identifier_quote_string() {
  // @@protoc_insertion_point(field_release:exec.user.ServerMeta.identifier_quote_string)
  if (!has_identifier_quote_string()) {
    return NULL;
  }
  clear_has_identifier_quote_string();
  return identifier_quote_string_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerMeta::set_allocated_identifier_quote_string(::std::string* identifier_quote_string) {
  if (identifier_quote_string != NULL) {
    set_has_identifier_quote_string();
  } else {
    clear_has_identifier_quote_string();
  }
  identifier_quote_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), identifier_quote_string);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ServerMeta.identifier_quote_string)
}

// optional bool like_escape_clause_supported = 15;
inline bool ServerMeta::has_like_escape_clause_supported() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void ServerMeta::set_has_like_escape_clause_supported() {
  _has_bits_[0] |= 0x20000000u;
}
inline void ServerMeta::clear_has_like_escape_clause_supported() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void ServerMeta::clear_like_escape_clause_supported() {
  like_escape_clause_supported_ = false;
  clear_has_like_escape_clause_supported();
}
inline bool ServerMeta::like_escape_clause_supported() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.like_escape_clause_supported)
  return like_escape_clause_supported_;
}
inline void ServerMeta::set_like_escape_clause_supported(bool value) {
  set_has_like_escape_clause_supported();
  like_escape_clause_supported_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.like_escape_clause_supported)
}

// optional uint32 max_binary_literal_length = 16;
inline bool ServerMeta::has_max_binary_literal_length() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ServerMeta::set_has_max_binary_literal_length() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ServerMeta::clear_has_max_binary_literal_length() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ServerMeta::clear_max_binary_literal_length() {
  max_binary_literal_length_ = 0u;
  clear_has_max_binary_literal_length();
}
inline ::google::protobuf::uint32 ServerMeta::max_binary_literal_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_binary_literal_length)
  return max_binary_literal_length_;
}
inline void ServerMeta::set_max_binary_literal_length(::google::protobuf::uint32 value) {
  set_has_max_binary_literal_length();
  max_binary_literal_length_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_binary_literal_length)
}

// optional uint32 max_catalog_name_length = 17;
inline bool ServerMeta::has_max_catalog_name_length() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ServerMeta::set_has_max_catalog_name_length() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ServerMeta::clear_has_max_catalog_name_length() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ServerMeta::clear_max_catalog_name_length() {
  max_catalog_name_length_ = 0u;
  clear_has_max_catalog_name_length();
}
inline ::google::protobuf::uint32 ServerMeta::max_catalog_name_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_catalog_name_length)
  return max_catalog_name_length_;
}
inline void ServerMeta::set_max_catalog_name_length(::google::protobuf::uint32 value) {
  set_has_max_catalog_name_length();
  max_catalog_name_length_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_catalog_name_length)
}

// optional uint32 max_char_literal_length = 18;
inline bool ServerMeta::has_max_char_literal_length() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ServerMeta::set_has_max_char_literal_length() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ServerMeta::clear_has_max_char_literal_length() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ServerMeta::clear_max_char_literal_length() {
  max_char_literal_length_ = 0u;
  clear_has_max_char_literal_length();
}
inline ::google::protobuf::uint32 ServerMeta::max_char_literal_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_char_literal_length)
  return max_char_literal_length_;
}
inline void ServerMeta::set_max_char_literal_length(::google::protobuf::uint32 value) {
  set_has_max_char_literal_length();
  max_char_literal_length_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_char_literal_length)
}

// optional uint32 max_column_name_length = 19;
inline bool ServerMeta::has_max_column_name_length() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ServerMeta::set_has_max_column_name_length() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ServerMeta::clear_has_max_column_name_length() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ServerMeta::clear_max_column_name_length() {
  max_column_name_length_ = 0u;
  clear_has_max_column_name_length();
}
inline ::google::protobuf::uint32 ServerMeta::max_column_name_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_column_name_length)
  return max_column_name_length_;
}
inline void ServerMeta::set_max_column_name_length(::google::protobuf::uint32 value) {
  set_has_max_column_name_length();
  max_column_name_length_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_column_name_length)
}

// optional uint32 max_columns_in_group_by = 20;
inline bool ServerMeta::has_max_columns_in_group_by() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ServerMeta::set_has_max_columns_in_group_by() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ServerMeta::clear_has_max_columns_in_group_by() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ServerMeta::clear_max_columns_in_group_by() {
  max_columns_in_group_by_ = 0u;
  clear_has_max_columns_in_group_by();
}
inline ::google::protobuf::uint32 ServerMeta::max_columns_in_group_by() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_columns_in_group_by)
  return max_columns_in_group_by_;
}
inline void ServerMeta::set_max_columns_in_group_by(::google::protobuf::uint32 value) {
  set_has_max_columns_in_group_by();
  max_columns_in_group_by_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_columns_in_group_by)
}

// optional uint32 max_columns_in_order_by = 21;
inline bool ServerMeta::has_max_columns_in_order_by() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ServerMeta::set_has_max_columns_in_order_by() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ServerMeta::clear_has_max_columns_in_order_by() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ServerMeta::clear_max_columns_in_order_by() {
  max_columns_in_order_by_ = 0u;
  clear_has_max_columns_in_order_by();
}
inline ::google::protobuf::uint32 ServerMeta::max_columns_in_order_by() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_columns_in_order_by)
  return max_columns_in_order_by_;
}
inline void ServerMeta::set_max_columns_in_order_by(::google::protobuf::uint32 value) {
  set_has_max_columns_in_order_by();
  max_columns_in_order_by_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_columns_in_order_by)
}

// optional uint32 max_columns_in_select = 22;
inline bool ServerMeta::has_max_columns_in_select() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ServerMeta::set_has_max_columns_in_select() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ServerMeta::clear_has_max_columns_in_select() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ServerMeta::clear_max_columns_in_select() {
  max_columns_in_select_ = 0u;
  clear_has_max_columns_in_select();
}
inline ::google::protobuf::uint32 ServerMeta::max_columns_in_select() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_columns_in_select)
  return max_columns_in_select_;
}
inline void ServerMeta::set_max_columns_in_select(::google::protobuf::uint32 value) {
  set_has_max_columns_in_select();
  max_columns_in_select_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_columns_in_select)
}

// optional uint32 max_cursor_name_length = 23;
inline bool ServerMeta::has_max_cursor_name_length() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ServerMeta::set_has_max_cursor_name_length() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ServerMeta::clear_has_max_cursor_name_length() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ServerMeta::clear_max_cursor_name_length() {
  max_cursor_name_length_ = 0u;
  clear_has_max_cursor_name_length();
}
inline ::google::protobuf::uint32 ServerMeta::max_cursor_name_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_cursor_name_length)
  return max_cursor_name_length_;
}
inline void ServerMeta::set_max_cursor_name_length(::google::protobuf::uint32 value) {
  set_has_max_cursor_name_length();
  max_cursor_name_length_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_cursor_name_length)
}

// optional uint32 max_logical_lob_size = 24;
inline bool ServerMeta::has_max_logical_lob_size() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ServerMeta::set_has_max_logical_lob_size() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ServerMeta::clear_has_max_logical_lob_size() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ServerMeta::clear_max_logical_lob_size() {
  max_logical_lob_size_ = 0u;
  clear_has_max_logical_lob_size();
}
inline ::google::protobuf::uint32 ServerMeta::max_logical_lob_size() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_logical_lob_size)
  return max_logical_lob_size_;
}
inline void ServerMeta::set_max_logical_lob_size(::google::protobuf::uint32 value) {
  set_has_max_logical_lob_size();
  max_logical_lob_size_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_logical_lob_size)
}

// optional uint32 max_row_size = 25;
inline bool ServerMeta::has_max_row_size() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ServerMeta::set_has_max_row_size() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ServerMeta::clear_has_max_row_size() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ServerMeta::clear_max_row_size() {
  max_row_size_ = 0u;
  clear_has_max_row_size();
}
inline ::google::protobuf::uint32 ServerMeta::max_row_size() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_row_size)
  return max_row_size_;
}
inline void ServerMeta::set_max_row_size(::google::protobuf::uint32 value) {
  set_has_max_row_size();
  max_row_size_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_row_size)
}

// optional uint32 max_schema_name_length = 26;
inline bool ServerMeta::has_max_schema_name_length() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ServerMeta::set_has_max_schema_name_length() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ServerMeta::clear_has_max_schema_name_length() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ServerMeta::clear_max_schema_name_length() {
  max_schema_name_length_ = 0u;
  clear_has_max_schema_name_length();
}
inline ::google::protobuf::uint32 ServerMeta::max_schema_name_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_schema_name_length)
  return max_schema_name_length_;
}
inline void ServerMeta::set_max_schema_name_length(::google::protobuf::uint32 value) {
  set_has_max_schema_name_length();
  max_schema_name_length_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_schema_name_length)
}

// optional uint32 max_statement_length = 27;
inline bool ServerMeta::has_max_statement_length() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ServerMeta::set_has_max_statement_length() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ServerMeta::clear_has_max_statement_length() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ServerMeta::clear_max_statement_length() {
  max_statement_length_ = 0u;
  clear_has_max_statement_length();
}
inline ::google::protobuf::uint32 ServerMeta::max_statement_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_statement_length)
  return max_statement_length_;
}
inline void ServerMeta::set_max_statement_length(::google::protobuf::uint32 value) {
  set_has_max_statement_length();
  max_statement_length_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_statement_length)
}

// optional uint32 max_statements = 28;
inline bool ServerMeta::has_max_statements() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ServerMeta::set_has_max_statements() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ServerMeta::clear_has_max_statements() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ServerMeta::clear_max_statements() {
  max_statements_ = 0u;
  clear_has_max_statements();
}
inline ::google::protobuf::uint32 ServerMeta::max_statements() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_statements)
  return max_statements_;
}
inline void ServerMeta::set_max_statements(::google::protobuf::uint32 value) {
  set_has_max_statements();
  max_statements_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_statements)
}

// optional uint32 max_table_name_length = 29;
inline bool ServerMeta::has_max_table_name_length() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ServerMeta::set_has_max_table_name_length() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ServerMeta::clear_has_max_table_name_length() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ServerMeta::clear_max_table_name_length() {
  max_table_name_length_ = 0u;
  clear_has_max_table_name_length();
}
inline ::google::protobuf::uint32 ServerMeta::max_table_name_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_table_name_length)
  return max_table_name_length_;
}
inline void ServerMeta::set_max_table_name_length(::google::protobuf::uint32 value) {
  set_has_max_table_name_length();
  max_table_name_length_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_table_name_length)
}

// optional uint32 max_tables_in_select = 30;
inline bool ServerMeta::has_max_tables_in_select() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ServerMeta::set_has_max_tables_in_select() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ServerMeta::clear_has_max_tables_in_select() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ServerMeta::clear_max_tables_in_select() {
  max_tables_in_select_ = 0u;
  clear_has_max_tables_in_select();
}
inline ::google::protobuf::uint32 ServerMeta::max_tables_in_select() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_tables_in_select)
  return max_tables_in_select_;
}
inline void ServerMeta::set_max_tables_in_select(::google::protobuf::uint32 value) {
  set_has_max_tables_in_select();
  max_tables_in_select_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_tables_in_select)
}

// optional uint32 max_user_name_length = 31;
inline bool ServerMeta::has_max_user_name_length() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ServerMeta::set_has_max_user_name_length() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ServerMeta::clear_has_max_user_name_length() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ServerMeta::clear_max_user_name_length() {
  max_user_name_length_ = 0u;
  clear_has_max_user_name_length();
}
inline ::google::protobuf::uint32 ServerMeta::max_user_name_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_user_name_length)
  return max_user_name_length_;
}
inline void ServerMeta::set_max_user_name_length(::google::protobuf::uint32 value) {
  set_has_max_user_name_length();
  max_user_name_length_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_user_name_length)
}

// optional .exec.user.NullCollation null_collation = 32;
inline bool ServerMeta::has_null_collation() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void ServerMeta::set_has_null_collation() {
  _has_bits_[1] |= 0x00000002u;
}
inline void ServerMeta::clear_has_null_collation() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void ServerMeta::clear_null_collation() {
  null_collation_ = 0;
  clear_has_null_collation();
}
inline ::exec::user::NullCollation ServerMeta::null_collation() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.null_collation)
  return static_cast< ::exec::user::NullCollation >(null_collation_);
}
inline void ServerMeta::set_null_collation(::exec::user::NullCollation value) {
  assert(::exec::user::NullCollation_IsValid(value));
  set_has_null_collation();
  null_collation_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.null_collation)
}

// optional bool null_plus_non_null_equals_null = 33;
inline bool ServerMeta::has_null_plus_non_null_equals_null() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void ServerMeta::set_has_null_plus_non_null_equals_null() {
  _has_bits_[0] |= 0x40000000u;
}
inline void ServerMeta::clear_has_null_plus_non_null_equals_null() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void ServerMeta::clear_null_plus_non_null_equals_null() {
  null_plus_non_null_equals_null_ = false;
  clear_has_null_plus_non_null_equals_null();
}
inline bool ServerMeta::null_plus_non_null_equals_null() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.null_plus_non_null_equals_null)
  return null_plus_non_null_equals_null_;
}
inline void ServerMeta::set_null_plus_non_null_equals_null(bool value) {
  set_has_null_plus_non_null_equals_null();
  null_plus_non_null_equals_null_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.null_plus_non_null_equals_null)
}

// repeated string numeric_functions = 34;
inline int ServerMeta::numeric_functions_size() const {
  return numeric_functions_.size();
}
inline void ServerMeta::clear_numeric_functions() {
  numeric_functions_.Clear();
}
inline const ::std::string& ServerMeta::numeric_functions(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.numeric_functions)
  return numeric_functions_.Get(index);
}
inline ::std::string* ServerMeta::mutable_numeric_functions(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.numeric_functions)
  return numeric_functions_.Mutable(index);
}
inline void ServerMeta::set_numeric_functions(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.numeric_functions)
  numeric_functions_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ServerMeta::set_numeric_functions(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.numeric_functions)
  numeric_functions_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ServerMeta::set_numeric_functions(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  numeric_functions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:exec.user.ServerMeta.numeric_functions)
}
inline void ServerMeta::set_numeric_functions(int index, const char* value, size_t size) {
  numeric_functions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:exec.user.ServerMeta.numeric_functions)
}
inline ::std::string* ServerMeta::add_numeric_functions() {
  // @@protoc_insertion_point(field_add_mutable:exec.user.ServerMeta.numeric_functions)
  return numeric_functions_.Add();
}
inline void ServerMeta::add_numeric_functions(const ::std::string& value) {
  numeric_functions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.numeric_functions)
}
#if LANG_CXX11
inline void ServerMeta::add_numeric_functions(::std::string&& value) {
  numeric_functions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.numeric_functions)
}
#endif
inline void ServerMeta::add_numeric_functions(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  numeric_functions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:exec.user.ServerMeta.numeric_functions)
}
inline void ServerMeta::add_numeric_functions(const char* value, size_t size) {
  numeric_functions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:exec.user.ServerMeta.numeric_functions)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ServerMeta::numeric_functions() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.numeric_functions)
  return numeric_functions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ServerMeta::mutable_numeric_functions() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.numeric_functions)
  return &numeric_functions_;
}

// repeated .exec.user.OrderBySupport order_by_support = 35;
inline int ServerMeta::order_by_support_size() const {
  return order_by_support_.size();
}
inline void ServerMeta::clear_order_by_support() {
  order_by_support_.Clear();
}
inline ::exec::user::OrderBySupport ServerMeta::order_by_support(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.order_by_support)
  return static_cast< ::exec::user::OrderBySupport >(order_by_support_.Get(index));
}
inline void ServerMeta::set_order_by_support(int index, ::exec::user::OrderBySupport value) {
  assert(::exec::user::OrderBySupport_IsValid(value));
  order_by_support_.Set(index, value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.order_by_support)
}
inline void ServerMeta::add_order_by_support(::exec::user::OrderBySupport value) {
  assert(::exec::user::OrderBySupport_IsValid(value));
  order_by_support_.Add(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.order_by_support)
}
inline const ::google::protobuf::RepeatedField<int>&
ServerMeta::order_by_support() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.order_by_support)
  return order_by_support_;
}
inline ::google::protobuf::RepeatedField<int>*
ServerMeta::mutable_order_by_support() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.order_by_support)
  return &order_by_support_;
}

// repeated .exec.user.OuterJoinSupport outer_join_support = 36;
inline int ServerMeta::outer_join_support_size() const {
  return outer_join_support_.size();
}
inline void ServerMeta::clear_outer_join_support() {
  outer_join_support_.Clear();
}
inline ::exec::user::OuterJoinSupport ServerMeta::outer_join_support(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.outer_join_support)
  return static_cast< ::exec::user::OuterJoinSupport >(outer_join_support_.Get(index));
}
inline void ServerMeta::set_outer_join_support(int index, ::exec::user::OuterJoinSupport value) {
  assert(::exec::user::OuterJoinSupport_IsValid(value));
  outer_join_support_.Set(index, value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.outer_join_support)
}
inline void ServerMeta::add_outer_join_support(::exec::user::OuterJoinSupport value) {
  assert(::exec::user::OuterJoinSupport_IsValid(value));
  outer_join_support_.Add(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.outer_join_support)
}
inline const ::google::protobuf::RepeatedField<int>&
ServerMeta::outer_join_support() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.outer_join_support)
  return outer_join_support_;
}
inline ::google::protobuf::RepeatedField<int>*
ServerMeta::mutable_outer_join_support() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.outer_join_support)
  return &outer_join_support_;
}

// optional .exec.user.IdentifierCasing quoted_identifier_casing = 37;
inline bool ServerMeta::has_quoted_identifier_casing() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void ServerMeta::set_has_quoted_identifier_casing() {
  _has_bits_[1] |= 0x00000004u;
}
inline void ServerMeta::clear_has_quoted_identifier_casing() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void ServerMeta::clear_quoted_identifier_casing() {
  quoted_identifier_casing_ = 0;
  clear_has_quoted_identifier_casing();
}
inline ::exec::user::IdentifierCasing ServerMeta::quoted_identifier_casing() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.quoted_identifier_casing)
  return static_cast< ::exec::user::IdentifierCasing >(quoted_identifier_casing_);
}
inline void ServerMeta::set_quoted_identifier_casing(::exec::user::IdentifierCasing value) {
  assert(::exec::user::IdentifierCasing_IsValid(value));
  set_has_quoted_identifier_casing();
  quoted_identifier_casing_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.quoted_identifier_casing)
}

// optional bool read_only = 38;
inline bool ServerMeta::has_read_only() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void ServerMeta::set_has_read_only() {
  _has_bits_[0] |= 0x80000000u;
}
inline void ServerMeta::clear_has_read_only() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void ServerMeta::clear_read_only() {
  read_only_ = false;
  clear_has_read_only();
}
inline bool ServerMeta::read_only() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.read_only)
  return read_only_;
}
inline void ServerMeta::set_read_only(bool value) {
  set_has_read_only();
  read_only_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.read_only)
}

// optional string schema_term = 39;
inline bool ServerMeta::has_schema_term() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerMeta::set_has_schema_term() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerMeta::clear_has_schema_term() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerMeta::clear_schema_term() {
  schema_term_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_schema_term();
}
inline const ::std::string& ServerMeta::schema_term() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.schema_term)
  return schema_term_.GetNoArena();
}
inline void ServerMeta::set_schema_term(const ::std::string& value) {
  set_has_schema_term();
  schema_term_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.schema_term)
}
#if LANG_CXX11
inline void ServerMeta::set_schema_term(::std::string&& value) {
  set_has_schema_term();
  schema_term_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ServerMeta.schema_term)
}
#endif
inline void ServerMeta::set_schema_term(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_schema_term();
  schema_term_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ServerMeta.schema_term)
}
inline void ServerMeta::set_schema_term(const char* value, size_t size) {
  set_has_schema_term();
  schema_term_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ServerMeta.schema_term)
}
inline ::std::string* ServerMeta::mutable_schema_term() {
  set_has_schema_term();
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.schema_term)
  return schema_term_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerMeta::release_schema_term() {
  // @@protoc_insertion_point(field_release:exec.user.ServerMeta.schema_term)
  if (!has_schema_term()) {
    return NULL;
  }
  clear_has_schema_term();
  return schema_term_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerMeta::set_allocated_schema_term(::std::string* schema_term) {
  if (schema_term != NULL) {
    set_has_schema_term();
  } else {
    clear_has_schema_term();
  }
  schema_term_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schema_term);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ServerMeta.schema_term)
}

// optional string search_escape_string = 40;
inline bool ServerMeta::has_search_escape_string() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerMeta::set_has_search_escape_string() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerMeta::clear_has_search_escape_string() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerMeta::clear_search_escape_string() {
  search_escape_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_search_escape_string();
}
inline const ::std::string& ServerMeta::search_escape_string() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.search_escape_string)
  return search_escape_string_.GetNoArena();
}
inline void ServerMeta::set_search_escape_string(const ::std::string& value) {
  set_has_search_escape_string();
  search_escape_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.search_escape_string)
}
#if LANG_CXX11
inline void ServerMeta::set_search_escape_string(::std::string&& value) {
  set_has_search_escape_string();
  search_escape_string_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ServerMeta.search_escape_string)
}
#endif
inline void ServerMeta::set_search_escape_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_search_escape_string();
  search_escape_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ServerMeta.search_escape_string)
}
inline void ServerMeta::set_search_escape_string(const char* value, size_t size) {
  set_has_search_escape_string();
  search_escape_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ServerMeta.search_escape_string)
}
inline ::std::string* ServerMeta::mutable_search_escape_string() {
  set_has_search_escape_string();
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.search_escape_string)
  return search_escape_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerMeta::release_search_escape_string() {
  // @@protoc_insertion_point(field_release:exec.user.ServerMeta.search_escape_string)
  if (!has_search_escape_string()) {
    return NULL;
  }
  clear_has_search_escape_string();
  return search_escape_string_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerMeta::set_allocated_search_escape_string(::std::string* search_escape_string) {
  if (search_escape_string != NULL) {
    set_has_search_escape_string();
  } else {
    clear_has_search_escape_string();
  }
  search_escape_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), search_escape_string);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ServerMeta.search_escape_string)
}

// optional bool select_for_update_supported = 41;
inline bool ServerMeta::has_select_for_update_supported() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void ServerMeta::set_has_select_for_update_supported() {
  _has_bits_[1] |= 0x00000001u;
}
inline void ServerMeta::clear_has_select_for_update_supported() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void ServerMeta::clear_select_for_update_supported() {
  select_for_update_supported_ = false;
  clear_has_select_for_update_supported();
}
inline bool ServerMeta::select_for_update_supported() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.select_for_update_supported)
  return select_for_update_supported_;
}
inline void ServerMeta::set_select_for_update_supported(bool value) {
  set_has_select_for_update_supported();
  select_for_update_supported_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.select_for_update_supported)
}

// optional string special_characters = 42;
inline bool ServerMeta::has_special_characters() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerMeta::set_has_special_characters() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServerMeta::clear_has_special_characters() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServerMeta::clear_special_characters() {
  special_characters_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_special_characters();
}
inline const ::std::string& ServerMeta::special_characters() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.special_characters)
  return special_characters_.GetNoArena();
}
inline void ServerMeta::set_special_characters(const ::std::string& value) {
  set_has_special_characters();
  special_characters_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.special_characters)
}
#if LANG_CXX11
inline void ServerMeta::set_special_characters(::std::string&& value) {
  set_has_special_characters();
  special_characters_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ServerMeta.special_characters)
}
#endif
inline void ServerMeta::set_special_characters(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_special_characters();
  special_characters_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ServerMeta.special_characters)
}
inline void ServerMeta::set_special_characters(const char* value, size_t size) {
  set_has_special_characters();
  special_characters_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ServerMeta.special_characters)
}
inline ::std::string* ServerMeta::mutable_special_characters() {
  set_has_special_characters();
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.special_characters)
  return special_characters_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerMeta::release_special_characters() {
  // @@protoc_insertion_point(field_release:exec.user.ServerMeta.special_characters)
  if (!has_special_characters()) {
    return NULL;
  }
  clear_has_special_characters();
  return special_characters_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerMeta::set_allocated_special_characters(::std::string* special_characters) {
  if (special_characters != NULL) {
    set_has_special_characters();
  } else {
    clear_has_special_characters();
  }
  special_characters_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), special_characters);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ServerMeta.special_characters)
}

// repeated string sql_keywords = 43;
inline int ServerMeta::sql_keywords_size() const {
  return sql_keywords_.size();
}
inline void ServerMeta::clear_sql_keywords() {
  sql_keywords_.Clear();
}
inline const ::std::string& ServerMeta::sql_keywords(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.sql_keywords)
  return sql_keywords_.Get(index);
}
inline ::std::string* ServerMeta::mutable_sql_keywords(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.sql_keywords)
  return sql_keywords_.Mutable(index);
}
inline void ServerMeta::set_sql_keywords(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.sql_keywords)
  sql_keywords_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ServerMeta::set_sql_keywords(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.sql_keywords)
  sql_keywords_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ServerMeta::set_sql_keywords(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  sql_keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:exec.user.ServerMeta.sql_keywords)
}
inline void ServerMeta::set_sql_keywords(int index, const char* value, size_t size) {
  sql_keywords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:exec.user.ServerMeta.sql_keywords)
}
inline ::std::string* ServerMeta::add_sql_keywords() {
  // @@protoc_insertion_point(field_add_mutable:exec.user.ServerMeta.sql_keywords)
  return sql_keywords_.Add();
}
inline void ServerMeta::add_sql_keywords(const ::std::string& value) {
  sql_keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.sql_keywords)
}
#if LANG_CXX11
inline void ServerMeta::add_sql_keywords(::std::string&& value) {
  sql_keywords_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.sql_keywords)
}
#endif
inline void ServerMeta::add_sql_keywords(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  sql_keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:exec.user.ServerMeta.sql_keywords)
}
inline void ServerMeta::add_sql_keywords(const char* value, size_t size) {
  sql_keywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:exec.user.ServerMeta.sql_keywords)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ServerMeta::sql_keywords() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.sql_keywords)
  return sql_keywords_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ServerMeta::mutable_sql_keywords() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.sql_keywords)
  return &sql_keywords_;
}

// repeated string string_functions = 44;
inline int ServerMeta::string_functions_size() const {
  return string_functions_.size();
}
inline void ServerMeta::clear_string_functions() {
  string_functions_.Clear();
}
inline const ::std::string& ServerMeta::string_functions(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.string_functions)
  return string_functions_.Get(index);
}
inline ::std::string* ServerMeta::mutable_string_functions(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.string_functions)
  return string_functions_.Mutable(index);
}
inline void ServerMeta::set_string_functions(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.string_functions)
  string_functions_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ServerMeta::set_string_functions(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.string_functions)
  string_functions_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ServerMeta::set_string_functions(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  string_functions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:exec.user.ServerMeta.string_functions)
}
inline void ServerMeta::set_string_functions(int index, const char* value, size_t size) {
  string_functions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:exec.user.ServerMeta.string_functions)
}
inline ::std::string* ServerMeta::add_string_functions() {
  // @@protoc_insertion_point(field_add_mutable:exec.user.ServerMeta.string_functions)
  return string_functions_.Add();
}
inline void ServerMeta::add_string_functions(const ::std::string& value) {
  string_functions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.string_functions)
}
#if LANG_CXX11
inline void ServerMeta::add_string_functions(::std::string&& value) {
  string_functions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.string_functions)
}
#endif
inline void ServerMeta::add_string_functions(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  string_functions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:exec.user.ServerMeta.string_functions)
}
inline void ServerMeta::add_string_functions(const char* value, size_t size) {
  string_functions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:exec.user.ServerMeta.string_functions)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ServerMeta::string_functions() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.string_functions)
  return string_functions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ServerMeta::mutable_string_functions() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.string_functions)
  return &string_functions_;
}

// repeated .exec.user.SubQuerySupport subquery_support = 45;
inline int ServerMeta::subquery_support_size() const {
  return subquery_support_.size();
}
inline void ServerMeta::clear_subquery_support() {
  subquery_support_.Clear();
}
inline ::exec::user::SubQuerySupport ServerMeta::subquery_support(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.subquery_support)
  return static_cast< ::exec::user::SubQuerySupport >(subquery_support_.Get(index));
}
inline void ServerMeta::set_subquery_support(int index, ::exec::user::SubQuerySupport value) {
  assert(::exec::user::SubQuerySupport_IsValid(value));
  subquery_support_.Set(index, value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.subquery_support)
}
inline void ServerMeta::add_subquery_support(::exec::user::SubQuerySupport value) {
  assert(::exec::user::SubQuerySupport_IsValid(value));
  subquery_support_.Add(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.subquery_support)
}
inline const ::google::protobuf::RepeatedField<int>&
ServerMeta::subquery_support() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.subquery_support)
  return subquery_support_;
}
inline ::google::protobuf::RepeatedField<int>*
ServerMeta::mutable_subquery_support() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.subquery_support)
  return &subquery_support_;
}

// repeated string system_functions = 46;
inline int ServerMeta::system_functions_size() const {
  return system_functions_.size();
}
inline void ServerMeta::clear_system_functions() {
  system_functions_.Clear();
}
inline const ::std::string& ServerMeta::system_functions(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.system_functions)
  return system_functions_.Get(index);
}
inline ::std::string* ServerMeta::mutable_system_functions(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.system_functions)
  return system_functions_.Mutable(index);
}
inline void ServerMeta::set_system_functions(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.system_functions)
  system_functions_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ServerMeta::set_system_functions(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.system_functions)
  system_functions_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ServerMeta::set_system_functions(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  system_functions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:exec.user.ServerMeta.system_functions)
}
inline void ServerMeta::set_system_functions(int index, const char* value, size_t size) {
  system_functions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:exec.user.ServerMeta.system_functions)
}
inline ::std::string* ServerMeta::add_system_functions() {
  // @@protoc_insertion_point(field_add_mutable:exec.user.ServerMeta.system_functions)
  return system_functions_.Add();
}
inline void ServerMeta::add_system_functions(const ::std::string& value) {
  system_functions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.system_functions)
}
#if LANG_CXX11
inline void ServerMeta::add_system_functions(::std::string&& value) {
  system_functions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.system_functions)
}
#endif
inline void ServerMeta::add_system_functions(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  system_functions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:exec.user.ServerMeta.system_functions)
}
inline void ServerMeta::add_system_functions(const char* value, size_t size) {
  system_functions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:exec.user.ServerMeta.system_functions)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ServerMeta::system_functions() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.system_functions)
  return system_functions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ServerMeta::mutable_system_functions() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.system_functions)
  return &system_functions_;
}

// optional string table_term = 47;
inline bool ServerMeta::has_table_term() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ServerMeta::set_has_table_term() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ServerMeta::clear_has_table_term() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ServerMeta::clear_table_term() {
  table_term_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_table_term();
}
inline const ::std::string& ServerMeta::table_term() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.table_term)
  return table_term_.GetNoArena();
}
inline void ServerMeta::set_table_term(const ::std::string& value) {
  set_has_table_term();
  table_term_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.table_term)
}
#if LANG_CXX11
inline void ServerMeta::set_table_term(::std::string&& value) {
  set_has_table_term();
  table_term_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ServerMeta.table_term)
}
#endif
inline void ServerMeta::set_table_term(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_table_term();
  table_term_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ServerMeta.table_term)
}
inline void ServerMeta::set_table_term(const char* value, size_t size) {
  set_has_table_term();
  table_term_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ServerMeta.table_term)
}
inline ::std::string* ServerMeta::mutable_table_term() {
  set_has_table_term();
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.table_term)
  return table_term_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerMeta::release_table_term() {
  // @@protoc_insertion_point(field_release:exec.user.ServerMeta.table_term)
  if (!has_table_term()) {
    return NULL;
  }
  clear_has_table_term();
  return table_term_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerMeta::set_allocated_table_term(::std::string* table_term) {
  if (table_term != NULL) {
    set_has_table_term();
  } else {
    clear_has_table_term();
  }
  table_term_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table_term);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ServerMeta.table_term)
}

// optional bool transaction_supported = 48;
inline bool ServerMeta::has_transaction_supported() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void ServerMeta::set_has_transaction_supported() {
  _has_bits_[1] |= 0x00000008u;
}
inline void ServerMeta::clear_has_transaction_supported() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void ServerMeta::clear_transaction_supported() {
  transaction_supported_ = false;
  clear_has_transaction_supported();
}
inline bool ServerMeta::transaction_supported() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.transaction_supported)
  return transaction_supported_;
}
inline void ServerMeta::set_transaction_supported(bool value) {
  set_has_transaction_supported();
  transaction_supported_ = value;
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.transaction_supported)
}

// repeated .exec.user.UnionSupport union_support = 49;
inline int ServerMeta::union_support_size() const {
  return union_support_.size();
}
inline void ServerMeta::clear_union_support() {
  union_support_.Clear();
}
inline ::exec::user::UnionSupport ServerMeta::union_support(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.union_support)
  return static_cast< ::exec::user::UnionSupport >(union_support_.Get(index));
}
inline void ServerMeta::set_union_support(int index, ::exec::user::UnionSupport value) {
  assert(::exec::user::UnionSupport_IsValid(value));
  union_support_.Set(index, value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.union_support)
}
inline void ServerMeta::add_union_support(::exec::user::UnionSupport value) {
  assert(::exec::user::UnionSupport_IsValid(value));
  union_support_.Add(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.union_support)
}
inline const ::google::protobuf::RepeatedField<int>&
ServerMeta::union_support() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.union_support)
  return union_support_;
}
inline ::google::protobuf::RepeatedField<int>*
ServerMeta::mutable_union_support() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.union_support)
  return &union_support_;
}

// optional string current_schema = 50;
inline bool ServerMeta::has_current_schema() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ServerMeta::set_has_current_schema() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ServerMeta::clear_has_current_schema() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ServerMeta::clear_current_schema() {
  current_schema_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_current_schema();
}
inline const ::std::string& ServerMeta::current_schema() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.current_schema)
  return current_schema_.GetNoArena();
}
inline void ServerMeta::set_current_schema(const ::std::string& value) {
  set_has_current_schema();
  current_schema_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.current_schema)
}
#if LANG_CXX11
inline void ServerMeta::set_current_schema(::std::string&& value) {
  set_has_current_schema();
  current_schema_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.ServerMeta.current_schema)
}
#endif
inline void ServerMeta::set_current_schema(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_current_schema();
  current_schema_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.ServerMeta.current_schema)
}
inline void ServerMeta::set_current_schema(const char* value, size_t size) {
  set_has_current_schema();
  current_schema_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.ServerMeta.current_schema)
}
inline ::std::string* ServerMeta::mutable_current_schema() {
  set_has_current_schema();
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.current_schema)
  return current_schema_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerMeta::release_current_schema() {
  // @@protoc_insertion_point(field_release:exec.user.ServerMeta.current_schema)
  if (!has_current_schema()) {
    return NULL;
  }
  clear_has_current_schema();
  return current_schema_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerMeta::set_allocated_current_schema(::std::string* current_schema) {
  if (current_schema != NULL) {
    set_has_current_schema();
  } else {
    clear_has_current_schema();
  }
  current_schema_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), current_schema);
  // @@protoc_insertion_point(field_set_allocated:exec.user.ServerMeta.current_schema)
}

// -------------------------------------------------------------------

// RunQuery

// optional .exec.user.QueryResultsMode results_mode = 1;
inline bool RunQuery::has_results_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RunQuery::set_has_results_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RunQuery::clear_has_results_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RunQuery::clear_results_mode() {
  results_mode_ = 1;
  clear_has_results_mode();
}
inline ::exec::user::QueryResultsMode RunQuery::results_mode() const {
  // @@protoc_insertion_point(field_get:exec.user.RunQuery.results_mode)
  return static_cast< ::exec::user::QueryResultsMode >(results_mode_);
}
inline void RunQuery::set_results_mode(::exec::user::QueryResultsMode value) {
  assert(::exec::user::QueryResultsMode_IsValid(value));
  set_has_results_mode();
  results_mode_ = value;
  // @@protoc_insertion_point(field_set:exec.user.RunQuery.results_mode)
}

// optional .exec.shared.QueryType type = 2;
inline bool RunQuery::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RunQuery::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RunQuery::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RunQuery::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::exec::shared::QueryType RunQuery::type() const {
  // @@protoc_insertion_point(field_get:exec.user.RunQuery.type)
  return static_cast< ::exec::shared::QueryType >(type_);
}
inline void RunQuery::set_type(::exec::shared::QueryType value) {
  assert(::exec::shared::QueryType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:exec.user.RunQuery.type)
}

// optional string plan = 3;
inline bool RunQuery::has_plan() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RunQuery::set_has_plan() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RunQuery::clear_has_plan() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RunQuery::clear_plan() {
  plan_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_plan();
}
inline const ::std::string& RunQuery::plan() const {
  // @@protoc_insertion_point(field_get:exec.user.RunQuery.plan)
  return plan_.GetNoArena();
}
inline void RunQuery::set_plan(const ::std::string& value) {
  set_has_plan();
  plan_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exec.user.RunQuery.plan)
}
#if LANG_CXX11
inline void RunQuery::set_plan(::std::string&& value) {
  set_has_plan();
  plan_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exec.user.RunQuery.plan)
}
#endif
inline void RunQuery::set_plan(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_plan();
  plan_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exec.user.RunQuery.plan)
}
inline void RunQuery::set_plan(const char* value, size_t size) {
  set_has_plan();
  plan_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exec.user.RunQuery.plan)
}
inline ::std::string* RunQuery::mutable_plan() {
  set_has_plan();
  // @@protoc_insertion_point(field_mutable:exec.user.RunQuery.plan)
  return plan_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunQuery::release_plan() {
  // @@protoc_insertion_point(field_release:exec.user.RunQuery.plan)
  if (!has_plan()) {
    return NULL;
  }
  clear_has_plan();
  return plan_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunQuery::set_allocated_plan(::std::string* plan) {
  if (plan != NULL) {
    set_has_plan();
  } else {
    clear_has_plan();
  }
  plan_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), plan);
  // @@protoc_insertion_point(field_set_allocated:exec.user.RunQuery.plan)
}

// repeated .exec.bit.control.PlanFragment fragments = 4;
inline int RunQuery::fragments_size() const {
  return fragments_.size();
}
inline ::exec::bit::control::PlanFragment* RunQuery::mutable_fragments(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.RunQuery.fragments)
  return fragments_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment >*
RunQuery::mutable_fragments() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.RunQuery.fragments)
  return &fragments_;
}
inline const ::exec::bit::control::PlanFragment& RunQuery::fragments(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.RunQuery.fragments)
  return fragments_.Get(index);
}
inline ::exec::bit::control::PlanFragment* RunQuery::add_fragments() {
  // @@protoc_insertion_point(field_add:exec.user.RunQuery.fragments)
  return fragments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::bit::control::PlanFragment >&
RunQuery::fragments() const {
  // @@protoc_insertion_point(field_list:exec.user.RunQuery.fragments)
  return fragments_;
}

// optional .exec.user.PreparedStatementHandle prepared_statement_handle = 5;
inline bool RunQuery::has_prepared_statement_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RunQuery::set_has_prepared_statement_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RunQuery::clear_has_prepared_statement_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RunQuery::clear_prepared_statement_handle() {
  if (prepared_statement_handle_ != NULL) prepared_statement_handle_->Clear();
  clear_has_prepared_statement_handle();
}
inline const ::exec::user::PreparedStatementHandle& RunQuery::_internal_prepared_statement_handle() const {
  return *prepared_statement_handle_;
}
inline const ::exec::user::PreparedStatementHandle& RunQuery::prepared_statement_handle() const {
  const ::exec::user::PreparedStatementHandle* p = prepared_statement_handle_;
  // @@protoc_insertion_point(field_get:exec.user.RunQuery.prepared_statement_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::exec::user::PreparedStatementHandle*>(
      &::exec::user::_PreparedStatementHandle_default_instance_);
}
inline ::exec::user::PreparedStatementHandle* RunQuery::release_prepared_statement_handle() {
  // @@protoc_insertion_point(field_release:exec.user.RunQuery.prepared_statement_handle)
  clear_has_prepared_statement_handle();
  ::exec::user::PreparedStatementHandle* temp = prepared_statement_handle_;
  prepared_statement_handle_ = NULL;
  return temp;
}
inline ::exec::user::PreparedStatementHandle* RunQuery::mutable_prepared_statement_handle() {
  set_has_prepared_statement_handle();
  if (prepared_statement_handle_ == NULL) {
    auto* p = CreateMaybeMessage<::exec::user::PreparedStatementHandle>(GetArenaNoVirtual());
    prepared_statement_handle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:exec.user.RunQuery.prepared_statement_handle)
  return prepared_statement_handle_;
}
inline void RunQuery::set_allocated_prepared_statement_handle(::exec::user::PreparedStatementHandle* prepared_statement_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete prepared_statement_handle_;
  }
  if (prepared_statement_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      prepared_statement_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prepared_statement_handle, submessage_arena);
    }
    set_has_prepared_statement_handle();
  } else {
    clear_has_prepared_statement_handle();
  }
  prepared_statement_handle_ = prepared_statement_handle;
  // @@protoc_insertion_point(field_set_allocated:exec.user.RunQuery.prepared_statement_handle)
}

// optional int32 autolimit_rowcount = 6;
inline bool RunQuery::has_autolimit_rowcount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RunQuery::set_has_autolimit_rowcount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RunQuery::clear_has_autolimit_rowcount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RunQuery::clear_autolimit_rowcount() {
  autolimit_rowcount_ = 0;
  clear_has_autolimit_rowcount();
}
inline ::google::protobuf::int32 RunQuery::autolimit_rowcount() const {
  // @@protoc_insertion_point(field_get:exec.user.RunQuery.autolimit_rowcount)
  return autolimit_rowcount_;
}
inline void RunQuery::set_autolimit_rowcount(::google::protobuf::int32 value) {
  set_has_autolimit_rowcount();
  autolimit_rowcount_ = value;
  // @@protoc_insertion_point(field_set:exec.user.RunQuery.autolimit_rowcount)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace user
}  // namespace exec

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::exec::user::RpcType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::RpcType>() {
  return ::exec::user::RpcType_descriptor();
}
template <> struct is_proto_enum< ::exec::user::SaslSupport> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::SaslSupport>() {
  return ::exec::user::SaslSupport_descriptor();
}
template <> struct is_proto_enum< ::exec::user::QueryResultsMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::QueryResultsMode>() {
  return ::exec::user::QueryResultsMode_descriptor();
}
template <> struct is_proto_enum< ::exec::user::HandshakeStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::HandshakeStatus>() {
  return ::exec::user::HandshakeStatus_descriptor();
}
template <> struct is_proto_enum< ::exec::user::RequestStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::RequestStatus>() {
  return ::exec::user::RequestStatus_descriptor();
}
template <> struct is_proto_enum< ::exec::user::ColumnSearchability> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::ColumnSearchability>() {
  return ::exec::user::ColumnSearchability_descriptor();
}
template <> struct is_proto_enum< ::exec::user::ColumnUpdatability> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::ColumnUpdatability>() {
  return ::exec::user::ColumnUpdatability_descriptor();
}
template <> struct is_proto_enum< ::exec::user::CollateSupport> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::CollateSupport>() {
  return ::exec::user::CollateSupport_descriptor();
}
template <> struct is_proto_enum< ::exec::user::CorrelationNamesSupport> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::CorrelationNamesSupport>() {
  return ::exec::user::CorrelationNamesSupport_descriptor();
}
template <> struct is_proto_enum< ::exec::user::DateTimeLiteralsSupport> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::DateTimeLiteralsSupport>() {
  return ::exec::user::DateTimeLiteralsSupport_descriptor();
}
template <> struct is_proto_enum< ::exec::user::GroupBySupport> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::GroupBySupport>() {
  return ::exec::user::GroupBySupport_descriptor();
}
template <> struct is_proto_enum< ::exec::user::IdentifierCasing> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::IdentifierCasing>() {
  return ::exec::user::IdentifierCasing_descriptor();
}
template <> struct is_proto_enum< ::exec::user::NullCollation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::NullCollation>() {
  return ::exec::user::NullCollation_descriptor();
}
template <> struct is_proto_enum< ::exec::user::OrderBySupport> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::OrderBySupport>() {
  return ::exec::user::OrderBySupport_descriptor();
}
template <> struct is_proto_enum< ::exec::user::OuterJoinSupport> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::OuterJoinSupport>() {
  return ::exec::user::OuterJoinSupport_descriptor();
}
template <> struct is_proto_enum< ::exec::user::SubQuerySupport> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::SubQuerySupport>() {
  return ::exec::user::SubQuerySupport_descriptor();
}
template <> struct is_proto_enum< ::exec::user::UnionSupport> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::user::UnionSupport>() {
  return ::exec::user::UnionSupport_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_User_2eproto
