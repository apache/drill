// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: UserBitShared.proto

#ifndef PROTOBUF_UserBitShared_2eproto__INCLUDED
#define PROTOBUF_UserBitShared_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Types.pb.h"
#include "Coordination.pb.h"
#include "SchemaDef.pb.h"
// @@protoc_insertion_point(includes)

namespace exec {
namespace shared {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_UserBitShared_2eproto();
void protobuf_AssignDesc_UserBitShared_2eproto();
void protobuf_ShutdownFile_UserBitShared_2eproto();

class UserCredentials;
class QueryId;
class DrillPBError;
class ExceptionWrapper;
class StackTraceElementWrapper;
class ParsingError;
class RecordBatchDef;
class NamePart;
class SerializedField;
class NodeStatus;
class QueryResult;
class QueryData;
class QueryInfo;
class QueryProfile;
class MajorFragmentProfile;
class MinorFragmentProfile;
class OperatorProfile;
class StreamProfile;
class MetricValue;

enum DrillPBError_ErrorType {
  DrillPBError_ErrorType_CONNECTION = 0,
  DrillPBError_ErrorType_DATA_READ = 1,
  DrillPBError_ErrorType_DATA_WRITE = 2,
  DrillPBError_ErrorType_FUNCTION = 3,
  DrillPBError_ErrorType_PARSE = 4,
  DrillPBError_ErrorType_PERMISSION = 5,
  DrillPBError_ErrorType_PLAN = 6,
  DrillPBError_ErrorType_RESOURCE = 7,
  DrillPBError_ErrorType_SYSTEM = 8,
  DrillPBError_ErrorType_UNSUPPORTED_OPERATION = 9,
  DrillPBError_ErrorType_VALIDATION = 10
};
bool DrillPBError_ErrorType_IsValid(int value);
const DrillPBError_ErrorType DrillPBError_ErrorType_ErrorType_MIN = DrillPBError_ErrorType_CONNECTION;
const DrillPBError_ErrorType DrillPBError_ErrorType_ErrorType_MAX = DrillPBError_ErrorType_VALIDATION;
const int DrillPBError_ErrorType_ErrorType_ARRAYSIZE = DrillPBError_ErrorType_ErrorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DrillPBError_ErrorType_descriptor();
inline const ::std::string& DrillPBError_ErrorType_Name(DrillPBError_ErrorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DrillPBError_ErrorType_descriptor(), value);
}
inline bool DrillPBError_ErrorType_Parse(
    const ::std::string& name, DrillPBError_ErrorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DrillPBError_ErrorType>(
    DrillPBError_ErrorType_descriptor(), name, value);
}
enum NamePart_Type {
  NamePart_Type_NAME = 0,
  NamePart_Type_ARRAY = 1
};
bool NamePart_Type_IsValid(int value);
const NamePart_Type NamePart_Type_Type_MIN = NamePart_Type_NAME;
const NamePart_Type NamePart_Type_Type_MAX = NamePart_Type_ARRAY;
const int NamePart_Type_Type_ARRAYSIZE = NamePart_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* NamePart_Type_descriptor();
inline const ::std::string& NamePart_Type_Name(NamePart_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    NamePart_Type_descriptor(), value);
}
inline bool NamePart_Type_Parse(
    const ::std::string& name, NamePart_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NamePart_Type>(
    NamePart_Type_descriptor(), name, value);
}
enum QueryResult_QueryState {
  QueryResult_QueryState_STARTING = 0,
  QueryResult_QueryState_RUNNING = 1,
  QueryResult_QueryState_COMPLETED = 2,
  QueryResult_QueryState_CANCELED = 3,
  QueryResult_QueryState_FAILED = 4,
  QueryResult_QueryState_CANCELLATION_REQUESTED = 5,
  QueryResult_QueryState_ENQUEUED = 6
};
bool QueryResult_QueryState_IsValid(int value);
const QueryResult_QueryState QueryResult_QueryState_QueryState_MIN = QueryResult_QueryState_STARTING;
const QueryResult_QueryState QueryResult_QueryState_QueryState_MAX = QueryResult_QueryState_ENQUEUED;
const int QueryResult_QueryState_QueryState_ARRAYSIZE = QueryResult_QueryState_QueryState_MAX + 1;

const ::google::protobuf::EnumDescriptor* QueryResult_QueryState_descriptor();
inline const ::std::string& QueryResult_QueryState_Name(QueryResult_QueryState value) {
  return ::google::protobuf::internal::NameOfEnum(
    QueryResult_QueryState_descriptor(), value);
}
inline bool QueryResult_QueryState_Parse(
    const ::std::string& name, QueryResult_QueryState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QueryResult_QueryState>(
    QueryResult_QueryState_descriptor(), name, value);
}
enum RpcChannel {
  BIT_CONTROL = 0,
  BIT_DATA = 1,
  USER = 2
};
bool RpcChannel_IsValid(int value);
const RpcChannel RpcChannel_MIN = BIT_CONTROL;
const RpcChannel RpcChannel_MAX = USER;
const int RpcChannel_ARRAYSIZE = RpcChannel_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpcChannel_descriptor();
inline const ::std::string& RpcChannel_Name(RpcChannel value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpcChannel_descriptor(), value);
}
inline bool RpcChannel_Parse(
    const ::std::string& name, RpcChannel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcChannel>(
    RpcChannel_descriptor(), name, value);
}
enum QueryType {
  SQL = 1,
  LOGICAL = 2,
  PHYSICAL = 3
};
bool QueryType_IsValid(int value);
const QueryType QueryType_MIN = SQL;
const QueryType QueryType_MAX = PHYSICAL;
const int QueryType_ARRAYSIZE = QueryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* QueryType_descriptor();
inline const ::std::string& QueryType_Name(QueryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    QueryType_descriptor(), value);
}
inline bool QueryType_Parse(
    const ::std::string& name, QueryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QueryType>(
    QueryType_descriptor(), name, value);
}
enum FragmentState {
  SENDING = 0,
  AWAITING_ALLOCATION = 1,
  RUNNING = 2,
  FINISHED = 3,
  CANCELLED = 4,
  FAILED = 5,
  CANCELLATION_REQUESTED = 6
};
bool FragmentState_IsValid(int value);
const FragmentState FragmentState_MIN = SENDING;
const FragmentState FragmentState_MAX = CANCELLATION_REQUESTED;
const int FragmentState_ARRAYSIZE = FragmentState_MAX + 1;

const ::google::protobuf::EnumDescriptor* FragmentState_descriptor();
inline const ::std::string& FragmentState_Name(FragmentState value) {
  return ::google::protobuf::internal::NameOfEnum(
    FragmentState_descriptor(), value);
}
inline bool FragmentState_Parse(
    const ::std::string& name, FragmentState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FragmentState>(
    FragmentState_descriptor(), name, value);
}
enum CoreOperatorType {
  SINGLE_SENDER = 0,
  BROADCAST_SENDER = 1,
  FILTER = 2,
  HASH_AGGREGATE = 3,
  HASH_JOIN = 4,
  MERGE_JOIN = 5,
  HASH_PARTITION_SENDER = 6,
  LIMIT = 7,
  MERGING_RECEIVER = 8,
  ORDERED_PARTITION_SENDER = 9,
  PROJECT = 10,
  UNORDERED_RECEIVER = 11,
  RANGE_SENDER = 12,
  SCREEN = 13,
  SELECTION_VECTOR_REMOVER = 14,
  STREAMING_AGGREGATE = 15,
  TOP_N_SORT = 16,
  EXTERNAL_SORT = 17,
  TRACE = 18,
  UNION = 19,
  OLD_SORT = 20,
  PARQUET_ROW_GROUP_SCAN = 21,
  HIVE_SUB_SCAN = 22,
  SYSTEM_TABLE_SCAN = 23,
  MOCK_SUB_SCAN = 24,
  PARQUET_WRITER = 25,
  DIRECT_SUB_SCAN = 26,
  TEXT_WRITER = 27,
  TEXT_SUB_SCAN = 28,
  JSON_SUB_SCAN = 29,
  INFO_SCHEMA_SUB_SCAN = 30,
  COMPLEX_TO_JSON = 31,
  PRODUCER_CONSUMER = 32,
  HBASE_SUB_SCAN = 33,
  WINDOW = 34,
  NESTED_LOOP_JOIN = 35,
  AVRO_SUB_SCAN = 36
};
bool CoreOperatorType_IsValid(int value);
const CoreOperatorType CoreOperatorType_MIN = SINGLE_SENDER;
const CoreOperatorType CoreOperatorType_MAX = AVRO_SUB_SCAN;
const int CoreOperatorType_ARRAYSIZE = CoreOperatorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CoreOperatorType_descriptor();
inline const ::std::string& CoreOperatorType_Name(CoreOperatorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CoreOperatorType_descriptor(), value);
}
inline bool CoreOperatorType_Parse(
    const ::std::string& name, CoreOperatorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CoreOperatorType>(
    CoreOperatorType_descriptor(), name, value);
}
// ===================================================================

class UserCredentials : public ::google::protobuf::Message {
 public:
  UserCredentials();
  virtual ~UserCredentials();

  UserCredentials(const UserCredentials& from);

  inline UserCredentials& operator=(const UserCredentials& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserCredentials& default_instance();

  void Swap(UserCredentials* other);

  // implements Message ----------------------------------------------

  UserCredentials* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserCredentials& from);
  void MergeFrom(const UserCredentials& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // @@protoc_insertion_point(class_scope:exec.shared.UserCredentials)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_UserBitShared_2eproto();
  friend void protobuf_AssignDesc_UserBitShared_2eproto();
  friend void protobuf_ShutdownFile_UserBitShared_2eproto();

  void InitAsDefaultInstance();
  static UserCredentials* default_instance_;
};
// -------------------------------------------------------------------

class QueryId : public ::google::protobuf::Message {
 public:
  QueryId();
  virtual ~QueryId();

  QueryId(const QueryId& from);

  inline QueryId& operator=(const QueryId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryId& default_instance();

  void Swap(QueryId* other);

  // implements Message ----------------------------------------------

  QueryId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryId& from);
  void MergeFrom(const QueryId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed64 part1 = 1;
  inline bool has_part1() const;
  inline void clear_part1();
  static const int kPart1FieldNumber = 1;
  inline ::google::protobuf::int64 part1() const;
  inline void set_part1(::google::protobuf::int64 value);

  // optional sfixed64 part2 = 2;
  inline bool has_part2() const;
  inline void clear_part2();
  static const int kPart2FieldNumber = 2;
  inline ::google::protobuf::int64 part2() const;
  inline void set_part2(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:exec.shared.QueryId)
 private:
  inline void set_has_part1();
  inline void clear_has_part1();
  inline void set_has_part2();
  inline void clear_has_part2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 part1_;
  ::google::protobuf::int64 part2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_UserBitShared_2eproto();
  friend void protobuf_AssignDesc_UserBitShared_2eproto();
  friend void protobuf_ShutdownFile_UserBitShared_2eproto();

  void InitAsDefaultInstance();
  static QueryId* default_instance_;
};
// -------------------------------------------------------------------

class DrillPBError : public ::google::protobuf::Message {
 public:
  DrillPBError();
  virtual ~DrillPBError();

  DrillPBError(const DrillPBError& from);

  inline DrillPBError& operator=(const DrillPBError& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DrillPBError& default_instance();

  void Swap(DrillPBError* other);

  // implements Message ----------------------------------------------

  DrillPBError* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DrillPBError& from);
  void MergeFrom(const DrillPBError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DrillPBError_ErrorType ErrorType;
  static const ErrorType CONNECTION = DrillPBError_ErrorType_CONNECTION;
  static const ErrorType DATA_READ = DrillPBError_ErrorType_DATA_READ;
  static const ErrorType DATA_WRITE = DrillPBError_ErrorType_DATA_WRITE;
  static const ErrorType FUNCTION = DrillPBError_ErrorType_FUNCTION;
  static const ErrorType PARSE = DrillPBError_ErrorType_PARSE;
  static const ErrorType PERMISSION = DrillPBError_ErrorType_PERMISSION;
  static const ErrorType PLAN = DrillPBError_ErrorType_PLAN;
  static const ErrorType RESOURCE = DrillPBError_ErrorType_RESOURCE;
  static const ErrorType SYSTEM = DrillPBError_ErrorType_SYSTEM;
  static const ErrorType UNSUPPORTED_OPERATION = DrillPBError_ErrorType_UNSUPPORTED_OPERATION;
  static const ErrorType VALIDATION = DrillPBError_ErrorType_VALIDATION;
  static inline bool ErrorType_IsValid(int value) {
    return DrillPBError_ErrorType_IsValid(value);
  }
  static const ErrorType ErrorType_MIN =
    DrillPBError_ErrorType_ErrorType_MIN;
  static const ErrorType ErrorType_MAX =
    DrillPBError_ErrorType_ErrorType_MAX;
  static const int ErrorType_ARRAYSIZE =
    DrillPBError_ErrorType_ErrorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorType_descriptor() {
    return DrillPBError_ErrorType_descriptor();
  }
  static inline const ::std::string& ErrorType_Name(ErrorType value) {
    return DrillPBError_ErrorType_Name(value);
  }
  static inline bool ErrorType_Parse(const ::std::string& name,
      ErrorType* value) {
    return DrillPBError_ErrorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string error_id = 1;
  inline bool has_error_id() const;
  inline void clear_error_id();
  static const int kErrorIdFieldNumber = 1;
  inline const ::std::string& error_id() const;
  inline void set_error_id(const ::std::string& value);
  inline void set_error_id(const char* value);
  inline void set_error_id(const char* value, size_t size);
  inline ::std::string* mutable_error_id();
  inline ::std::string* release_error_id();
  inline void set_allocated_error_id(::std::string* error_id);

  // optional .exec.DrillbitEndpoint endpoint = 2;
  inline bool has_endpoint() const;
  inline void clear_endpoint();
  static const int kEndpointFieldNumber = 2;
  inline const ::exec::DrillbitEndpoint& endpoint() const;
  inline ::exec::DrillbitEndpoint* mutable_endpoint();
  inline ::exec::DrillbitEndpoint* release_endpoint();
  inline void set_allocated_endpoint(::exec::DrillbitEndpoint* endpoint);

  // optional .exec.shared.DrillPBError.ErrorType error_type = 3;
  inline bool has_error_type() const;
  inline void clear_error_type();
  static const int kErrorTypeFieldNumber = 3;
  inline ::exec::shared::DrillPBError_ErrorType error_type() const;
  inline void set_error_type(::exec::shared::DrillPBError_ErrorType value);

  // optional string message = 4;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 4;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional .exec.shared.ExceptionWrapper exception = 5;
  inline bool has_exception() const;
  inline void clear_exception();
  static const int kExceptionFieldNumber = 5;
  inline const ::exec::shared::ExceptionWrapper& exception() const;
  inline ::exec::shared::ExceptionWrapper* mutable_exception();
  inline ::exec::shared::ExceptionWrapper* release_exception();
  inline void set_allocated_exception(::exec::shared::ExceptionWrapper* exception);

  // repeated .exec.shared.ParsingError parsing_error = 6;
  inline int parsing_error_size() const;
  inline void clear_parsing_error();
  static const int kParsingErrorFieldNumber = 6;
  inline const ::exec::shared::ParsingError& parsing_error(int index) const;
  inline ::exec::shared::ParsingError* mutable_parsing_error(int index);
  inline ::exec::shared::ParsingError* add_parsing_error();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::shared::ParsingError >&
      parsing_error() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::shared::ParsingError >*
      mutable_parsing_error();

  // @@protoc_insertion_point(class_scope:exec.shared.DrillPBError)
 private:
  inline void set_has_error_id();
  inline void clear_has_error_id();
  inline void set_has_endpoint();
  inline void clear_has_endpoint();
  inline void set_has_error_type();
  inline void clear_has_error_type();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_exception();
  inline void clear_has_exception();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* error_id_;
  ::exec::DrillbitEndpoint* endpoint_;
  ::std::string* message_;
  ::exec::shared::ExceptionWrapper* exception_;
  ::google::protobuf::RepeatedPtrField< ::exec::shared::ParsingError > parsing_error_;
  int error_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_UserBitShared_2eproto();
  friend void protobuf_AssignDesc_UserBitShared_2eproto();
  friend void protobuf_ShutdownFile_UserBitShared_2eproto();

  void InitAsDefaultInstance();
  static DrillPBError* default_instance_;
};
// -------------------------------------------------------------------

class ExceptionWrapper : public ::google::protobuf::Message {
 public:
  ExceptionWrapper();
  virtual ~ExceptionWrapper();

  ExceptionWrapper(const ExceptionWrapper& from);

  inline ExceptionWrapper& operator=(const ExceptionWrapper& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExceptionWrapper& default_instance();

  void Swap(ExceptionWrapper* other);

  // implements Message ----------------------------------------------

  ExceptionWrapper* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExceptionWrapper& from);
  void MergeFrom(const ExceptionWrapper& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string exception_class = 1;
  inline bool has_exception_class() const;
  inline void clear_exception_class();
  static const int kExceptionClassFieldNumber = 1;
  inline const ::std::string& exception_class() const;
  inline void set_exception_class(const ::std::string& value);
  inline void set_exception_class(const char* value);
  inline void set_exception_class(const char* value, size_t size);
  inline ::std::string* mutable_exception_class();
  inline ::std::string* release_exception_class();
  inline void set_allocated_exception_class(::std::string* exception_class);

  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // repeated .exec.shared.StackTraceElementWrapper stack_trace = 3;
  inline int stack_trace_size() const;
  inline void clear_stack_trace();
  static const int kStackTraceFieldNumber = 3;
  inline const ::exec::shared::StackTraceElementWrapper& stack_trace(int index) const;
  inline ::exec::shared::StackTraceElementWrapper* mutable_stack_trace(int index);
  inline ::exec::shared::StackTraceElementWrapper* add_stack_trace();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::shared::StackTraceElementWrapper >&
      stack_trace() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::shared::StackTraceElementWrapper >*
      mutable_stack_trace();

  // optional .exec.shared.ExceptionWrapper cause = 4;
  inline bool has_cause() const;
  inline void clear_cause();
  static const int kCauseFieldNumber = 4;
  inline const ::exec::shared::ExceptionWrapper& cause() const;
  inline ::exec::shared::ExceptionWrapper* mutable_cause();
  inline ::exec::shared::ExceptionWrapper* release_cause();
  inline void set_allocated_cause(::exec::shared::ExceptionWrapper* cause);

  // @@protoc_insertion_point(class_scope:exec.shared.ExceptionWrapper)
 private:
  inline void set_has_exception_class();
  inline void clear_has_exception_class();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_cause();
  inline void clear_has_cause();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* exception_class_;
  ::std::string* message_;
  ::google::protobuf::RepeatedPtrField< ::exec::shared::StackTraceElementWrapper > stack_trace_;
  ::exec::shared::ExceptionWrapper* cause_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_UserBitShared_2eproto();
  friend void protobuf_AssignDesc_UserBitShared_2eproto();
  friend void protobuf_ShutdownFile_UserBitShared_2eproto();

  void InitAsDefaultInstance();
  static ExceptionWrapper* default_instance_;
};
// -------------------------------------------------------------------

class StackTraceElementWrapper : public ::google::protobuf::Message {
 public:
  StackTraceElementWrapper();
  virtual ~StackTraceElementWrapper();

  StackTraceElementWrapper(const StackTraceElementWrapper& from);

  inline StackTraceElementWrapper& operator=(const StackTraceElementWrapper& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StackTraceElementWrapper& default_instance();

  void Swap(StackTraceElementWrapper* other);

  // implements Message ----------------------------------------------

  StackTraceElementWrapper* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StackTraceElementWrapper& from);
  void MergeFrom(const StackTraceElementWrapper& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string class_name = 1;
  inline bool has_class_name() const;
  inline void clear_class_name();
  static const int kClassNameFieldNumber = 1;
  inline const ::std::string& class_name() const;
  inline void set_class_name(const ::std::string& value);
  inline void set_class_name(const char* value);
  inline void set_class_name(const char* value, size_t size);
  inline ::std::string* mutable_class_name();
  inline ::std::string* release_class_name();
  inline void set_allocated_class_name(::std::string* class_name);

  // optional string file_name = 2;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional int32 line_number = 3;
  inline bool has_line_number() const;
  inline void clear_line_number();
  static const int kLineNumberFieldNumber = 3;
  inline ::google::protobuf::int32 line_number() const;
  inline void set_line_number(::google::protobuf::int32 value);

  // optional string method_name = 4;
  inline bool has_method_name() const;
  inline void clear_method_name();
  static const int kMethodNameFieldNumber = 4;
  inline const ::std::string& method_name() const;
  inline void set_method_name(const ::std::string& value);
  inline void set_method_name(const char* value);
  inline void set_method_name(const char* value, size_t size);
  inline ::std::string* mutable_method_name();
  inline ::std::string* release_method_name();
  inline void set_allocated_method_name(::std::string* method_name);

  // optional bool is_native_method = 5;
  inline bool has_is_native_method() const;
  inline void clear_is_native_method();
  static const int kIsNativeMethodFieldNumber = 5;
  inline bool is_native_method() const;
  inline void set_is_native_method(bool value);

  // @@protoc_insertion_point(class_scope:exec.shared.StackTraceElementWrapper)
 private:
  inline void set_has_class_name();
  inline void clear_has_class_name();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_line_number();
  inline void clear_has_line_number();
  inline void set_has_method_name();
  inline void clear_has_method_name();
  inline void set_has_is_native_method();
  inline void clear_has_is_native_method();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* class_name_;
  ::std::string* file_name_;
  ::std::string* method_name_;
  ::google::protobuf::int32 line_number_;
  bool is_native_method_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_UserBitShared_2eproto();
  friend void protobuf_AssignDesc_UserBitShared_2eproto();
  friend void protobuf_ShutdownFile_UserBitShared_2eproto();

  void InitAsDefaultInstance();
  static StackTraceElementWrapper* default_instance_;
};
// -------------------------------------------------------------------

class ParsingError : public ::google::protobuf::Message {
 public:
  ParsingError();
  virtual ~ParsingError();

  ParsingError(const ParsingError& from);

  inline ParsingError& operator=(const ParsingError& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParsingError& default_instance();

  void Swap(ParsingError* other);

  // implements Message ----------------------------------------------

  ParsingError* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParsingError& from);
  void MergeFrom(const ParsingError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 start_column = 2;
  inline bool has_start_column() const;
  inline void clear_start_column();
  static const int kStartColumnFieldNumber = 2;
  inline ::google::protobuf::int32 start_column() const;
  inline void set_start_column(::google::protobuf::int32 value);

  // optional int32 start_row = 3;
  inline bool has_start_row() const;
  inline void clear_start_row();
  static const int kStartRowFieldNumber = 3;
  inline ::google::protobuf::int32 start_row() const;
  inline void set_start_row(::google::protobuf::int32 value);

  // optional int32 end_column = 4;
  inline bool has_end_column() const;
  inline void clear_end_column();
  static const int kEndColumnFieldNumber = 4;
  inline ::google::protobuf::int32 end_column() const;
  inline void set_end_column(::google::protobuf::int32 value);

  // optional int32 end_row = 5;
  inline bool has_end_row() const;
  inline void clear_end_row();
  static const int kEndRowFieldNumber = 5;
  inline ::google::protobuf::int32 end_row() const;
  inline void set_end_row(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:exec.shared.ParsingError)
 private:
  inline void set_has_start_column();
  inline void clear_has_start_column();
  inline void set_has_start_row();
  inline void clear_has_start_row();
  inline void set_has_end_column();
  inline void clear_has_end_column();
  inline void set_has_end_row();
  inline void clear_has_end_row();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 start_column_;
  ::google::protobuf::int32 start_row_;
  ::google::protobuf::int32 end_column_;
  ::google::protobuf::int32 end_row_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_UserBitShared_2eproto();
  friend void protobuf_AssignDesc_UserBitShared_2eproto();
  friend void protobuf_ShutdownFile_UserBitShared_2eproto();

  void InitAsDefaultInstance();
  static ParsingError* default_instance_;
};
// -------------------------------------------------------------------

class RecordBatchDef : public ::google::protobuf::Message {
 public:
  RecordBatchDef();
  virtual ~RecordBatchDef();

  RecordBatchDef(const RecordBatchDef& from);

  inline RecordBatchDef& operator=(const RecordBatchDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordBatchDef& default_instance();

  void Swap(RecordBatchDef* other);

  // implements Message ----------------------------------------------

  RecordBatchDef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecordBatchDef& from);
  void MergeFrom(const RecordBatchDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 record_count = 1;
  inline bool has_record_count() const;
  inline void clear_record_count();
  static const int kRecordCountFieldNumber = 1;
  inline ::google::protobuf::int32 record_count() const;
  inline void set_record_count(::google::protobuf::int32 value);

  // repeated .exec.shared.SerializedField field = 2;
  inline int field_size() const;
  inline void clear_field();
  static const int kFieldFieldNumber = 2;
  inline const ::exec::shared::SerializedField& field(int index) const;
  inline ::exec::shared::SerializedField* mutable_field(int index);
  inline ::exec::shared::SerializedField* add_field();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::shared::SerializedField >&
      field() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::shared::SerializedField >*
      mutable_field();

  // optional bool carries_two_byte_selection_vector = 3;
  inline bool has_carries_two_byte_selection_vector() const;
  inline void clear_carries_two_byte_selection_vector();
  static const int kCarriesTwoByteSelectionVectorFieldNumber = 3;
  inline bool carries_two_byte_selection_vector() const;
  inline void set_carries_two_byte_selection_vector(bool value);

  // @@protoc_insertion_point(class_scope:exec.shared.RecordBatchDef)
 private:
  inline void set_has_record_count();
  inline void clear_has_record_count();
  inline void set_has_carries_two_byte_selection_vector();
  inline void clear_has_carries_two_byte_selection_vector();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::exec::shared::SerializedField > field_;
  ::google::protobuf::int32 record_count_;
  bool carries_two_byte_selection_vector_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_UserBitShared_2eproto();
  friend void protobuf_AssignDesc_UserBitShared_2eproto();
  friend void protobuf_ShutdownFile_UserBitShared_2eproto();

  void InitAsDefaultInstance();
  static RecordBatchDef* default_instance_;
};
// -------------------------------------------------------------------

class NamePart : public ::google::protobuf::Message {
 public:
  NamePart();
  virtual ~NamePart();

  NamePart(const NamePart& from);

  inline NamePart& operator=(const NamePart& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NamePart& default_instance();

  void Swap(NamePart* other);

  // implements Message ----------------------------------------------

  NamePart* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NamePart& from);
  void MergeFrom(const NamePart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NamePart_Type Type;
  static const Type NAME = NamePart_Type_NAME;
  static const Type ARRAY = NamePart_Type_ARRAY;
  static inline bool Type_IsValid(int value) {
    return NamePart_Type_IsValid(value);
  }
  static const Type Type_MIN =
    NamePart_Type_Type_MIN;
  static const Type Type_MAX =
    NamePart_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    NamePart_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return NamePart_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return NamePart_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return NamePart_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .exec.shared.NamePart.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::exec::shared::NamePart_Type type() const;
  inline void set_type(::exec::shared::NamePart_Type value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .exec.shared.NamePart child = 3;
  inline bool has_child() const;
  inline void clear_child();
  static const int kChildFieldNumber = 3;
  inline const ::exec::shared::NamePart& child() const;
  inline ::exec::shared::NamePart* mutable_child();
  inline ::exec::shared::NamePart* release_child();
  inline void set_allocated_child(::exec::shared::NamePart* child);

  // @@protoc_insertion_point(class_scope:exec.shared.NamePart)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_child();
  inline void clear_has_child();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::exec::shared::NamePart* child_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_UserBitShared_2eproto();
  friend void protobuf_AssignDesc_UserBitShared_2eproto();
  friend void protobuf_ShutdownFile_UserBitShared_2eproto();

  void InitAsDefaultInstance();
  static NamePart* default_instance_;
};
// -------------------------------------------------------------------

class SerializedField : public ::google::protobuf::Message {
 public:
  SerializedField();
  virtual ~SerializedField();

  SerializedField(const SerializedField& from);

  inline SerializedField& operator=(const SerializedField& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SerializedField& default_instance();

  void Swap(SerializedField* other);

  // implements Message ----------------------------------------------

  SerializedField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SerializedField& from);
  void MergeFrom(const SerializedField& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.MajorType major_type = 1;
  inline bool has_major_type() const;
  inline void clear_major_type();
  static const int kMajorTypeFieldNumber = 1;
  inline const ::common::MajorType& major_type() const;
  inline ::common::MajorType* mutable_major_type();
  inline ::common::MajorType* release_major_type();
  inline void set_allocated_major_type(::common::MajorType* major_type);

  // optional .exec.shared.NamePart name_part = 2;
  inline bool has_name_part() const;
  inline void clear_name_part();
  static const int kNamePartFieldNumber = 2;
  inline const ::exec::shared::NamePart& name_part() const;
  inline ::exec::shared::NamePart* mutable_name_part();
  inline ::exec::shared::NamePart* release_name_part();
  inline void set_allocated_name_part(::exec::shared::NamePart* name_part);

  // repeated .exec.shared.SerializedField child = 3;
  inline int child_size() const;
  inline void clear_child();
  static const int kChildFieldNumber = 3;
  inline const ::exec::shared::SerializedField& child(int index) const;
  inline ::exec::shared::SerializedField* mutable_child(int index);
  inline ::exec::shared::SerializedField* add_child();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::shared::SerializedField >&
      child() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::shared::SerializedField >*
      mutable_child();

  // optional int32 value_count = 4;
  inline bool has_value_count() const;
  inline void clear_value_count();
  static const int kValueCountFieldNumber = 4;
  inline ::google::protobuf::int32 value_count() const;
  inline void set_value_count(::google::protobuf::int32 value);

  // optional int32 var_byte_length = 5;
  inline bool has_var_byte_length() const;
  inline void clear_var_byte_length();
  static const int kVarByteLengthFieldNumber = 5;
  inline ::google::protobuf::int32 var_byte_length() const;
  inline void set_var_byte_length(::google::protobuf::int32 value);

  // optional int32 buffer_length = 7;
  inline bool has_buffer_length() const;
  inline void clear_buffer_length();
  static const int kBufferLengthFieldNumber = 7;
  inline ::google::protobuf::int32 buffer_length() const;
  inline void set_buffer_length(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:exec.shared.SerializedField)
 private:
  inline void set_has_major_type();
  inline void clear_has_major_type();
  inline void set_has_name_part();
  inline void clear_has_name_part();
  inline void set_has_value_count();
  inline void clear_has_value_count();
  inline void set_has_var_byte_length();
  inline void clear_has_var_byte_length();
  inline void set_has_buffer_length();
  inline void clear_has_buffer_length();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::common::MajorType* major_type_;
  ::exec::shared::NamePart* name_part_;
  ::google::protobuf::RepeatedPtrField< ::exec::shared::SerializedField > child_;
  ::google::protobuf::int32 value_count_;
  ::google::protobuf::int32 var_byte_length_;
  ::google::protobuf::int32 buffer_length_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_UserBitShared_2eproto();
  friend void protobuf_AssignDesc_UserBitShared_2eproto();
  friend void protobuf_ShutdownFile_UserBitShared_2eproto();

  void InitAsDefaultInstance();
  static SerializedField* default_instance_;
};
// -------------------------------------------------------------------

class NodeStatus : public ::google::protobuf::Message {
 public:
  NodeStatus();
  virtual ~NodeStatus();

  NodeStatus(const NodeStatus& from);

  inline NodeStatus& operator=(const NodeStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeStatus& default_instance();

  void Swap(NodeStatus* other);

  // implements Message ----------------------------------------------

  NodeStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeStatus& from);
  void MergeFrom(const NodeStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline ::google::protobuf::int32 node_id() const;
  inline void set_node_id(::google::protobuf::int32 value);

  // optional int64 memory_footprint = 2;
  inline bool has_memory_footprint() const;
  inline void clear_memory_footprint();
  static const int kMemoryFootprintFieldNumber = 2;
  inline ::google::protobuf::int64 memory_footprint() const;
  inline void set_memory_footprint(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:exec.shared.NodeStatus)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_memory_footprint();
  inline void clear_has_memory_footprint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 memory_footprint_;
  ::google::protobuf::int32 node_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_UserBitShared_2eproto();
  friend void protobuf_AssignDesc_UserBitShared_2eproto();
  friend void protobuf_ShutdownFile_UserBitShared_2eproto();

  void InitAsDefaultInstance();
  static NodeStatus* default_instance_;
};
// -------------------------------------------------------------------

class QueryResult : public ::google::protobuf::Message {
 public:
  QueryResult();
  virtual ~QueryResult();

  QueryResult(const QueryResult& from);

  inline QueryResult& operator=(const QueryResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryResult& default_instance();

  void Swap(QueryResult* other);

  // implements Message ----------------------------------------------

  QueryResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryResult& from);
  void MergeFrom(const QueryResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef QueryResult_QueryState QueryState;
  static const QueryState STARTING = QueryResult_QueryState_STARTING;
  static const QueryState RUNNING = QueryResult_QueryState_RUNNING;
  static const QueryState COMPLETED = QueryResult_QueryState_COMPLETED;
  static const QueryState CANCELED = QueryResult_QueryState_CANCELED;
  static const QueryState FAILED = QueryResult_QueryState_FAILED;
  static const QueryState CANCELLATION_REQUESTED = QueryResult_QueryState_CANCELLATION_REQUESTED;
  static const QueryState ENQUEUED = QueryResult_QueryState_ENQUEUED;
  static inline bool QueryState_IsValid(int value) {
    return QueryResult_QueryState_IsValid(value);
  }
  static const QueryState QueryState_MIN =
    QueryResult_QueryState_QueryState_MIN;
  static const QueryState QueryState_MAX =
    QueryResult_QueryState_QueryState_MAX;
  static const int QueryState_ARRAYSIZE =
    QueryResult_QueryState_QueryState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  QueryState_descriptor() {
    return QueryResult_QueryState_descriptor();
  }
  static inline const ::std::string& QueryState_Name(QueryState value) {
    return QueryResult_QueryState_Name(value);
  }
  static inline bool QueryState_Parse(const ::std::string& name,
      QueryState* value) {
    return QueryResult_QueryState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .exec.shared.QueryResult.QueryState query_state = 1;
  inline bool has_query_state() const;
  inline void clear_query_state();
  static const int kQueryStateFieldNumber = 1;
  inline ::exec::shared::QueryResult_QueryState query_state() const;
  inline void set_query_state(::exec::shared::QueryResult_QueryState value);

  // optional .exec.shared.QueryId query_id = 2;
  inline bool has_query_id() const;
  inline void clear_query_id();
  static const int kQueryIdFieldNumber = 2;
  inline const ::exec::shared::QueryId& query_id() const;
  inline ::exec::shared::QueryId* mutable_query_id();
  inline ::exec::shared::QueryId* release_query_id();
  inline void set_allocated_query_id(::exec::shared::QueryId* query_id);

  // repeated .exec.shared.DrillPBError error = 3;
  inline int error_size() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::exec::shared::DrillPBError& error(int index) const;
  inline ::exec::shared::DrillPBError* mutable_error(int index);
  inline ::exec::shared::DrillPBError* add_error();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::shared::DrillPBError >&
      error() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::shared::DrillPBError >*
      mutable_error();

  // @@protoc_insertion_point(class_scope:exec.shared.QueryResult)
 private:
  inline void set_has_query_state();
  inline void clear_has_query_state();
  inline void set_has_query_id();
  inline void clear_has_query_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::exec::shared::QueryId* query_id_;
  ::google::protobuf::RepeatedPtrField< ::exec::shared::DrillPBError > error_;
  int query_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_UserBitShared_2eproto();
  friend void protobuf_AssignDesc_UserBitShared_2eproto();
  friend void protobuf_ShutdownFile_UserBitShared_2eproto();

  void InitAsDefaultInstance();
  static QueryResult* default_instance_;
};
// -------------------------------------------------------------------

class QueryData : public ::google::protobuf::Message {
 public:
  QueryData();
  virtual ~QueryData();

  QueryData(const QueryData& from);

  inline QueryData& operator=(const QueryData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryData& default_instance();

  void Swap(QueryData* other);

  // implements Message ----------------------------------------------

  QueryData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryData& from);
  void MergeFrom(const QueryData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.shared.QueryId query_id = 1;
  inline bool has_query_id() const;
  inline void clear_query_id();
  static const int kQueryIdFieldNumber = 1;
  inline const ::exec::shared::QueryId& query_id() const;
  inline ::exec::shared::QueryId* mutable_query_id();
  inline ::exec::shared::QueryId* release_query_id();
  inline void set_allocated_query_id(::exec::shared::QueryId* query_id);

  // optional int32 row_count = 2;
  inline bool has_row_count() const;
  inline void clear_row_count();
  static const int kRowCountFieldNumber = 2;
  inline ::google::protobuf::int32 row_count() const;
  inline void set_row_count(::google::protobuf::int32 value);

  // optional .exec.shared.RecordBatchDef def = 3;
  inline bool has_def() const;
  inline void clear_def();
  static const int kDefFieldNumber = 3;
  inline const ::exec::shared::RecordBatchDef& def() const;
  inline ::exec::shared::RecordBatchDef* mutable_def();
  inline ::exec::shared::RecordBatchDef* release_def();
  inline void set_allocated_def(::exec::shared::RecordBatchDef* def);

  // @@protoc_insertion_point(class_scope:exec.shared.QueryData)
 private:
  inline void set_has_query_id();
  inline void clear_has_query_id();
  inline void set_has_row_count();
  inline void clear_has_row_count();
  inline void set_has_def();
  inline void clear_has_def();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::exec::shared::QueryId* query_id_;
  ::exec::shared::RecordBatchDef* def_;
  ::google::protobuf::int32 row_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_UserBitShared_2eproto();
  friend void protobuf_AssignDesc_UserBitShared_2eproto();
  friend void protobuf_ShutdownFile_UserBitShared_2eproto();

  void InitAsDefaultInstance();
  static QueryData* default_instance_;
};
// -------------------------------------------------------------------

class QueryInfo : public ::google::protobuf::Message {
 public:
  QueryInfo();
  virtual ~QueryInfo();

  QueryInfo(const QueryInfo& from);

  inline QueryInfo& operator=(const QueryInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryInfo& default_instance();

  void Swap(QueryInfo* other);

  // implements Message ----------------------------------------------

  QueryInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryInfo& from);
  void MergeFrom(const QueryInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string query = 1;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 1;
  inline const ::std::string& query() const;
  inline void set_query(const ::std::string& value);
  inline void set_query(const char* value);
  inline void set_query(const char* value, size_t size);
  inline ::std::string* mutable_query();
  inline ::std::string* release_query();
  inline void set_allocated_query(::std::string* query);

  // optional int64 start = 2;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 2;
  inline ::google::protobuf::int64 start() const;
  inline void set_start(::google::protobuf::int64 value);

  // optional .exec.shared.QueryResult.QueryState state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline ::exec::shared::QueryResult_QueryState state() const;
  inline void set_state(::exec::shared::QueryResult_QueryState value);

  // optional string user = 4 [default = "-"];
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 4;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // optional .exec.DrillbitEndpoint foreman = 5;
  inline bool has_foreman() const;
  inline void clear_foreman();
  static const int kForemanFieldNumber = 5;
  inline const ::exec::DrillbitEndpoint& foreman() const;
  inline ::exec::DrillbitEndpoint* mutable_foreman();
  inline ::exec::DrillbitEndpoint* release_foreman();
  inline void set_allocated_foreman(::exec::DrillbitEndpoint* foreman);

  // @@protoc_insertion_point(class_scope:exec.shared.QueryInfo)
 private:
  inline void set_has_query();
  inline void clear_has_query();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_foreman();
  inline void clear_has_foreman();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* query_;
  ::google::protobuf::int64 start_;
  ::std::string* user_;
  static ::std::string* _default_user_;
  ::exec::DrillbitEndpoint* foreman_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_UserBitShared_2eproto();
  friend void protobuf_AssignDesc_UserBitShared_2eproto();
  friend void protobuf_ShutdownFile_UserBitShared_2eproto();

  void InitAsDefaultInstance();
  static QueryInfo* default_instance_;
};
// -------------------------------------------------------------------

class QueryProfile : public ::google::protobuf::Message {
 public:
  QueryProfile();
  virtual ~QueryProfile();

  QueryProfile(const QueryProfile& from);

  inline QueryProfile& operator=(const QueryProfile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryProfile& default_instance();

  void Swap(QueryProfile* other);

  // implements Message ----------------------------------------------

  QueryProfile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryProfile& from);
  void MergeFrom(const QueryProfile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.shared.QueryId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::exec::shared::QueryId& id() const;
  inline ::exec::shared::QueryId* mutable_id();
  inline ::exec::shared::QueryId* release_id();
  inline void set_allocated_id(::exec::shared::QueryId* id);

  // optional .exec.shared.QueryType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::exec::shared::QueryType type() const;
  inline void set_type(::exec::shared::QueryType value);

  // optional int64 start = 3;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 3;
  inline ::google::protobuf::int64 start() const;
  inline void set_start(::google::protobuf::int64 value);

  // optional int64 end = 4;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 4;
  inline ::google::protobuf::int64 end() const;
  inline void set_end(::google::protobuf::int64 value);

  // optional string query = 5;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 5;
  inline const ::std::string& query() const;
  inline void set_query(const ::std::string& value);
  inline void set_query(const char* value);
  inline void set_query(const char* value, size_t size);
  inline ::std::string* mutable_query();
  inline ::std::string* release_query();
  inline void set_allocated_query(::std::string* query);

  // optional string plan = 6;
  inline bool has_plan() const;
  inline void clear_plan();
  static const int kPlanFieldNumber = 6;
  inline const ::std::string& plan() const;
  inline void set_plan(const ::std::string& value);
  inline void set_plan(const char* value);
  inline void set_plan(const char* value, size_t size);
  inline ::std::string* mutable_plan();
  inline ::std::string* release_plan();
  inline void set_allocated_plan(::std::string* plan);

  // optional .exec.DrillbitEndpoint foreman = 7;
  inline bool has_foreman() const;
  inline void clear_foreman();
  static const int kForemanFieldNumber = 7;
  inline const ::exec::DrillbitEndpoint& foreman() const;
  inline ::exec::DrillbitEndpoint* mutable_foreman();
  inline ::exec::DrillbitEndpoint* release_foreman();
  inline void set_allocated_foreman(::exec::DrillbitEndpoint* foreman);

  // optional .exec.shared.QueryResult.QueryState state = 8;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 8;
  inline ::exec::shared::QueryResult_QueryState state() const;
  inline void set_state(::exec::shared::QueryResult_QueryState value);

  // optional int32 total_fragments = 9;
  inline bool has_total_fragments() const;
  inline void clear_total_fragments();
  static const int kTotalFragmentsFieldNumber = 9;
  inline ::google::protobuf::int32 total_fragments() const;
  inline void set_total_fragments(::google::protobuf::int32 value);

  // optional int32 finished_fragments = 10;
  inline bool has_finished_fragments() const;
  inline void clear_finished_fragments();
  static const int kFinishedFragmentsFieldNumber = 10;
  inline ::google::protobuf::int32 finished_fragments() const;
  inline void set_finished_fragments(::google::protobuf::int32 value);

  // repeated .exec.shared.MajorFragmentProfile fragment_profile = 11;
  inline int fragment_profile_size() const;
  inline void clear_fragment_profile();
  static const int kFragmentProfileFieldNumber = 11;
  inline const ::exec::shared::MajorFragmentProfile& fragment_profile(int index) const;
  inline ::exec::shared::MajorFragmentProfile* mutable_fragment_profile(int index);
  inline ::exec::shared::MajorFragmentProfile* add_fragment_profile();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::shared::MajorFragmentProfile >&
      fragment_profile() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::shared::MajorFragmentProfile >*
      mutable_fragment_profile();

  // optional string user = 12 [default = "-"];
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 12;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // optional string error = 13;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 13;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // optional string verboseError = 14;
  inline bool has_verboseerror() const;
  inline void clear_verboseerror();
  static const int kVerboseErrorFieldNumber = 14;
  inline const ::std::string& verboseerror() const;
  inline void set_verboseerror(const ::std::string& value);
  inline void set_verboseerror(const char* value);
  inline void set_verboseerror(const char* value, size_t size);
  inline ::std::string* mutable_verboseerror();
  inline ::std::string* release_verboseerror();
  inline void set_allocated_verboseerror(::std::string* verboseerror);

  // optional string error_id = 15;
  inline bool has_error_id() const;
  inline void clear_error_id();
  static const int kErrorIdFieldNumber = 15;
  inline const ::std::string& error_id() const;
  inline void set_error_id(const ::std::string& value);
  inline void set_error_id(const char* value);
  inline void set_error_id(const char* value, size_t size);
  inline ::std::string* mutable_error_id();
  inline ::std::string* release_error_id();
  inline void set_allocated_error_id(::std::string* error_id);

  // optional string error_node = 16;
  inline bool has_error_node() const;
  inline void clear_error_node();
  static const int kErrorNodeFieldNumber = 16;
  inline const ::std::string& error_node() const;
  inline void set_error_node(const ::std::string& value);
  inline void set_error_node(const char* value);
  inline void set_error_node(const char* value, size_t size);
  inline ::std::string* mutable_error_node();
  inline ::std::string* release_error_node();
  inline void set_allocated_error_node(::std::string* error_node);

  // @@protoc_insertion_point(class_scope:exec.shared.QueryProfile)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_query();
  inline void clear_has_query();
  inline void set_has_plan();
  inline void clear_has_plan();
  inline void set_has_foreman();
  inline void clear_has_foreman();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_total_fragments();
  inline void clear_has_total_fragments();
  inline void set_has_finished_fragments();
  inline void clear_has_finished_fragments();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_verboseerror();
  inline void clear_has_verboseerror();
  inline void set_has_error_id();
  inline void clear_has_error_id();
  inline void set_has_error_node();
  inline void clear_has_error_node();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::exec::shared::QueryId* id_;
  ::google::protobuf::int64 start_;
  ::google::protobuf::int64 end_;
  ::std::string* query_;
  int type_;
  int state_;
  ::std::string* plan_;
  ::exec::DrillbitEndpoint* foreman_;
  ::google::protobuf::int32 total_fragments_;
  ::google::protobuf::int32 finished_fragments_;
  ::google::protobuf::RepeatedPtrField< ::exec::shared::MajorFragmentProfile > fragment_profile_;
  ::std::string* user_;
  static ::std::string* _default_user_;
  ::std::string* error_;
  ::std::string* verboseerror_;
  ::std::string* error_id_;
  ::std::string* error_node_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_UserBitShared_2eproto();
  friend void protobuf_AssignDesc_UserBitShared_2eproto();
  friend void protobuf_ShutdownFile_UserBitShared_2eproto();

  void InitAsDefaultInstance();
  static QueryProfile* default_instance_;
};
// -------------------------------------------------------------------

class MajorFragmentProfile : public ::google::protobuf::Message {
 public:
  MajorFragmentProfile();
  virtual ~MajorFragmentProfile();

  MajorFragmentProfile(const MajorFragmentProfile& from);

  inline MajorFragmentProfile& operator=(const MajorFragmentProfile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MajorFragmentProfile& default_instance();

  void Swap(MajorFragmentProfile* other);

  // implements Message ----------------------------------------------

  MajorFragmentProfile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MajorFragmentProfile& from);
  void MergeFrom(const MajorFragmentProfile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 major_fragment_id = 1;
  inline bool has_major_fragment_id() const;
  inline void clear_major_fragment_id();
  static const int kMajorFragmentIdFieldNumber = 1;
  inline ::google::protobuf::int32 major_fragment_id() const;
  inline void set_major_fragment_id(::google::protobuf::int32 value);

  // repeated .exec.shared.MinorFragmentProfile minor_fragment_profile = 2;
  inline int minor_fragment_profile_size() const;
  inline void clear_minor_fragment_profile();
  static const int kMinorFragmentProfileFieldNumber = 2;
  inline const ::exec::shared::MinorFragmentProfile& minor_fragment_profile(int index) const;
  inline ::exec::shared::MinorFragmentProfile* mutable_minor_fragment_profile(int index);
  inline ::exec::shared::MinorFragmentProfile* add_minor_fragment_profile();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::shared::MinorFragmentProfile >&
      minor_fragment_profile() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::shared::MinorFragmentProfile >*
      mutable_minor_fragment_profile();

  // @@protoc_insertion_point(class_scope:exec.shared.MajorFragmentProfile)
 private:
  inline void set_has_major_fragment_id();
  inline void clear_has_major_fragment_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::exec::shared::MinorFragmentProfile > minor_fragment_profile_;
  ::google::protobuf::int32 major_fragment_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_UserBitShared_2eproto();
  friend void protobuf_AssignDesc_UserBitShared_2eproto();
  friend void protobuf_ShutdownFile_UserBitShared_2eproto();

  void InitAsDefaultInstance();
  static MajorFragmentProfile* default_instance_;
};
// -------------------------------------------------------------------

class MinorFragmentProfile : public ::google::protobuf::Message {
 public:
  MinorFragmentProfile();
  virtual ~MinorFragmentProfile();

  MinorFragmentProfile(const MinorFragmentProfile& from);

  inline MinorFragmentProfile& operator=(const MinorFragmentProfile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MinorFragmentProfile& default_instance();

  void Swap(MinorFragmentProfile* other);

  // implements Message ----------------------------------------------

  MinorFragmentProfile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MinorFragmentProfile& from);
  void MergeFrom(const MinorFragmentProfile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .exec.shared.FragmentState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::exec::shared::FragmentState state() const;
  inline void set_state(::exec::shared::FragmentState value);

  // optional .exec.shared.DrillPBError error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::exec::shared::DrillPBError& error() const;
  inline ::exec::shared::DrillPBError* mutable_error();
  inline ::exec::shared::DrillPBError* release_error();
  inline void set_allocated_error(::exec::shared::DrillPBError* error);

  // optional int32 minor_fragment_id = 3;
  inline bool has_minor_fragment_id() const;
  inline void clear_minor_fragment_id();
  static const int kMinorFragmentIdFieldNumber = 3;
  inline ::google::protobuf::int32 minor_fragment_id() const;
  inline void set_minor_fragment_id(::google::protobuf::int32 value);

  // repeated .exec.shared.OperatorProfile operator_profile = 4;
  inline int operator_profile_size() const;
  inline void clear_operator_profile();
  static const int kOperatorProfileFieldNumber = 4;
  inline const ::exec::shared::OperatorProfile& operator_profile(int index) const;
  inline ::exec::shared::OperatorProfile* mutable_operator_profile(int index);
  inline ::exec::shared::OperatorProfile* add_operator_profile();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::shared::OperatorProfile >&
      operator_profile() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::shared::OperatorProfile >*
      mutable_operator_profile();

  // optional int64 start_time = 5;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 5;
  inline ::google::protobuf::int64 start_time() const;
  inline void set_start_time(::google::protobuf::int64 value);

  // optional int64 end_time = 6;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 6;
  inline ::google::protobuf::int64 end_time() const;
  inline void set_end_time(::google::protobuf::int64 value);

  // optional int64 memory_used = 7;
  inline bool has_memory_used() const;
  inline void clear_memory_used();
  static const int kMemoryUsedFieldNumber = 7;
  inline ::google::protobuf::int64 memory_used() const;
  inline void set_memory_used(::google::protobuf::int64 value);

  // optional int64 max_memory_used = 8;
  inline bool has_max_memory_used() const;
  inline void clear_max_memory_used();
  static const int kMaxMemoryUsedFieldNumber = 8;
  inline ::google::protobuf::int64 max_memory_used() const;
  inline void set_max_memory_used(::google::protobuf::int64 value);

  // optional .exec.DrillbitEndpoint endpoint = 9;
  inline bool has_endpoint() const;
  inline void clear_endpoint();
  static const int kEndpointFieldNumber = 9;
  inline const ::exec::DrillbitEndpoint& endpoint() const;
  inline ::exec::DrillbitEndpoint* mutable_endpoint();
  inline ::exec::DrillbitEndpoint* release_endpoint();
  inline void set_allocated_endpoint(::exec::DrillbitEndpoint* endpoint);

  // optional int64 last_update = 10;
  inline bool has_last_update() const;
  inline void clear_last_update();
  static const int kLastUpdateFieldNumber = 10;
  inline ::google::protobuf::int64 last_update() const;
  inline void set_last_update(::google::protobuf::int64 value);

  // optional int64 last_progress = 11;
  inline bool has_last_progress() const;
  inline void clear_last_progress();
  static const int kLastProgressFieldNumber = 11;
  inline ::google::protobuf::int64 last_progress() const;
  inline void set_last_progress(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:exec.shared.MinorFragmentProfile)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_minor_fragment_id();
  inline void clear_has_minor_fragment_id();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_memory_used();
  inline void clear_has_memory_used();
  inline void set_has_max_memory_used();
  inline void clear_has_max_memory_used();
  inline void set_has_endpoint();
  inline void clear_has_endpoint();
  inline void set_has_last_update();
  inline void clear_has_last_update();
  inline void set_has_last_progress();
  inline void clear_has_last_progress();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::exec::shared::DrillPBError* error_;
  int state_;
  ::google::protobuf::int32 minor_fragment_id_;
  ::google::protobuf::RepeatedPtrField< ::exec::shared::OperatorProfile > operator_profile_;
  ::google::protobuf::int64 start_time_;
  ::google::protobuf::int64 end_time_;
  ::google::protobuf::int64 memory_used_;
  ::google::protobuf::int64 max_memory_used_;
  ::exec::DrillbitEndpoint* endpoint_;
  ::google::protobuf::int64 last_update_;
  ::google::protobuf::int64 last_progress_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_UserBitShared_2eproto();
  friend void protobuf_AssignDesc_UserBitShared_2eproto();
  friend void protobuf_ShutdownFile_UserBitShared_2eproto();

  void InitAsDefaultInstance();
  static MinorFragmentProfile* default_instance_;
};
// -------------------------------------------------------------------

class OperatorProfile : public ::google::protobuf::Message {
 public:
  OperatorProfile();
  virtual ~OperatorProfile();

  OperatorProfile(const OperatorProfile& from);

  inline OperatorProfile& operator=(const OperatorProfile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperatorProfile& default_instance();

  void Swap(OperatorProfile* other);

  // implements Message ----------------------------------------------

  OperatorProfile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperatorProfile& from);
  void MergeFrom(const OperatorProfile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .exec.shared.StreamProfile input_profile = 1;
  inline int input_profile_size() const;
  inline void clear_input_profile();
  static const int kInputProfileFieldNumber = 1;
  inline const ::exec::shared::StreamProfile& input_profile(int index) const;
  inline ::exec::shared::StreamProfile* mutable_input_profile(int index);
  inline ::exec::shared::StreamProfile* add_input_profile();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::shared::StreamProfile >&
      input_profile() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::shared::StreamProfile >*
      mutable_input_profile();

  // optional int32 operator_id = 3;
  inline bool has_operator_id() const;
  inline void clear_operator_id();
  static const int kOperatorIdFieldNumber = 3;
  inline ::google::protobuf::int32 operator_id() const;
  inline void set_operator_id(::google::protobuf::int32 value);

  // optional int32 operator_type = 4;
  inline bool has_operator_type() const;
  inline void clear_operator_type();
  static const int kOperatorTypeFieldNumber = 4;
  inline ::google::protobuf::int32 operator_type() const;
  inline void set_operator_type(::google::protobuf::int32 value);

  // optional int64 setup_nanos = 5;
  inline bool has_setup_nanos() const;
  inline void clear_setup_nanos();
  static const int kSetupNanosFieldNumber = 5;
  inline ::google::protobuf::int64 setup_nanos() const;
  inline void set_setup_nanos(::google::protobuf::int64 value);

  // optional int64 process_nanos = 6;
  inline bool has_process_nanos() const;
  inline void clear_process_nanos();
  static const int kProcessNanosFieldNumber = 6;
  inline ::google::protobuf::int64 process_nanos() const;
  inline void set_process_nanos(::google::protobuf::int64 value);

  // optional int64 peak_local_memory_allocated = 7;
  inline bool has_peak_local_memory_allocated() const;
  inline void clear_peak_local_memory_allocated();
  static const int kPeakLocalMemoryAllocatedFieldNumber = 7;
  inline ::google::protobuf::int64 peak_local_memory_allocated() const;
  inline void set_peak_local_memory_allocated(::google::protobuf::int64 value);

  // repeated .exec.shared.MetricValue metric = 8;
  inline int metric_size() const;
  inline void clear_metric();
  static const int kMetricFieldNumber = 8;
  inline const ::exec::shared::MetricValue& metric(int index) const;
  inline ::exec::shared::MetricValue* mutable_metric(int index);
  inline ::exec::shared::MetricValue* add_metric();
  inline const ::google::protobuf::RepeatedPtrField< ::exec::shared::MetricValue >&
      metric() const;
  inline ::google::protobuf::RepeatedPtrField< ::exec::shared::MetricValue >*
      mutable_metric();

  // optional int64 wait_nanos = 9;
  inline bool has_wait_nanos() const;
  inline void clear_wait_nanos();
  static const int kWaitNanosFieldNumber = 9;
  inline ::google::protobuf::int64 wait_nanos() const;
  inline void set_wait_nanos(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:exec.shared.OperatorProfile)
 private:
  inline void set_has_operator_id();
  inline void clear_has_operator_id();
  inline void set_has_operator_type();
  inline void clear_has_operator_type();
  inline void set_has_setup_nanos();
  inline void clear_has_setup_nanos();
  inline void set_has_process_nanos();
  inline void clear_has_process_nanos();
  inline void set_has_peak_local_memory_allocated();
  inline void clear_has_peak_local_memory_allocated();
  inline void set_has_wait_nanos();
  inline void clear_has_wait_nanos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::exec::shared::StreamProfile > input_profile_;
  ::google::protobuf::int32 operator_id_;
  ::google::protobuf::int32 operator_type_;
  ::google::protobuf::int64 setup_nanos_;
  ::google::protobuf::int64 process_nanos_;
  ::google::protobuf::int64 peak_local_memory_allocated_;
  ::google::protobuf::RepeatedPtrField< ::exec::shared::MetricValue > metric_;
  ::google::protobuf::int64 wait_nanos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_UserBitShared_2eproto();
  friend void protobuf_AssignDesc_UserBitShared_2eproto();
  friend void protobuf_ShutdownFile_UserBitShared_2eproto();

  void InitAsDefaultInstance();
  static OperatorProfile* default_instance_;
};
// -------------------------------------------------------------------

class StreamProfile : public ::google::protobuf::Message {
 public:
  StreamProfile();
  virtual ~StreamProfile();

  StreamProfile(const StreamProfile& from);

  inline StreamProfile& operator=(const StreamProfile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamProfile& default_instance();

  void Swap(StreamProfile* other);

  // implements Message ----------------------------------------------

  StreamProfile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamProfile& from);
  void MergeFrom(const StreamProfile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 records = 1;
  inline bool has_records() const;
  inline void clear_records();
  static const int kRecordsFieldNumber = 1;
  inline ::google::protobuf::int64 records() const;
  inline void set_records(::google::protobuf::int64 value);

  // optional int64 batches = 2;
  inline bool has_batches() const;
  inline void clear_batches();
  static const int kBatchesFieldNumber = 2;
  inline ::google::protobuf::int64 batches() const;
  inline void set_batches(::google::protobuf::int64 value);

  // optional int64 schemas = 3;
  inline bool has_schemas() const;
  inline void clear_schemas();
  static const int kSchemasFieldNumber = 3;
  inline ::google::protobuf::int64 schemas() const;
  inline void set_schemas(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:exec.shared.StreamProfile)
 private:
  inline void set_has_records();
  inline void clear_has_records();
  inline void set_has_batches();
  inline void clear_has_batches();
  inline void set_has_schemas();
  inline void clear_has_schemas();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 records_;
  ::google::protobuf::int64 batches_;
  ::google::protobuf::int64 schemas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_UserBitShared_2eproto();
  friend void protobuf_AssignDesc_UserBitShared_2eproto();
  friend void protobuf_ShutdownFile_UserBitShared_2eproto();

  void InitAsDefaultInstance();
  static StreamProfile* default_instance_;
};
// -------------------------------------------------------------------

class MetricValue : public ::google::protobuf::Message {
 public:
  MetricValue();
  virtual ~MetricValue();

  MetricValue(const MetricValue& from);

  inline MetricValue& operator=(const MetricValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MetricValue& default_instance();

  void Swap(MetricValue* other);

  // implements Message ----------------------------------------------

  MetricValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MetricValue& from);
  void MergeFrom(const MetricValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 metric_id = 1;
  inline bool has_metric_id() const;
  inline void clear_metric_id();
  static const int kMetricIdFieldNumber = 1;
  inline ::google::protobuf::int32 metric_id() const;
  inline void set_metric_id(::google::protobuf::int32 value);

  // optional int64 long_value = 2;
  inline bool has_long_value() const;
  inline void clear_long_value();
  static const int kLongValueFieldNumber = 2;
  inline ::google::protobuf::int64 long_value() const;
  inline void set_long_value(::google::protobuf::int64 value);

  // optional double double_value = 3;
  inline bool has_double_value() const;
  inline void clear_double_value();
  static const int kDoubleValueFieldNumber = 3;
  inline double double_value() const;
  inline void set_double_value(double value);

  // @@protoc_insertion_point(class_scope:exec.shared.MetricValue)
 private:
  inline void set_has_metric_id();
  inline void clear_has_metric_id();
  inline void set_has_long_value();
  inline void clear_has_long_value();
  inline void set_has_double_value();
  inline void clear_has_double_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 long_value_;
  double double_value_;
  ::google::protobuf::int32 metric_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_UserBitShared_2eproto();
  friend void protobuf_AssignDesc_UserBitShared_2eproto();
  friend void protobuf_ShutdownFile_UserBitShared_2eproto();

  void InitAsDefaultInstance();
  static MetricValue* default_instance_;
};
// ===================================================================


// ===================================================================

// UserCredentials

// optional string user_name = 1;
inline bool UserCredentials::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserCredentials::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserCredentials::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserCredentials::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& UserCredentials::user_name() const {
  return *user_name_;
}
inline void UserCredentials::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void UserCredentials::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void UserCredentials::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserCredentials::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* UserCredentials::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserCredentials::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// QueryId

// optional sfixed64 part1 = 1;
inline bool QueryId::has_part1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryId::set_has_part1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryId::clear_has_part1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryId::clear_part1() {
  part1_ = GOOGLE_LONGLONG(0);
  clear_has_part1();
}
inline ::google::protobuf::int64 QueryId::part1() const {
  return part1_;
}
inline void QueryId::set_part1(::google::protobuf::int64 value) {
  set_has_part1();
  part1_ = value;
}

// optional sfixed64 part2 = 2;
inline bool QueryId::has_part2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryId::set_has_part2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryId::clear_has_part2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryId::clear_part2() {
  part2_ = GOOGLE_LONGLONG(0);
  clear_has_part2();
}
inline ::google::protobuf::int64 QueryId::part2() const {
  return part2_;
}
inline void QueryId::set_part2(::google::protobuf::int64 value) {
  set_has_part2();
  part2_ = value;
}

// -------------------------------------------------------------------

// DrillPBError

// optional string error_id = 1;
inline bool DrillPBError::has_error_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DrillPBError::set_has_error_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DrillPBError::clear_has_error_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DrillPBError::clear_error_id() {
  if (error_id_ != &::google::protobuf::internal::kEmptyString) {
    error_id_->clear();
  }
  clear_has_error_id();
}
inline const ::std::string& DrillPBError::error_id() const {
  return *error_id_;
}
inline void DrillPBError::set_error_id(const ::std::string& value) {
  set_has_error_id();
  if (error_id_ == &::google::protobuf::internal::kEmptyString) {
    error_id_ = new ::std::string;
  }
  error_id_->assign(value);
}
inline void DrillPBError::set_error_id(const char* value) {
  set_has_error_id();
  if (error_id_ == &::google::protobuf::internal::kEmptyString) {
    error_id_ = new ::std::string;
  }
  error_id_->assign(value);
}
inline void DrillPBError::set_error_id(const char* value, size_t size) {
  set_has_error_id();
  if (error_id_ == &::google::protobuf::internal::kEmptyString) {
    error_id_ = new ::std::string;
  }
  error_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DrillPBError::mutable_error_id() {
  set_has_error_id();
  if (error_id_ == &::google::protobuf::internal::kEmptyString) {
    error_id_ = new ::std::string;
  }
  return error_id_;
}
inline ::std::string* DrillPBError::release_error_id() {
  clear_has_error_id();
  if (error_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_id_;
    error_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DrillPBError::set_allocated_error_id(::std::string* error_id) {
  if (error_id_ != &::google::protobuf::internal::kEmptyString) {
    delete error_id_;
  }
  if (error_id) {
    set_has_error_id();
    error_id_ = error_id;
  } else {
    clear_has_error_id();
    error_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .exec.DrillbitEndpoint endpoint = 2;
inline bool DrillPBError::has_endpoint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DrillPBError::set_has_endpoint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DrillPBError::clear_has_endpoint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DrillPBError::clear_endpoint() {
  if (endpoint_ != NULL) endpoint_->::exec::DrillbitEndpoint::Clear();
  clear_has_endpoint();
}
inline const ::exec::DrillbitEndpoint& DrillPBError::endpoint() const {
  return endpoint_ != NULL ? *endpoint_ : *default_instance_->endpoint_;
}
inline ::exec::DrillbitEndpoint* DrillPBError::mutable_endpoint() {
  set_has_endpoint();
  if (endpoint_ == NULL) endpoint_ = new ::exec::DrillbitEndpoint;
  return endpoint_;
}
inline ::exec::DrillbitEndpoint* DrillPBError::release_endpoint() {
  clear_has_endpoint();
  ::exec::DrillbitEndpoint* temp = endpoint_;
  endpoint_ = NULL;
  return temp;
}
inline void DrillPBError::set_allocated_endpoint(::exec::DrillbitEndpoint* endpoint) {
  delete endpoint_;
  endpoint_ = endpoint;
  if (endpoint) {
    set_has_endpoint();
  } else {
    clear_has_endpoint();
  }
}

// optional .exec.shared.DrillPBError.ErrorType error_type = 3;
inline bool DrillPBError::has_error_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DrillPBError::set_has_error_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DrillPBError::clear_has_error_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DrillPBError::clear_error_type() {
  error_type_ = 0;
  clear_has_error_type();
}
inline ::exec::shared::DrillPBError_ErrorType DrillPBError::error_type() const {
  return static_cast< ::exec::shared::DrillPBError_ErrorType >(error_type_);
}
inline void DrillPBError::set_error_type(::exec::shared::DrillPBError_ErrorType value) {
  assert(::exec::shared::DrillPBError_ErrorType_IsValid(value));
  set_has_error_type();
  error_type_ = value;
}

// optional string message = 4;
inline bool DrillPBError::has_message() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DrillPBError::set_has_message() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DrillPBError::clear_has_message() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DrillPBError::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& DrillPBError::message() const {
  return *message_;
}
inline void DrillPBError::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void DrillPBError::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void DrillPBError::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DrillPBError::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* DrillPBError::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DrillPBError::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .exec.shared.ExceptionWrapper exception = 5;
inline bool DrillPBError::has_exception() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DrillPBError::set_has_exception() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DrillPBError::clear_has_exception() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DrillPBError::clear_exception() {
  if (exception_ != NULL) exception_->::exec::shared::ExceptionWrapper::Clear();
  clear_has_exception();
}
inline const ::exec::shared::ExceptionWrapper& DrillPBError::exception() const {
  return exception_ != NULL ? *exception_ : *default_instance_->exception_;
}
inline ::exec::shared::ExceptionWrapper* DrillPBError::mutable_exception() {
  set_has_exception();
  if (exception_ == NULL) exception_ = new ::exec::shared::ExceptionWrapper;
  return exception_;
}
inline ::exec::shared::ExceptionWrapper* DrillPBError::release_exception() {
  clear_has_exception();
  ::exec::shared::ExceptionWrapper* temp = exception_;
  exception_ = NULL;
  return temp;
}
inline void DrillPBError::set_allocated_exception(::exec::shared::ExceptionWrapper* exception) {
  delete exception_;
  exception_ = exception;
  if (exception) {
    set_has_exception();
  } else {
    clear_has_exception();
  }
}

// repeated .exec.shared.ParsingError parsing_error = 6;
inline int DrillPBError::parsing_error_size() const {
  return parsing_error_.size();
}
inline void DrillPBError::clear_parsing_error() {
  parsing_error_.Clear();
}
inline const ::exec::shared::ParsingError& DrillPBError::parsing_error(int index) const {
  return parsing_error_.Get(index);
}
inline ::exec::shared::ParsingError* DrillPBError::mutable_parsing_error(int index) {
  return parsing_error_.Mutable(index);
}
inline ::exec::shared::ParsingError* DrillPBError::add_parsing_error() {
  return parsing_error_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::shared::ParsingError >&
DrillPBError::parsing_error() const {
  return parsing_error_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::shared::ParsingError >*
DrillPBError::mutable_parsing_error() {
  return &parsing_error_;
}

// -------------------------------------------------------------------

// ExceptionWrapper

// optional string exception_class = 1;
inline bool ExceptionWrapper::has_exception_class() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExceptionWrapper::set_has_exception_class() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExceptionWrapper::clear_has_exception_class() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExceptionWrapper::clear_exception_class() {
  if (exception_class_ != &::google::protobuf::internal::kEmptyString) {
    exception_class_->clear();
  }
  clear_has_exception_class();
}
inline const ::std::string& ExceptionWrapper::exception_class() const {
  return *exception_class_;
}
inline void ExceptionWrapper::set_exception_class(const ::std::string& value) {
  set_has_exception_class();
  if (exception_class_ == &::google::protobuf::internal::kEmptyString) {
    exception_class_ = new ::std::string;
  }
  exception_class_->assign(value);
}
inline void ExceptionWrapper::set_exception_class(const char* value) {
  set_has_exception_class();
  if (exception_class_ == &::google::protobuf::internal::kEmptyString) {
    exception_class_ = new ::std::string;
  }
  exception_class_->assign(value);
}
inline void ExceptionWrapper::set_exception_class(const char* value, size_t size) {
  set_has_exception_class();
  if (exception_class_ == &::google::protobuf::internal::kEmptyString) {
    exception_class_ = new ::std::string;
  }
  exception_class_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExceptionWrapper::mutable_exception_class() {
  set_has_exception_class();
  if (exception_class_ == &::google::protobuf::internal::kEmptyString) {
    exception_class_ = new ::std::string;
  }
  return exception_class_;
}
inline ::std::string* ExceptionWrapper::release_exception_class() {
  clear_has_exception_class();
  if (exception_class_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exception_class_;
    exception_class_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExceptionWrapper::set_allocated_exception_class(::std::string* exception_class) {
  if (exception_class_ != &::google::protobuf::internal::kEmptyString) {
    delete exception_class_;
  }
  if (exception_class) {
    set_has_exception_class();
    exception_class_ = exception_class;
  } else {
    clear_has_exception_class();
    exception_class_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string message = 2;
inline bool ExceptionWrapper::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExceptionWrapper::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExceptionWrapper::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExceptionWrapper::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ExceptionWrapper::message() const {
  return *message_;
}
inline void ExceptionWrapper::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ExceptionWrapper::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ExceptionWrapper::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExceptionWrapper::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ExceptionWrapper::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExceptionWrapper::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .exec.shared.StackTraceElementWrapper stack_trace = 3;
inline int ExceptionWrapper::stack_trace_size() const {
  return stack_trace_.size();
}
inline void ExceptionWrapper::clear_stack_trace() {
  stack_trace_.Clear();
}
inline const ::exec::shared::StackTraceElementWrapper& ExceptionWrapper::stack_trace(int index) const {
  return stack_trace_.Get(index);
}
inline ::exec::shared::StackTraceElementWrapper* ExceptionWrapper::mutable_stack_trace(int index) {
  return stack_trace_.Mutable(index);
}
inline ::exec::shared::StackTraceElementWrapper* ExceptionWrapper::add_stack_trace() {
  return stack_trace_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::shared::StackTraceElementWrapper >&
ExceptionWrapper::stack_trace() const {
  return stack_trace_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::shared::StackTraceElementWrapper >*
ExceptionWrapper::mutable_stack_trace() {
  return &stack_trace_;
}

// optional .exec.shared.ExceptionWrapper cause = 4;
inline bool ExceptionWrapper::has_cause() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExceptionWrapper::set_has_cause() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExceptionWrapper::clear_has_cause() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExceptionWrapper::clear_cause() {
  if (cause_ != NULL) cause_->::exec::shared::ExceptionWrapper::Clear();
  clear_has_cause();
}
inline const ::exec::shared::ExceptionWrapper& ExceptionWrapper::cause() const {
  return cause_ != NULL ? *cause_ : *default_instance_->cause_;
}
inline ::exec::shared::ExceptionWrapper* ExceptionWrapper::mutable_cause() {
  set_has_cause();
  if (cause_ == NULL) cause_ = new ::exec::shared::ExceptionWrapper;
  return cause_;
}
inline ::exec::shared::ExceptionWrapper* ExceptionWrapper::release_cause() {
  clear_has_cause();
  ::exec::shared::ExceptionWrapper* temp = cause_;
  cause_ = NULL;
  return temp;
}
inline void ExceptionWrapper::set_allocated_cause(::exec::shared::ExceptionWrapper* cause) {
  delete cause_;
  cause_ = cause;
  if (cause) {
    set_has_cause();
  } else {
    clear_has_cause();
  }
}

// -------------------------------------------------------------------

// StackTraceElementWrapper

// optional string class_name = 1;
inline bool StackTraceElementWrapper::has_class_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StackTraceElementWrapper::set_has_class_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StackTraceElementWrapper::clear_has_class_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StackTraceElementWrapper::clear_class_name() {
  if (class_name_ != &::google::protobuf::internal::kEmptyString) {
    class_name_->clear();
  }
  clear_has_class_name();
}
inline const ::std::string& StackTraceElementWrapper::class_name() const {
  return *class_name_;
}
inline void StackTraceElementWrapper::set_class_name(const ::std::string& value) {
  set_has_class_name();
  if (class_name_ == &::google::protobuf::internal::kEmptyString) {
    class_name_ = new ::std::string;
  }
  class_name_->assign(value);
}
inline void StackTraceElementWrapper::set_class_name(const char* value) {
  set_has_class_name();
  if (class_name_ == &::google::protobuf::internal::kEmptyString) {
    class_name_ = new ::std::string;
  }
  class_name_->assign(value);
}
inline void StackTraceElementWrapper::set_class_name(const char* value, size_t size) {
  set_has_class_name();
  if (class_name_ == &::google::protobuf::internal::kEmptyString) {
    class_name_ = new ::std::string;
  }
  class_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StackTraceElementWrapper::mutable_class_name() {
  set_has_class_name();
  if (class_name_ == &::google::protobuf::internal::kEmptyString) {
    class_name_ = new ::std::string;
  }
  return class_name_;
}
inline ::std::string* StackTraceElementWrapper::release_class_name() {
  clear_has_class_name();
  if (class_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = class_name_;
    class_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StackTraceElementWrapper::set_allocated_class_name(::std::string* class_name) {
  if (class_name_ != &::google::protobuf::internal::kEmptyString) {
    delete class_name_;
  }
  if (class_name) {
    set_has_class_name();
    class_name_ = class_name;
  } else {
    clear_has_class_name();
    class_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string file_name = 2;
inline bool StackTraceElementWrapper::has_file_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StackTraceElementWrapper::set_has_file_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StackTraceElementWrapper::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StackTraceElementWrapper::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& StackTraceElementWrapper::file_name() const {
  return *file_name_;
}
inline void StackTraceElementWrapper::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void StackTraceElementWrapper::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void StackTraceElementWrapper::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StackTraceElementWrapper::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* StackTraceElementWrapper::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StackTraceElementWrapper::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 line_number = 3;
inline bool StackTraceElementWrapper::has_line_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StackTraceElementWrapper::set_has_line_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StackTraceElementWrapper::clear_has_line_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StackTraceElementWrapper::clear_line_number() {
  line_number_ = 0;
  clear_has_line_number();
}
inline ::google::protobuf::int32 StackTraceElementWrapper::line_number() const {
  return line_number_;
}
inline void StackTraceElementWrapper::set_line_number(::google::protobuf::int32 value) {
  set_has_line_number();
  line_number_ = value;
}

// optional string method_name = 4;
inline bool StackTraceElementWrapper::has_method_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StackTraceElementWrapper::set_has_method_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StackTraceElementWrapper::clear_has_method_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StackTraceElementWrapper::clear_method_name() {
  if (method_name_ != &::google::protobuf::internal::kEmptyString) {
    method_name_->clear();
  }
  clear_has_method_name();
}
inline const ::std::string& StackTraceElementWrapper::method_name() const {
  return *method_name_;
}
inline void StackTraceElementWrapper::set_method_name(const ::std::string& value) {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(value);
}
inline void StackTraceElementWrapper::set_method_name(const char* value) {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(value);
}
inline void StackTraceElementWrapper::set_method_name(const char* value, size_t size) {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StackTraceElementWrapper::mutable_method_name() {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    method_name_ = new ::std::string;
  }
  return method_name_;
}
inline ::std::string* StackTraceElementWrapper::release_method_name() {
  clear_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = method_name_;
    method_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StackTraceElementWrapper::set_allocated_method_name(::std::string* method_name) {
  if (method_name_ != &::google::protobuf::internal::kEmptyString) {
    delete method_name_;
  }
  if (method_name) {
    set_has_method_name();
    method_name_ = method_name;
  } else {
    clear_has_method_name();
    method_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_native_method = 5;
inline bool StackTraceElementWrapper::has_is_native_method() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StackTraceElementWrapper::set_has_is_native_method() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StackTraceElementWrapper::clear_has_is_native_method() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StackTraceElementWrapper::clear_is_native_method() {
  is_native_method_ = false;
  clear_has_is_native_method();
}
inline bool StackTraceElementWrapper::is_native_method() const {
  return is_native_method_;
}
inline void StackTraceElementWrapper::set_is_native_method(bool value) {
  set_has_is_native_method();
  is_native_method_ = value;
}

// -------------------------------------------------------------------

// ParsingError

// optional int32 start_column = 2;
inline bool ParsingError::has_start_column() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParsingError::set_has_start_column() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParsingError::clear_has_start_column() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParsingError::clear_start_column() {
  start_column_ = 0;
  clear_has_start_column();
}
inline ::google::protobuf::int32 ParsingError::start_column() const {
  return start_column_;
}
inline void ParsingError::set_start_column(::google::protobuf::int32 value) {
  set_has_start_column();
  start_column_ = value;
}

// optional int32 start_row = 3;
inline bool ParsingError::has_start_row() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParsingError::set_has_start_row() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParsingError::clear_has_start_row() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParsingError::clear_start_row() {
  start_row_ = 0;
  clear_has_start_row();
}
inline ::google::protobuf::int32 ParsingError::start_row() const {
  return start_row_;
}
inline void ParsingError::set_start_row(::google::protobuf::int32 value) {
  set_has_start_row();
  start_row_ = value;
}

// optional int32 end_column = 4;
inline bool ParsingError::has_end_column() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParsingError::set_has_end_column() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParsingError::clear_has_end_column() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParsingError::clear_end_column() {
  end_column_ = 0;
  clear_has_end_column();
}
inline ::google::protobuf::int32 ParsingError::end_column() const {
  return end_column_;
}
inline void ParsingError::set_end_column(::google::protobuf::int32 value) {
  set_has_end_column();
  end_column_ = value;
}

// optional int32 end_row = 5;
inline bool ParsingError::has_end_row() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParsingError::set_has_end_row() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParsingError::clear_has_end_row() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParsingError::clear_end_row() {
  end_row_ = 0;
  clear_has_end_row();
}
inline ::google::protobuf::int32 ParsingError::end_row() const {
  return end_row_;
}
inline void ParsingError::set_end_row(::google::protobuf::int32 value) {
  set_has_end_row();
  end_row_ = value;
}

// -------------------------------------------------------------------

// RecordBatchDef

// optional int32 record_count = 1;
inline bool RecordBatchDef::has_record_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecordBatchDef::set_has_record_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecordBatchDef::clear_has_record_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecordBatchDef::clear_record_count() {
  record_count_ = 0;
  clear_has_record_count();
}
inline ::google::protobuf::int32 RecordBatchDef::record_count() const {
  return record_count_;
}
inline void RecordBatchDef::set_record_count(::google::protobuf::int32 value) {
  set_has_record_count();
  record_count_ = value;
}

// repeated .exec.shared.SerializedField field = 2;
inline int RecordBatchDef::field_size() const {
  return field_.size();
}
inline void RecordBatchDef::clear_field() {
  field_.Clear();
}
inline const ::exec::shared::SerializedField& RecordBatchDef::field(int index) const {
  return field_.Get(index);
}
inline ::exec::shared::SerializedField* RecordBatchDef::mutable_field(int index) {
  return field_.Mutable(index);
}
inline ::exec::shared::SerializedField* RecordBatchDef::add_field() {
  return field_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::shared::SerializedField >&
RecordBatchDef::field() const {
  return field_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::shared::SerializedField >*
RecordBatchDef::mutable_field() {
  return &field_;
}

// optional bool carries_two_byte_selection_vector = 3;
inline bool RecordBatchDef::has_carries_two_byte_selection_vector() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecordBatchDef::set_has_carries_two_byte_selection_vector() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RecordBatchDef::clear_has_carries_two_byte_selection_vector() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RecordBatchDef::clear_carries_two_byte_selection_vector() {
  carries_two_byte_selection_vector_ = false;
  clear_has_carries_two_byte_selection_vector();
}
inline bool RecordBatchDef::carries_two_byte_selection_vector() const {
  return carries_two_byte_selection_vector_;
}
inline void RecordBatchDef::set_carries_two_byte_selection_vector(bool value) {
  set_has_carries_two_byte_selection_vector();
  carries_two_byte_selection_vector_ = value;
}

// -------------------------------------------------------------------

// NamePart

// optional .exec.shared.NamePart.Type type = 1;
inline bool NamePart::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NamePart::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NamePart::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NamePart::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::exec::shared::NamePart_Type NamePart::type() const {
  return static_cast< ::exec::shared::NamePart_Type >(type_);
}
inline void NamePart::set_type(::exec::shared::NamePart_Type value) {
  assert(::exec::shared::NamePart_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string name = 2;
inline bool NamePart::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NamePart::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NamePart::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NamePart::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NamePart::name() const {
  return *name_;
}
inline void NamePart::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NamePart::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NamePart::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NamePart::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NamePart::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NamePart::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .exec.shared.NamePart child = 3;
inline bool NamePart::has_child() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NamePart::set_has_child() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NamePart::clear_has_child() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NamePart::clear_child() {
  if (child_ != NULL) child_->::exec::shared::NamePart::Clear();
  clear_has_child();
}
inline const ::exec::shared::NamePart& NamePart::child() const {
  return child_ != NULL ? *child_ : *default_instance_->child_;
}
inline ::exec::shared::NamePart* NamePart::mutable_child() {
  set_has_child();
  if (child_ == NULL) child_ = new ::exec::shared::NamePart;
  return child_;
}
inline ::exec::shared::NamePart* NamePart::release_child() {
  clear_has_child();
  ::exec::shared::NamePart* temp = child_;
  child_ = NULL;
  return temp;
}
inline void NamePart::set_allocated_child(::exec::shared::NamePart* child) {
  delete child_;
  child_ = child;
  if (child) {
    set_has_child();
  } else {
    clear_has_child();
  }
}

// -------------------------------------------------------------------

// SerializedField

// optional .common.MajorType major_type = 1;
inline bool SerializedField::has_major_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SerializedField::set_has_major_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SerializedField::clear_has_major_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SerializedField::clear_major_type() {
  if (major_type_ != NULL) major_type_->::common::MajorType::Clear();
  clear_has_major_type();
}
inline const ::common::MajorType& SerializedField::major_type() const {
  return major_type_ != NULL ? *major_type_ : *default_instance_->major_type_;
}
inline ::common::MajorType* SerializedField::mutable_major_type() {
  set_has_major_type();
  if (major_type_ == NULL) major_type_ = new ::common::MajorType;
  return major_type_;
}
inline ::common::MajorType* SerializedField::release_major_type() {
  clear_has_major_type();
  ::common::MajorType* temp = major_type_;
  major_type_ = NULL;
  return temp;
}
inline void SerializedField::set_allocated_major_type(::common::MajorType* major_type) {
  delete major_type_;
  major_type_ = major_type;
  if (major_type) {
    set_has_major_type();
  } else {
    clear_has_major_type();
  }
}

// optional .exec.shared.NamePart name_part = 2;
inline bool SerializedField::has_name_part() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SerializedField::set_has_name_part() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SerializedField::clear_has_name_part() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SerializedField::clear_name_part() {
  if (name_part_ != NULL) name_part_->::exec::shared::NamePart::Clear();
  clear_has_name_part();
}
inline const ::exec::shared::NamePart& SerializedField::name_part() const {
  return name_part_ != NULL ? *name_part_ : *default_instance_->name_part_;
}
inline ::exec::shared::NamePart* SerializedField::mutable_name_part() {
  set_has_name_part();
  if (name_part_ == NULL) name_part_ = new ::exec::shared::NamePart;
  return name_part_;
}
inline ::exec::shared::NamePart* SerializedField::release_name_part() {
  clear_has_name_part();
  ::exec::shared::NamePart* temp = name_part_;
  name_part_ = NULL;
  return temp;
}
inline void SerializedField::set_allocated_name_part(::exec::shared::NamePart* name_part) {
  delete name_part_;
  name_part_ = name_part;
  if (name_part) {
    set_has_name_part();
  } else {
    clear_has_name_part();
  }
}

// repeated .exec.shared.SerializedField child = 3;
inline int SerializedField::child_size() const {
  return child_.size();
}
inline void SerializedField::clear_child() {
  child_.Clear();
}
inline const ::exec::shared::SerializedField& SerializedField::child(int index) const {
  return child_.Get(index);
}
inline ::exec::shared::SerializedField* SerializedField::mutable_child(int index) {
  return child_.Mutable(index);
}
inline ::exec::shared::SerializedField* SerializedField::add_child() {
  return child_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::shared::SerializedField >&
SerializedField::child() const {
  return child_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::shared::SerializedField >*
SerializedField::mutable_child() {
  return &child_;
}

// optional int32 value_count = 4;
inline bool SerializedField::has_value_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SerializedField::set_has_value_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SerializedField::clear_has_value_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SerializedField::clear_value_count() {
  value_count_ = 0;
  clear_has_value_count();
}
inline ::google::protobuf::int32 SerializedField::value_count() const {
  return value_count_;
}
inline void SerializedField::set_value_count(::google::protobuf::int32 value) {
  set_has_value_count();
  value_count_ = value;
}

// optional int32 var_byte_length = 5;
inline bool SerializedField::has_var_byte_length() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SerializedField::set_has_var_byte_length() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SerializedField::clear_has_var_byte_length() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SerializedField::clear_var_byte_length() {
  var_byte_length_ = 0;
  clear_has_var_byte_length();
}
inline ::google::protobuf::int32 SerializedField::var_byte_length() const {
  return var_byte_length_;
}
inline void SerializedField::set_var_byte_length(::google::protobuf::int32 value) {
  set_has_var_byte_length();
  var_byte_length_ = value;
}

// optional int32 buffer_length = 7;
inline bool SerializedField::has_buffer_length() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SerializedField::set_has_buffer_length() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SerializedField::clear_has_buffer_length() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SerializedField::clear_buffer_length() {
  buffer_length_ = 0;
  clear_has_buffer_length();
}
inline ::google::protobuf::int32 SerializedField::buffer_length() const {
  return buffer_length_;
}
inline void SerializedField::set_buffer_length(::google::protobuf::int32 value) {
  set_has_buffer_length();
  buffer_length_ = value;
}

// -------------------------------------------------------------------

// NodeStatus

// optional int32 node_id = 1;
inline bool NodeStatus::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeStatus::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeStatus::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeStatus::clear_node_id() {
  node_id_ = 0;
  clear_has_node_id();
}
inline ::google::protobuf::int32 NodeStatus::node_id() const {
  return node_id_;
}
inline void NodeStatus::set_node_id(::google::protobuf::int32 value) {
  set_has_node_id();
  node_id_ = value;
}

// optional int64 memory_footprint = 2;
inline bool NodeStatus::has_memory_footprint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeStatus::set_has_memory_footprint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeStatus::clear_has_memory_footprint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeStatus::clear_memory_footprint() {
  memory_footprint_ = GOOGLE_LONGLONG(0);
  clear_has_memory_footprint();
}
inline ::google::protobuf::int64 NodeStatus::memory_footprint() const {
  return memory_footprint_;
}
inline void NodeStatus::set_memory_footprint(::google::protobuf::int64 value) {
  set_has_memory_footprint();
  memory_footprint_ = value;
}

// -------------------------------------------------------------------

// QueryResult

// optional .exec.shared.QueryResult.QueryState query_state = 1;
inline bool QueryResult::has_query_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryResult::set_has_query_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryResult::clear_has_query_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryResult::clear_query_state() {
  query_state_ = 0;
  clear_has_query_state();
}
inline ::exec::shared::QueryResult_QueryState QueryResult::query_state() const {
  return static_cast< ::exec::shared::QueryResult_QueryState >(query_state_);
}
inline void QueryResult::set_query_state(::exec::shared::QueryResult_QueryState value) {
  assert(::exec::shared::QueryResult_QueryState_IsValid(value));
  set_has_query_state();
  query_state_ = value;
}

// optional .exec.shared.QueryId query_id = 2;
inline bool QueryResult::has_query_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryResult::set_has_query_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryResult::clear_has_query_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryResult::clear_query_id() {
  if (query_id_ != NULL) query_id_->::exec::shared::QueryId::Clear();
  clear_has_query_id();
}
inline const ::exec::shared::QueryId& QueryResult::query_id() const {
  return query_id_ != NULL ? *query_id_ : *default_instance_->query_id_;
}
inline ::exec::shared::QueryId* QueryResult::mutable_query_id() {
  set_has_query_id();
  if (query_id_ == NULL) query_id_ = new ::exec::shared::QueryId;
  return query_id_;
}
inline ::exec::shared::QueryId* QueryResult::release_query_id() {
  clear_has_query_id();
  ::exec::shared::QueryId* temp = query_id_;
  query_id_ = NULL;
  return temp;
}
inline void QueryResult::set_allocated_query_id(::exec::shared::QueryId* query_id) {
  delete query_id_;
  query_id_ = query_id;
  if (query_id) {
    set_has_query_id();
  } else {
    clear_has_query_id();
  }
}

// repeated .exec.shared.DrillPBError error = 3;
inline int QueryResult::error_size() const {
  return error_.size();
}
inline void QueryResult::clear_error() {
  error_.Clear();
}
inline const ::exec::shared::DrillPBError& QueryResult::error(int index) const {
  return error_.Get(index);
}
inline ::exec::shared::DrillPBError* QueryResult::mutable_error(int index) {
  return error_.Mutable(index);
}
inline ::exec::shared::DrillPBError* QueryResult::add_error() {
  return error_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::shared::DrillPBError >&
QueryResult::error() const {
  return error_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::shared::DrillPBError >*
QueryResult::mutable_error() {
  return &error_;
}

// -------------------------------------------------------------------

// QueryData

// optional .exec.shared.QueryId query_id = 1;
inline bool QueryData::has_query_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryData::set_has_query_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryData::clear_has_query_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryData::clear_query_id() {
  if (query_id_ != NULL) query_id_->::exec::shared::QueryId::Clear();
  clear_has_query_id();
}
inline const ::exec::shared::QueryId& QueryData::query_id() const {
  return query_id_ != NULL ? *query_id_ : *default_instance_->query_id_;
}
inline ::exec::shared::QueryId* QueryData::mutable_query_id() {
  set_has_query_id();
  if (query_id_ == NULL) query_id_ = new ::exec::shared::QueryId;
  return query_id_;
}
inline ::exec::shared::QueryId* QueryData::release_query_id() {
  clear_has_query_id();
  ::exec::shared::QueryId* temp = query_id_;
  query_id_ = NULL;
  return temp;
}
inline void QueryData::set_allocated_query_id(::exec::shared::QueryId* query_id) {
  delete query_id_;
  query_id_ = query_id;
  if (query_id) {
    set_has_query_id();
  } else {
    clear_has_query_id();
  }
}

// optional int32 row_count = 2;
inline bool QueryData::has_row_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryData::set_has_row_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryData::clear_has_row_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryData::clear_row_count() {
  row_count_ = 0;
  clear_has_row_count();
}
inline ::google::protobuf::int32 QueryData::row_count() const {
  return row_count_;
}
inline void QueryData::set_row_count(::google::protobuf::int32 value) {
  set_has_row_count();
  row_count_ = value;
}

// optional .exec.shared.RecordBatchDef def = 3;
inline bool QueryData::has_def() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryData::set_has_def() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryData::clear_has_def() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryData::clear_def() {
  if (def_ != NULL) def_->::exec::shared::RecordBatchDef::Clear();
  clear_has_def();
}
inline const ::exec::shared::RecordBatchDef& QueryData::def() const {
  return def_ != NULL ? *def_ : *default_instance_->def_;
}
inline ::exec::shared::RecordBatchDef* QueryData::mutable_def() {
  set_has_def();
  if (def_ == NULL) def_ = new ::exec::shared::RecordBatchDef;
  return def_;
}
inline ::exec::shared::RecordBatchDef* QueryData::release_def() {
  clear_has_def();
  ::exec::shared::RecordBatchDef* temp = def_;
  def_ = NULL;
  return temp;
}
inline void QueryData::set_allocated_def(::exec::shared::RecordBatchDef* def) {
  delete def_;
  def_ = def;
  if (def) {
    set_has_def();
  } else {
    clear_has_def();
  }
}

// -------------------------------------------------------------------

// QueryInfo

// optional string query = 1;
inline bool QueryInfo::has_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryInfo::set_has_query() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryInfo::clear_has_query() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryInfo::clear_query() {
  if (query_ != &::google::protobuf::internal::kEmptyString) {
    query_->clear();
  }
  clear_has_query();
}
inline const ::std::string& QueryInfo::query() const {
  return *query_;
}
inline void QueryInfo::set_query(const ::std::string& value) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(value);
}
inline void QueryInfo::set_query(const char* value) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(value);
}
inline void QueryInfo::set_query(const char* value, size_t size) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryInfo::mutable_query() {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  return query_;
}
inline ::std::string* QueryInfo::release_query() {
  clear_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = query_;
    query_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryInfo::set_allocated_query(::std::string* query) {
  if (query_ != &::google::protobuf::internal::kEmptyString) {
    delete query_;
  }
  if (query) {
    set_has_query();
    query_ = query;
  } else {
    clear_has_query();
    query_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 start = 2;
inline bool QueryInfo::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryInfo::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryInfo::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryInfo::clear_start() {
  start_ = GOOGLE_LONGLONG(0);
  clear_has_start();
}
inline ::google::protobuf::int64 QueryInfo::start() const {
  return start_;
}
inline void QueryInfo::set_start(::google::protobuf::int64 value) {
  set_has_start();
  start_ = value;
}

// optional .exec.shared.QueryResult.QueryState state = 3;
inline bool QueryInfo::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryInfo::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::exec::shared::QueryResult_QueryState QueryInfo::state() const {
  return static_cast< ::exec::shared::QueryResult_QueryState >(state_);
}
inline void QueryInfo::set_state(::exec::shared::QueryResult_QueryState value) {
  assert(::exec::shared::QueryResult_QueryState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional string user = 4 [default = "-"];
inline bool QueryInfo::has_user() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QueryInfo::set_has_user() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QueryInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QueryInfo::clear_user() {
  if (user_ != _default_user_) {
    user_->assign(*_default_user_);
  }
  clear_has_user();
}
inline const ::std::string& QueryInfo::user() const {
  return *user_;
}
inline void QueryInfo::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == _default_user_) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void QueryInfo::set_user(const char* value) {
  set_has_user();
  if (user_ == _default_user_) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void QueryInfo::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == _default_user_) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryInfo::mutable_user() {
  set_has_user();
  if (user_ == _default_user_) {
    user_ = new ::std::string(*_default_user_);
  }
  return user_;
}
inline ::std::string* QueryInfo::release_user() {
  clear_has_user();
  if (user_ == _default_user_) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(_default_user_);
    return temp;
  }
}
inline void QueryInfo::set_allocated_user(::std::string* user) {
  if (user_ != _default_user_) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(_default_user_);
  }
}

// optional .exec.DrillbitEndpoint foreman = 5;
inline bool QueryInfo::has_foreman() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void QueryInfo::set_has_foreman() {
  _has_bits_[0] |= 0x00000010u;
}
inline void QueryInfo::clear_has_foreman() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void QueryInfo::clear_foreman() {
  if (foreman_ != NULL) foreman_->::exec::DrillbitEndpoint::Clear();
  clear_has_foreman();
}
inline const ::exec::DrillbitEndpoint& QueryInfo::foreman() const {
  return foreman_ != NULL ? *foreman_ : *default_instance_->foreman_;
}
inline ::exec::DrillbitEndpoint* QueryInfo::mutable_foreman() {
  set_has_foreman();
  if (foreman_ == NULL) foreman_ = new ::exec::DrillbitEndpoint;
  return foreman_;
}
inline ::exec::DrillbitEndpoint* QueryInfo::release_foreman() {
  clear_has_foreman();
  ::exec::DrillbitEndpoint* temp = foreman_;
  foreman_ = NULL;
  return temp;
}
inline void QueryInfo::set_allocated_foreman(::exec::DrillbitEndpoint* foreman) {
  delete foreman_;
  foreman_ = foreman;
  if (foreman) {
    set_has_foreman();
  } else {
    clear_has_foreman();
  }
}

// -------------------------------------------------------------------

// QueryProfile

// optional .exec.shared.QueryId id = 1;
inline bool QueryProfile::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryProfile::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryProfile::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryProfile::clear_id() {
  if (id_ != NULL) id_->::exec::shared::QueryId::Clear();
  clear_has_id();
}
inline const ::exec::shared::QueryId& QueryProfile::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::exec::shared::QueryId* QueryProfile::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::exec::shared::QueryId;
  return id_;
}
inline ::exec::shared::QueryId* QueryProfile::release_id() {
  clear_has_id();
  ::exec::shared::QueryId* temp = id_;
  id_ = NULL;
  return temp;
}
inline void QueryProfile::set_allocated_id(::exec::shared::QueryId* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// optional .exec.shared.QueryType type = 2;
inline bool QueryProfile::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryProfile::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryProfile::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryProfile::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::exec::shared::QueryType QueryProfile::type() const {
  return static_cast< ::exec::shared::QueryType >(type_);
}
inline void QueryProfile::set_type(::exec::shared::QueryType value) {
  assert(::exec::shared::QueryType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int64 start = 3;
inline bool QueryProfile::has_start() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryProfile::set_has_start() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryProfile::clear_has_start() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryProfile::clear_start() {
  start_ = GOOGLE_LONGLONG(0);
  clear_has_start();
}
inline ::google::protobuf::int64 QueryProfile::start() const {
  return start_;
}
inline void QueryProfile::set_start(::google::protobuf::int64 value) {
  set_has_start();
  start_ = value;
}

// optional int64 end = 4;
inline bool QueryProfile::has_end() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QueryProfile::set_has_end() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QueryProfile::clear_has_end() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QueryProfile::clear_end() {
  end_ = GOOGLE_LONGLONG(0);
  clear_has_end();
}
inline ::google::protobuf::int64 QueryProfile::end() const {
  return end_;
}
inline void QueryProfile::set_end(::google::protobuf::int64 value) {
  set_has_end();
  end_ = value;
}

// optional string query = 5;
inline bool QueryProfile::has_query() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void QueryProfile::set_has_query() {
  _has_bits_[0] |= 0x00000010u;
}
inline void QueryProfile::clear_has_query() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void QueryProfile::clear_query() {
  if (query_ != &::google::protobuf::internal::kEmptyString) {
    query_->clear();
  }
  clear_has_query();
}
inline const ::std::string& QueryProfile::query() const {
  return *query_;
}
inline void QueryProfile::set_query(const ::std::string& value) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(value);
}
inline void QueryProfile::set_query(const char* value) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(value);
}
inline void QueryProfile::set_query(const char* value, size_t size) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryProfile::mutable_query() {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  return query_;
}
inline ::std::string* QueryProfile::release_query() {
  clear_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = query_;
    query_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryProfile::set_allocated_query(::std::string* query) {
  if (query_ != &::google::protobuf::internal::kEmptyString) {
    delete query_;
  }
  if (query) {
    set_has_query();
    query_ = query;
  } else {
    clear_has_query();
    query_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string plan = 6;
inline bool QueryProfile::has_plan() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void QueryProfile::set_has_plan() {
  _has_bits_[0] |= 0x00000020u;
}
inline void QueryProfile::clear_has_plan() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void QueryProfile::clear_plan() {
  if (plan_ != &::google::protobuf::internal::kEmptyString) {
    plan_->clear();
  }
  clear_has_plan();
}
inline const ::std::string& QueryProfile::plan() const {
  return *plan_;
}
inline void QueryProfile::set_plan(const ::std::string& value) {
  set_has_plan();
  if (plan_ == &::google::protobuf::internal::kEmptyString) {
    plan_ = new ::std::string;
  }
  plan_->assign(value);
}
inline void QueryProfile::set_plan(const char* value) {
  set_has_plan();
  if (plan_ == &::google::protobuf::internal::kEmptyString) {
    plan_ = new ::std::string;
  }
  plan_->assign(value);
}
inline void QueryProfile::set_plan(const char* value, size_t size) {
  set_has_plan();
  if (plan_ == &::google::protobuf::internal::kEmptyString) {
    plan_ = new ::std::string;
  }
  plan_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryProfile::mutable_plan() {
  set_has_plan();
  if (plan_ == &::google::protobuf::internal::kEmptyString) {
    plan_ = new ::std::string;
  }
  return plan_;
}
inline ::std::string* QueryProfile::release_plan() {
  clear_has_plan();
  if (plan_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = plan_;
    plan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryProfile::set_allocated_plan(::std::string* plan) {
  if (plan_ != &::google::protobuf::internal::kEmptyString) {
    delete plan_;
  }
  if (plan) {
    set_has_plan();
    plan_ = plan;
  } else {
    clear_has_plan();
    plan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .exec.DrillbitEndpoint foreman = 7;
inline bool QueryProfile::has_foreman() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void QueryProfile::set_has_foreman() {
  _has_bits_[0] |= 0x00000040u;
}
inline void QueryProfile::clear_has_foreman() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void QueryProfile::clear_foreman() {
  if (foreman_ != NULL) foreman_->::exec::DrillbitEndpoint::Clear();
  clear_has_foreman();
}
inline const ::exec::DrillbitEndpoint& QueryProfile::foreman() const {
  return foreman_ != NULL ? *foreman_ : *default_instance_->foreman_;
}
inline ::exec::DrillbitEndpoint* QueryProfile::mutable_foreman() {
  set_has_foreman();
  if (foreman_ == NULL) foreman_ = new ::exec::DrillbitEndpoint;
  return foreman_;
}
inline ::exec::DrillbitEndpoint* QueryProfile::release_foreman() {
  clear_has_foreman();
  ::exec::DrillbitEndpoint* temp = foreman_;
  foreman_ = NULL;
  return temp;
}
inline void QueryProfile::set_allocated_foreman(::exec::DrillbitEndpoint* foreman) {
  delete foreman_;
  foreman_ = foreman;
  if (foreman) {
    set_has_foreman();
  } else {
    clear_has_foreman();
  }
}

// optional .exec.shared.QueryResult.QueryState state = 8;
inline bool QueryProfile::has_state() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void QueryProfile::set_has_state() {
  _has_bits_[0] |= 0x00000080u;
}
inline void QueryProfile::clear_has_state() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void QueryProfile::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::exec::shared::QueryResult_QueryState QueryProfile::state() const {
  return static_cast< ::exec::shared::QueryResult_QueryState >(state_);
}
inline void QueryProfile::set_state(::exec::shared::QueryResult_QueryState value) {
  assert(::exec::shared::QueryResult_QueryState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional int32 total_fragments = 9;
inline bool QueryProfile::has_total_fragments() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void QueryProfile::set_has_total_fragments() {
  _has_bits_[0] |= 0x00000100u;
}
inline void QueryProfile::clear_has_total_fragments() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void QueryProfile::clear_total_fragments() {
  total_fragments_ = 0;
  clear_has_total_fragments();
}
inline ::google::protobuf::int32 QueryProfile::total_fragments() const {
  return total_fragments_;
}
inline void QueryProfile::set_total_fragments(::google::protobuf::int32 value) {
  set_has_total_fragments();
  total_fragments_ = value;
}

// optional int32 finished_fragments = 10;
inline bool QueryProfile::has_finished_fragments() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void QueryProfile::set_has_finished_fragments() {
  _has_bits_[0] |= 0x00000200u;
}
inline void QueryProfile::clear_has_finished_fragments() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void QueryProfile::clear_finished_fragments() {
  finished_fragments_ = 0;
  clear_has_finished_fragments();
}
inline ::google::protobuf::int32 QueryProfile::finished_fragments() const {
  return finished_fragments_;
}
inline void QueryProfile::set_finished_fragments(::google::protobuf::int32 value) {
  set_has_finished_fragments();
  finished_fragments_ = value;
}

// repeated .exec.shared.MajorFragmentProfile fragment_profile = 11;
inline int QueryProfile::fragment_profile_size() const {
  return fragment_profile_.size();
}
inline void QueryProfile::clear_fragment_profile() {
  fragment_profile_.Clear();
}
inline const ::exec::shared::MajorFragmentProfile& QueryProfile::fragment_profile(int index) const {
  return fragment_profile_.Get(index);
}
inline ::exec::shared::MajorFragmentProfile* QueryProfile::mutable_fragment_profile(int index) {
  return fragment_profile_.Mutable(index);
}
inline ::exec::shared::MajorFragmentProfile* QueryProfile::add_fragment_profile() {
  return fragment_profile_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::shared::MajorFragmentProfile >&
QueryProfile::fragment_profile() const {
  return fragment_profile_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::shared::MajorFragmentProfile >*
QueryProfile::mutable_fragment_profile() {
  return &fragment_profile_;
}

// optional string user = 12 [default = "-"];
inline bool QueryProfile::has_user() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void QueryProfile::set_has_user() {
  _has_bits_[0] |= 0x00000800u;
}
inline void QueryProfile::clear_has_user() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void QueryProfile::clear_user() {
  if (user_ != _default_user_) {
    user_->assign(*_default_user_);
  }
  clear_has_user();
}
inline const ::std::string& QueryProfile::user() const {
  return *user_;
}
inline void QueryProfile::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == _default_user_) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void QueryProfile::set_user(const char* value) {
  set_has_user();
  if (user_ == _default_user_) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void QueryProfile::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == _default_user_) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryProfile::mutable_user() {
  set_has_user();
  if (user_ == _default_user_) {
    user_ = new ::std::string(*_default_user_);
  }
  return user_;
}
inline ::std::string* QueryProfile::release_user() {
  clear_has_user();
  if (user_ == _default_user_) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(_default_user_);
    return temp;
  }
}
inline void QueryProfile::set_allocated_user(::std::string* user) {
  if (user_ != _default_user_) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(_default_user_);
  }
}

// optional string error = 13;
inline bool QueryProfile::has_error() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void QueryProfile::set_has_error() {
  _has_bits_[0] |= 0x00001000u;
}
inline void QueryProfile::clear_has_error() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void QueryProfile::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& QueryProfile::error() const {
  return *error_;
}
inline void QueryProfile::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void QueryProfile::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void QueryProfile::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryProfile::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* QueryProfile::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryProfile::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string verboseError = 14;
inline bool QueryProfile::has_verboseerror() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void QueryProfile::set_has_verboseerror() {
  _has_bits_[0] |= 0x00002000u;
}
inline void QueryProfile::clear_has_verboseerror() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void QueryProfile::clear_verboseerror() {
  if (verboseerror_ != &::google::protobuf::internal::kEmptyString) {
    verboseerror_->clear();
  }
  clear_has_verboseerror();
}
inline const ::std::string& QueryProfile::verboseerror() const {
  return *verboseerror_;
}
inline void QueryProfile::set_verboseerror(const ::std::string& value) {
  set_has_verboseerror();
  if (verboseerror_ == &::google::protobuf::internal::kEmptyString) {
    verboseerror_ = new ::std::string;
  }
  verboseerror_->assign(value);
}
inline void QueryProfile::set_verboseerror(const char* value) {
  set_has_verboseerror();
  if (verboseerror_ == &::google::protobuf::internal::kEmptyString) {
    verboseerror_ = new ::std::string;
  }
  verboseerror_->assign(value);
}
inline void QueryProfile::set_verboseerror(const char* value, size_t size) {
  set_has_verboseerror();
  if (verboseerror_ == &::google::protobuf::internal::kEmptyString) {
    verboseerror_ = new ::std::string;
  }
  verboseerror_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryProfile::mutable_verboseerror() {
  set_has_verboseerror();
  if (verboseerror_ == &::google::protobuf::internal::kEmptyString) {
    verboseerror_ = new ::std::string;
  }
  return verboseerror_;
}
inline ::std::string* QueryProfile::release_verboseerror() {
  clear_has_verboseerror();
  if (verboseerror_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verboseerror_;
    verboseerror_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryProfile::set_allocated_verboseerror(::std::string* verboseerror) {
  if (verboseerror_ != &::google::protobuf::internal::kEmptyString) {
    delete verboseerror_;
  }
  if (verboseerror) {
    set_has_verboseerror();
    verboseerror_ = verboseerror;
  } else {
    clear_has_verboseerror();
    verboseerror_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string error_id = 15;
inline bool QueryProfile::has_error_id() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void QueryProfile::set_has_error_id() {
  _has_bits_[0] |= 0x00004000u;
}
inline void QueryProfile::clear_has_error_id() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void QueryProfile::clear_error_id() {
  if (error_id_ != &::google::protobuf::internal::kEmptyString) {
    error_id_->clear();
  }
  clear_has_error_id();
}
inline const ::std::string& QueryProfile::error_id() const {
  return *error_id_;
}
inline void QueryProfile::set_error_id(const ::std::string& value) {
  set_has_error_id();
  if (error_id_ == &::google::protobuf::internal::kEmptyString) {
    error_id_ = new ::std::string;
  }
  error_id_->assign(value);
}
inline void QueryProfile::set_error_id(const char* value) {
  set_has_error_id();
  if (error_id_ == &::google::protobuf::internal::kEmptyString) {
    error_id_ = new ::std::string;
  }
  error_id_->assign(value);
}
inline void QueryProfile::set_error_id(const char* value, size_t size) {
  set_has_error_id();
  if (error_id_ == &::google::protobuf::internal::kEmptyString) {
    error_id_ = new ::std::string;
  }
  error_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryProfile::mutable_error_id() {
  set_has_error_id();
  if (error_id_ == &::google::protobuf::internal::kEmptyString) {
    error_id_ = new ::std::string;
  }
  return error_id_;
}
inline ::std::string* QueryProfile::release_error_id() {
  clear_has_error_id();
  if (error_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_id_;
    error_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryProfile::set_allocated_error_id(::std::string* error_id) {
  if (error_id_ != &::google::protobuf::internal::kEmptyString) {
    delete error_id_;
  }
  if (error_id) {
    set_has_error_id();
    error_id_ = error_id;
  } else {
    clear_has_error_id();
    error_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string error_node = 16;
inline bool QueryProfile::has_error_node() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void QueryProfile::set_has_error_node() {
  _has_bits_[0] |= 0x00008000u;
}
inline void QueryProfile::clear_has_error_node() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void QueryProfile::clear_error_node() {
  if (error_node_ != &::google::protobuf::internal::kEmptyString) {
    error_node_->clear();
  }
  clear_has_error_node();
}
inline const ::std::string& QueryProfile::error_node() const {
  return *error_node_;
}
inline void QueryProfile::set_error_node(const ::std::string& value) {
  set_has_error_node();
  if (error_node_ == &::google::protobuf::internal::kEmptyString) {
    error_node_ = new ::std::string;
  }
  error_node_->assign(value);
}
inline void QueryProfile::set_error_node(const char* value) {
  set_has_error_node();
  if (error_node_ == &::google::protobuf::internal::kEmptyString) {
    error_node_ = new ::std::string;
  }
  error_node_->assign(value);
}
inline void QueryProfile::set_error_node(const char* value, size_t size) {
  set_has_error_node();
  if (error_node_ == &::google::protobuf::internal::kEmptyString) {
    error_node_ = new ::std::string;
  }
  error_node_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryProfile::mutable_error_node() {
  set_has_error_node();
  if (error_node_ == &::google::protobuf::internal::kEmptyString) {
    error_node_ = new ::std::string;
  }
  return error_node_;
}
inline ::std::string* QueryProfile::release_error_node() {
  clear_has_error_node();
  if (error_node_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_node_;
    error_node_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryProfile::set_allocated_error_node(::std::string* error_node) {
  if (error_node_ != &::google::protobuf::internal::kEmptyString) {
    delete error_node_;
  }
  if (error_node) {
    set_has_error_node();
    error_node_ = error_node;
  } else {
    clear_has_error_node();
    error_node_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MajorFragmentProfile

// optional int32 major_fragment_id = 1;
inline bool MajorFragmentProfile::has_major_fragment_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MajorFragmentProfile::set_has_major_fragment_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MajorFragmentProfile::clear_has_major_fragment_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MajorFragmentProfile::clear_major_fragment_id() {
  major_fragment_id_ = 0;
  clear_has_major_fragment_id();
}
inline ::google::protobuf::int32 MajorFragmentProfile::major_fragment_id() const {
  return major_fragment_id_;
}
inline void MajorFragmentProfile::set_major_fragment_id(::google::protobuf::int32 value) {
  set_has_major_fragment_id();
  major_fragment_id_ = value;
}

// repeated .exec.shared.MinorFragmentProfile minor_fragment_profile = 2;
inline int MajorFragmentProfile::minor_fragment_profile_size() const {
  return minor_fragment_profile_.size();
}
inline void MajorFragmentProfile::clear_minor_fragment_profile() {
  minor_fragment_profile_.Clear();
}
inline const ::exec::shared::MinorFragmentProfile& MajorFragmentProfile::minor_fragment_profile(int index) const {
  return minor_fragment_profile_.Get(index);
}
inline ::exec::shared::MinorFragmentProfile* MajorFragmentProfile::mutable_minor_fragment_profile(int index) {
  return minor_fragment_profile_.Mutable(index);
}
inline ::exec::shared::MinorFragmentProfile* MajorFragmentProfile::add_minor_fragment_profile() {
  return minor_fragment_profile_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::shared::MinorFragmentProfile >&
MajorFragmentProfile::minor_fragment_profile() const {
  return minor_fragment_profile_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::shared::MinorFragmentProfile >*
MajorFragmentProfile::mutable_minor_fragment_profile() {
  return &minor_fragment_profile_;
}

// -------------------------------------------------------------------

// MinorFragmentProfile

// optional .exec.shared.FragmentState state = 1;
inline bool MinorFragmentProfile::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MinorFragmentProfile::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MinorFragmentProfile::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MinorFragmentProfile::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::exec::shared::FragmentState MinorFragmentProfile::state() const {
  return static_cast< ::exec::shared::FragmentState >(state_);
}
inline void MinorFragmentProfile::set_state(::exec::shared::FragmentState value) {
  assert(::exec::shared::FragmentState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional .exec.shared.DrillPBError error = 2;
inline bool MinorFragmentProfile::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MinorFragmentProfile::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MinorFragmentProfile::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MinorFragmentProfile::clear_error() {
  if (error_ != NULL) error_->::exec::shared::DrillPBError::Clear();
  clear_has_error();
}
inline const ::exec::shared::DrillPBError& MinorFragmentProfile::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::exec::shared::DrillPBError* MinorFragmentProfile::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::exec::shared::DrillPBError;
  return error_;
}
inline ::exec::shared::DrillPBError* MinorFragmentProfile::release_error() {
  clear_has_error();
  ::exec::shared::DrillPBError* temp = error_;
  error_ = NULL;
  return temp;
}
inline void MinorFragmentProfile::set_allocated_error(::exec::shared::DrillPBError* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
}

// optional int32 minor_fragment_id = 3;
inline bool MinorFragmentProfile::has_minor_fragment_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MinorFragmentProfile::set_has_minor_fragment_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MinorFragmentProfile::clear_has_minor_fragment_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MinorFragmentProfile::clear_minor_fragment_id() {
  minor_fragment_id_ = 0;
  clear_has_minor_fragment_id();
}
inline ::google::protobuf::int32 MinorFragmentProfile::minor_fragment_id() const {
  return minor_fragment_id_;
}
inline void MinorFragmentProfile::set_minor_fragment_id(::google::protobuf::int32 value) {
  set_has_minor_fragment_id();
  minor_fragment_id_ = value;
}

// repeated .exec.shared.OperatorProfile operator_profile = 4;
inline int MinorFragmentProfile::operator_profile_size() const {
  return operator_profile_.size();
}
inline void MinorFragmentProfile::clear_operator_profile() {
  operator_profile_.Clear();
}
inline const ::exec::shared::OperatorProfile& MinorFragmentProfile::operator_profile(int index) const {
  return operator_profile_.Get(index);
}
inline ::exec::shared::OperatorProfile* MinorFragmentProfile::mutable_operator_profile(int index) {
  return operator_profile_.Mutable(index);
}
inline ::exec::shared::OperatorProfile* MinorFragmentProfile::add_operator_profile() {
  return operator_profile_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::shared::OperatorProfile >&
MinorFragmentProfile::operator_profile() const {
  return operator_profile_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::shared::OperatorProfile >*
MinorFragmentProfile::mutable_operator_profile() {
  return &operator_profile_;
}

// optional int64 start_time = 5;
inline bool MinorFragmentProfile::has_start_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MinorFragmentProfile::set_has_start_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MinorFragmentProfile::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MinorFragmentProfile::clear_start_time() {
  start_time_ = GOOGLE_LONGLONG(0);
  clear_has_start_time();
}
inline ::google::protobuf::int64 MinorFragmentProfile::start_time() const {
  return start_time_;
}
inline void MinorFragmentProfile::set_start_time(::google::protobuf::int64 value) {
  set_has_start_time();
  start_time_ = value;
}

// optional int64 end_time = 6;
inline bool MinorFragmentProfile::has_end_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MinorFragmentProfile::set_has_end_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MinorFragmentProfile::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MinorFragmentProfile::clear_end_time() {
  end_time_ = GOOGLE_LONGLONG(0);
  clear_has_end_time();
}
inline ::google::protobuf::int64 MinorFragmentProfile::end_time() const {
  return end_time_;
}
inline void MinorFragmentProfile::set_end_time(::google::protobuf::int64 value) {
  set_has_end_time();
  end_time_ = value;
}

// optional int64 memory_used = 7;
inline bool MinorFragmentProfile::has_memory_used() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MinorFragmentProfile::set_has_memory_used() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MinorFragmentProfile::clear_has_memory_used() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MinorFragmentProfile::clear_memory_used() {
  memory_used_ = GOOGLE_LONGLONG(0);
  clear_has_memory_used();
}
inline ::google::protobuf::int64 MinorFragmentProfile::memory_used() const {
  return memory_used_;
}
inline void MinorFragmentProfile::set_memory_used(::google::protobuf::int64 value) {
  set_has_memory_used();
  memory_used_ = value;
}

// optional int64 max_memory_used = 8;
inline bool MinorFragmentProfile::has_max_memory_used() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MinorFragmentProfile::set_has_max_memory_used() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MinorFragmentProfile::clear_has_max_memory_used() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MinorFragmentProfile::clear_max_memory_used() {
  max_memory_used_ = GOOGLE_LONGLONG(0);
  clear_has_max_memory_used();
}
inline ::google::protobuf::int64 MinorFragmentProfile::max_memory_used() const {
  return max_memory_used_;
}
inline void MinorFragmentProfile::set_max_memory_used(::google::protobuf::int64 value) {
  set_has_max_memory_used();
  max_memory_used_ = value;
}

// optional .exec.DrillbitEndpoint endpoint = 9;
inline bool MinorFragmentProfile::has_endpoint() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MinorFragmentProfile::set_has_endpoint() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MinorFragmentProfile::clear_has_endpoint() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MinorFragmentProfile::clear_endpoint() {
  if (endpoint_ != NULL) endpoint_->::exec::DrillbitEndpoint::Clear();
  clear_has_endpoint();
}
inline const ::exec::DrillbitEndpoint& MinorFragmentProfile::endpoint() const {
  return endpoint_ != NULL ? *endpoint_ : *default_instance_->endpoint_;
}
inline ::exec::DrillbitEndpoint* MinorFragmentProfile::mutable_endpoint() {
  set_has_endpoint();
  if (endpoint_ == NULL) endpoint_ = new ::exec::DrillbitEndpoint;
  return endpoint_;
}
inline ::exec::DrillbitEndpoint* MinorFragmentProfile::release_endpoint() {
  clear_has_endpoint();
  ::exec::DrillbitEndpoint* temp = endpoint_;
  endpoint_ = NULL;
  return temp;
}
inline void MinorFragmentProfile::set_allocated_endpoint(::exec::DrillbitEndpoint* endpoint) {
  delete endpoint_;
  endpoint_ = endpoint;
  if (endpoint) {
    set_has_endpoint();
  } else {
    clear_has_endpoint();
  }
}

// optional int64 last_update = 10;
inline bool MinorFragmentProfile::has_last_update() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MinorFragmentProfile::set_has_last_update() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MinorFragmentProfile::clear_has_last_update() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MinorFragmentProfile::clear_last_update() {
  last_update_ = GOOGLE_LONGLONG(0);
  clear_has_last_update();
}
inline ::google::protobuf::int64 MinorFragmentProfile::last_update() const {
  return last_update_;
}
inline void MinorFragmentProfile::set_last_update(::google::protobuf::int64 value) {
  set_has_last_update();
  last_update_ = value;
}

// optional int64 last_progress = 11;
inline bool MinorFragmentProfile::has_last_progress() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MinorFragmentProfile::set_has_last_progress() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MinorFragmentProfile::clear_has_last_progress() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MinorFragmentProfile::clear_last_progress() {
  last_progress_ = GOOGLE_LONGLONG(0);
  clear_has_last_progress();
}
inline ::google::protobuf::int64 MinorFragmentProfile::last_progress() const {
  return last_progress_;
}
inline void MinorFragmentProfile::set_last_progress(::google::protobuf::int64 value) {
  set_has_last_progress();
  last_progress_ = value;
}

// -------------------------------------------------------------------

// OperatorProfile

// repeated .exec.shared.StreamProfile input_profile = 1;
inline int OperatorProfile::input_profile_size() const {
  return input_profile_.size();
}
inline void OperatorProfile::clear_input_profile() {
  input_profile_.Clear();
}
inline const ::exec::shared::StreamProfile& OperatorProfile::input_profile(int index) const {
  return input_profile_.Get(index);
}
inline ::exec::shared::StreamProfile* OperatorProfile::mutable_input_profile(int index) {
  return input_profile_.Mutable(index);
}
inline ::exec::shared::StreamProfile* OperatorProfile::add_input_profile() {
  return input_profile_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::shared::StreamProfile >&
OperatorProfile::input_profile() const {
  return input_profile_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::shared::StreamProfile >*
OperatorProfile::mutable_input_profile() {
  return &input_profile_;
}

// optional int32 operator_id = 3;
inline bool OperatorProfile::has_operator_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperatorProfile::set_has_operator_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperatorProfile::clear_has_operator_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperatorProfile::clear_operator_id() {
  operator_id_ = 0;
  clear_has_operator_id();
}
inline ::google::protobuf::int32 OperatorProfile::operator_id() const {
  return operator_id_;
}
inline void OperatorProfile::set_operator_id(::google::protobuf::int32 value) {
  set_has_operator_id();
  operator_id_ = value;
}

// optional int32 operator_type = 4;
inline bool OperatorProfile::has_operator_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperatorProfile::set_has_operator_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperatorProfile::clear_has_operator_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperatorProfile::clear_operator_type() {
  operator_type_ = 0;
  clear_has_operator_type();
}
inline ::google::protobuf::int32 OperatorProfile::operator_type() const {
  return operator_type_;
}
inline void OperatorProfile::set_operator_type(::google::protobuf::int32 value) {
  set_has_operator_type();
  operator_type_ = value;
}

// optional int64 setup_nanos = 5;
inline bool OperatorProfile::has_setup_nanos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OperatorProfile::set_has_setup_nanos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OperatorProfile::clear_has_setup_nanos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OperatorProfile::clear_setup_nanos() {
  setup_nanos_ = GOOGLE_LONGLONG(0);
  clear_has_setup_nanos();
}
inline ::google::protobuf::int64 OperatorProfile::setup_nanos() const {
  return setup_nanos_;
}
inline void OperatorProfile::set_setup_nanos(::google::protobuf::int64 value) {
  set_has_setup_nanos();
  setup_nanos_ = value;
}

// optional int64 process_nanos = 6;
inline bool OperatorProfile::has_process_nanos() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OperatorProfile::set_has_process_nanos() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OperatorProfile::clear_has_process_nanos() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OperatorProfile::clear_process_nanos() {
  process_nanos_ = GOOGLE_LONGLONG(0);
  clear_has_process_nanos();
}
inline ::google::protobuf::int64 OperatorProfile::process_nanos() const {
  return process_nanos_;
}
inline void OperatorProfile::set_process_nanos(::google::protobuf::int64 value) {
  set_has_process_nanos();
  process_nanos_ = value;
}

// optional int64 peak_local_memory_allocated = 7;
inline bool OperatorProfile::has_peak_local_memory_allocated() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OperatorProfile::set_has_peak_local_memory_allocated() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OperatorProfile::clear_has_peak_local_memory_allocated() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OperatorProfile::clear_peak_local_memory_allocated() {
  peak_local_memory_allocated_ = GOOGLE_LONGLONG(0);
  clear_has_peak_local_memory_allocated();
}
inline ::google::protobuf::int64 OperatorProfile::peak_local_memory_allocated() const {
  return peak_local_memory_allocated_;
}
inline void OperatorProfile::set_peak_local_memory_allocated(::google::protobuf::int64 value) {
  set_has_peak_local_memory_allocated();
  peak_local_memory_allocated_ = value;
}

// repeated .exec.shared.MetricValue metric = 8;
inline int OperatorProfile::metric_size() const {
  return metric_.size();
}
inline void OperatorProfile::clear_metric() {
  metric_.Clear();
}
inline const ::exec::shared::MetricValue& OperatorProfile::metric(int index) const {
  return metric_.Get(index);
}
inline ::exec::shared::MetricValue* OperatorProfile::mutable_metric(int index) {
  return metric_.Mutable(index);
}
inline ::exec::shared::MetricValue* OperatorProfile::add_metric() {
  return metric_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::exec::shared::MetricValue >&
OperatorProfile::metric() const {
  return metric_;
}
inline ::google::protobuf::RepeatedPtrField< ::exec::shared::MetricValue >*
OperatorProfile::mutable_metric() {
  return &metric_;
}

// optional int64 wait_nanos = 9;
inline bool OperatorProfile::has_wait_nanos() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OperatorProfile::set_has_wait_nanos() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OperatorProfile::clear_has_wait_nanos() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OperatorProfile::clear_wait_nanos() {
  wait_nanos_ = GOOGLE_LONGLONG(0);
  clear_has_wait_nanos();
}
inline ::google::protobuf::int64 OperatorProfile::wait_nanos() const {
  return wait_nanos_;
}
inline void OperatorProfile::set_wait_nanos(::google::protobuf::int64 value) {
  set_has_wait_nanos();
  wait_nanos_ = value;
}

// -------------------------------------------------------------------

// StreamProfile

// optional int64 records = 1;
inline bool StreamProfile::has_records() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreamProfile::set_has_records() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreamProfile::clear_has_records() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreamProfile::clear_records() {
  records_ = GOOGLE_LONGLONG(0);
  clear_has_records();
}
inline ::google::protobuf::int64 StreamProfile::records() const {
  return records_;
}
inline void StreamProfile::set_records(::google::protobuf::int64 value) {
  set_has_records();
  records_ = value;
}

// optional int64 batches = 2;
inline bool StreamProfile::has_batches() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StreamProfile::set_has_batches() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StreamProfile::clear_has_batches() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StreamProfile::clear_batches() {
  batches_ = GOOGLE_LONGLONG(0);
  clear_has_batches();
}
inline ::google::protobuf::int64 StreamProfile::batches() const {
  return batches_;
}
inline void StreamProfile::set_batches(::google::protobuf::int64 value) {
  set_has_batches();
  batches_ = value;
}

// optional int64 schemas = 3;
inline bool StreamProfile::has_schemas() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StreamProfile::set_has_schemas() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StreamProfile::clear_has_schemas() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StreamProfile::clear_schemas() {
  schemas_ = GOOGLE_LONGLONG(0);
  clear_has_schemas();
}
inline ::google::protobuf::int64 StreamProfile::schemas() const {
  return schemas_;
}
inline void StreamProfile::set_schemas(::google::protobuf::int64 value) {
  set_has_schemas();
  schemas_ = value;
}

// -------------------------------------------------------------------

// MetricValue

// optional int32 metric_id = 1;
inline bool MetricValue::has_metric_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetricValue::set_has_metric_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetricValue::clear_has_metric_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetricValue::clear_metric_id() {
  metric_id_ = 0;
  clear_has_metric_id();
}
inline ::google::protobuf::int32 MetricValue::metric_id() const {
  return metric_id_;
}
inline void MetricValue::set_metric_id(::google::protobuf::int32 value) {
  set_has_metric_id();
  metric_id_ = value;
}

// optional int64 long_value = 2;
inline bool MetricValue::has_long_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MetricValue::set_has_long_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MetricValue::clear_has_long_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MetricValue::clear_long_value() {
  long_value_ = GOOGLE_LONGLONG(0);
  clear_has_long_value();
}
inline ::google::protobuf::int64 MetricValue::long_value() const {
  return long_value_;
}
inline void MetricValue::set_long_value(::google::protobuf::int64 value) {
  set_has_long_value();
  long_value_ = value;
}

// optional double double_value = 3;
inline bool MetricValue::has_double_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MetricValue::set_has_double_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MetricValue::clear_has_double_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MetricValue::clear_double_value() {
  double_value_ = 0;
  clear_has_double_value();
}
inline double MetricValue::double_value() const {
  return double_value_;
}
inline void MetricValue::set_double_value(double value) {
  set_has_double_value();
  double_value_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace shared
}  // namespace exec

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::shared::DrillPBError_ErrorType>() {
  return ::exec::shared::DrillPBError_ErrorType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::shared::NamePart_Type>() {
  return ::exec::shared::NamePart_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::shared::QueryResult_QueryState>() {
  return ::exec::shared::QueryResult_QueryState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::shared::RpcChannel>() {
  return ::exec::shared::RpcChannel_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::shared::QueryType>() {
  return ::exec::shared::QueryType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::shared::FragmentState>() {
  return ::exec::shared::FragmentState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exec::shared::CoreOperatorType>() {
  return ::exec::shared::CoreOperatorType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_UserBitShared_2eproto__INCLUDED
