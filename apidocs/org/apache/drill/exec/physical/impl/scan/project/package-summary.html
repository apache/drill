<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_232) on Tue Dec 24 19:10:21 EET 2019 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>org.apache.drill.exec.physical.impl.scan.project (Apache Drill Root POM 1.17.0 API)</title>
<meta name="date" content="2019-12-24">
<link rel="stylesheet" type="text/css" href="../../../../../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="org.apache.drill.exec.physical.impl.scan.project (Apache Drill Root POM 1.17.0 API)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/framework/package-summary.html">Prev&nbsp;Package</a></li>
<li><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/projSet/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../../../../index.html?org/apache/drill/exec/physical/impl/scan/project/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 title="Package" class="title">Package&nbsp;org.apache.drill.exec.physical.impl.scan.project</h1>
<div class="docSummary">
<div class="block">Provides run-time semantic analysis of the projection list for the
 scan operator.</div>
</div>
<p>See:&nbsp;<a href="#package.description">Description</a></p>
</div>
<div class="contentContainer">
<ul class="blockList">
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Interface Summary table, listing interfaces, and an explanation">
<caption><span>Interface Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Interface</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ColumnProjection.html" title="interface in org.apache.drill.exec.physical.impl.scan.project">ColumnProjection</a></td>
<td class="colLast">
<div class="block">Core interface for a projected column.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ConstantColumnLoader.ConstantColumnSpec.html" title="interface in org.apache.drill.exec.physical.impl.scan.project">ConstantColumnLoader.ConstantColumnSpec</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/MetadataManager.html" title="interface in org.apache.drill.exec.physical.impl.scan.project">MetadataManager</a></td>
<td class="colLast">
<div class="block">Queries can contain a wildcard (*), table columns, or special
 system-defined columns (the file metadata columns AKA implicit
 columns, the `columns` column of CSV, etc.).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/NullColumnLoader.NullColumnSpec.html" title="interface in org.apache.drill.exec.physical.impl.scan.project">NullColumnLoader.NullColumnSpec</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ReaderLevelProjection.ReaderProjectionResolver.html" title="interface in org.apache.drill.exec.physical.impl.scan.project">ReaderLevelProjection.ReaderProjectionResolver</a></td>
<td class="colLast">
<div class="block">Reader-level projection is customizable.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ScanLevelProjection.ScanProjectionParser.html" title="interface in org.apache.drill.exec.physical.impl.scan.project">ScanLevelProjection.ScanProjectionParser</a></td>
<td class="colLast">
<div class="block">Interface for add-on parsers, avoids the need to create
 a single, tightly-coupled parser for all types of columns.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/VectorSource.html" title="interface in org.apache.drill.exec.physical.impl.scan.project">VectorSource</a></td>
<td class="colLast">
<div class="block">Generic mechanism for retrieving vectors from a source tuple when
 projecting columns to the output tuple.</div>
</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Class Summary table, listing classes, and an explanation">
<caption><span>Class Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/AbstractUnresolvedColumn.html" title="class in org.apache.drill.exec.physical.impl.scan.project">AbstractUnresolvedColumn</a></td>
<td class="colLast">
<div class="block">Represents a projected column that has not yet been bound to a
 table column, special column or a null column.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/AbstractUnresolvedColumn.UnresolvedColumn.html" title="class in org.apache.drill.exec.physical.impl.scan.project">AbstractUnresolvedColumn.UnresolvedColumn</a></td>
<td class="colLast">
<div class="block">Represents an unresolved table column to be provided by the
 reader (or filled in with nulls.) May be associated with
 a provided schema column.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/AbstractUnresolvedColumn.UnresolvedWildcardColumn.html" title="class in org.apache.drill.exec.physical.impl.scan.project">AbstractUnresolvedColumn.UnresolvedWildcardColumn</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ConstantColumnLoader.html" title="class in org.apache.drill.exec.physical.impl.scan.project">ConstantColumnLoader</a></td>
<td class="colLast">
<div class="block">Populate metadata columns either file metadata (AKA "implicit
 columns") or directory metadata (AKA "partition columns.") In both
 cases the column type is nullable Varchar and the column value
 is predefined by the projection planner; this class just copies
 that value into each row.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ExplicitSchemaProjection.html" title="class in org.apache.drill.exec.physical.impl.scan.project">ExplicitSchemaProjection</a></td>
<td class="colLast">
<div class="block">Perform a schema projection for the case of an explicit list of
 projected columns.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/NoOpMetadataManager.html" title="class in org.apache.drill.exec.physical.impl.scan.project">NoOpMetadataManager</a></td>
<td class="colLast">
<div class="block">Do-nothing implementation of the metadata manager.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/NullColumnBuilder.html" title="class in org.apache.drill.exec.physical.impl.scan.project">NullColumnBuilder</a></td>
<td class="colLast">
<div class="block">Manages null columns by creating a null column loader for each
 set of non-empty null columns.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/NullColumnBuilder.NullBuilderBuilder.html" title="class in org.apache.drill.exec.physical.impl.scan.project">NullColumnBuilder.NullBuilderBuilder</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/NullColumnLoader.html" title="class in org.apache.drill.exec.physical.impl.scan.project">NullColumnLoader</a></td>
<td class="colLast">
<div class="block">Create and populate null columns for the case in which a SELECT statement
 refers to columns that do not exist in the actual table.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ReaderLevelProjection.html" title="class in org.apache.drill.exec.physical.impl.scan.project">ReaderLevelProjection</a></td>
<td class="colLast">
<div class="block">Computes the full output schema given a table (or batch)
 schema.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ReaderSchemaOrchestrator.html" title="class in org.apache.drill.exec.physical.impl.scan.project">ReaderSchemaOrchestrator</a></td>
<td class="colLast">
<div class="block">Orchestrates projection tasks for a single reader within the set that the
 scan operator manages.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ResolvedColumn.html" title="class in org.apache.drill.exec.physical.impl.scan.project">ResolvedColumn</a></td>
<td class="colLast">
<div class="block">A resolved column has a name, and a specification for how to project
 data from a source vector to a vector in the final output container.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ResolvedMapColumn.html" title="class in org.apache.drill.exec.physical.impl.scan.project">ResolvedMapColumn</a></td>
<td class="colLast">
<div class="block">Represents a column which is implicitly a map (because it has children
 in the project list), but which does not match any column in the table.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ResolvedNullColumn.html" title="class in org.apache.drill.exec.physical.impl.scan.project">ResolvedNullColumn</a></td>
<td class="colLast">
<div class="block">Projected column that serves as both a resolved column (provides projection
 mapping) and a null column spec (provides the information needed to create
 the required null vectors.)</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ResolvedTableColumn.html" title="class in org.apache.drill.exec.physical.impl.scan.project">ResolvedTableColumn</a></td>
<td class="colLast">
<div class="block">Column that matches one provided by the table.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ResolvedTuple.html" title="class in org.apache.drill.exec.physical.impl.scan.project">ResolvedTuple</a></td>
<td class="colLast">
<div class="block">Drill rows are made up of a tree of tuples, with the row being the root
 tuple.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ResolvedTuple.ResolvedMap.html" title="class in org.apache.drill.exec.physical.impl.scan.project">ResolvedTuple.ResolvedMap</a></td>
<td class="colLast">
<div class="block">Represents a map implied by the project list, whether or not the map
 actually appears in the table schema.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ResolvedTuple.ResolvedMapArray.html" title="class in org.apache.drill.exec.physical.impl.scan.project">ResolvedTuple.ResolvedMapArray</a></td>
<td class="colLast">
<div class="block">Represents a map tuple (not the map column, rather the value of the
 map column.) When projecting, we create a new repeated map vector,
 but share the offsets vector from input to output.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ResolvedTuple.ResolvedRow.html" title="class in org.apache.drill.exec.physical.impl.scan.project">ResolvedTuple.ResolvedRow</a></td>
<td class="colLast">
<div class="block">Represents the top-level tuple which is projected to a
 vector container.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ResolvedTuple.ResolvedSingleMap.html" title="class in org.apache.drill.exec.physical.impl.scan.project">ResolvedTuple.ResolvedSingleMap</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ScanLevelProjection.html" title="class in org.apache.drill.exec.physical.impl.scan.project">ScanLevelProjection</a></td>
<td class="colLast">
<div class="block">Parses and analyzes the projection list passed to the scanner.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ScanLevelProjection.Builder.html" title="class in org.apache.drill.exec.physical.impl.scan.project">ScanLevelProjection.Builder</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ScanSchemaOrchestrator.html" title="class in org.apache.drill.exec.physical.impl.scan.project">ScanSchemaOrchestrator</a></td>
<td class="colLast">
<div class="block">Performs projection of a record reader, along with a set of static
 columns, to produce the final "public" result set (record batch)
 for the scan operator.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ScanSchemaOrchestrator.ScanOrchestratorBuilder.html" title="class in org.apache.drill.exec.physical.impl.scan.project">ScanSchemaOrchestrator.ScanOrchestratorBuilder</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ScanSchemaOrchestrator.ScanSchemaOptions.html" title="class in org.apache.drill.exec.physical.impl.scan.project">ScanSchemaOrchestrator.ScanSchemaOptions</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/SchemaSmoother.html" title="class in org.apache.drill.exec.physical.impl.scan.project">SchemaSmoother</a></td>
<td class="colLast">
<div class="block">Implements a "schema smoothing" algorithm.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/SmoothingProjection.html" title="class in org.apache.drill.exec.physical.impl.scan.project">SmoothingProjection</a></td>
<td class="colLast">
<div class="block">Resolve a table schema against the prior schema.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/StaticColumnLoader.html" title="class in org.apache.drill.exec.physical.impl.scan.project">StaticColumnLoader</a></td>
<td class="colLast">
<div class="block">Base class for columns that take values based on the
 reader, not individual rows.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/TestConstantColumnLoader.html" title="class in org.apache.drill.exec.physical.impl.scan.project">TestConstantColumnLoader</a></td>
<td class="colLast">
<div class="block">Drill allows file metadata columns (also called "implicit" columns.)
 These are columns that contain a long repeated sequences of the same
 values.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/TestNullColumnLoader.html" title="class in org.apache.drill.exec.physical.impl.scan.project">TestNullColumnLoader</a></td>
<td class="colLast">
<div class="block">Test the mechanism that handles all-null columns during projection.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/TestReaderLevelProjection.html" title="class in org.apache.drill.exec.physical.impl.scan.project">TestReaderLevelProjection</a></td>
<td class="colLast">
<div class="block">"Schema level projection" describes one side of the projection
 mechanism.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/TestRowBatchMerger.html" title="class in org.apache.drill.exec.physical.impl.scan.project">TestRowBatchMerger</a></td>
<td class="colLast">
<div class="block">Test the row batch merger by merging two batches.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/TestRowBatchMerger.RowSetSource.html" title="class in org.apache.drill.exec.physical.impl.scan.project">TestRowBatchMerger.RowSetSource</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/TestRowBatchMerger.TestProjection.html" title="class in org.apache.drill.exec.physical.impl.scan.project">TestRowBatchMerger.TestProjection</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/TestScanLevelProjection.html" title="class in org.apache.drill.exec.physical.impl.scan.project">TestScanLevelProjection</a></td>
<td class="colLast">
<div class="block">Test the level of projection done at the level of the scan as a whole;
 before knowledge of table "implicit" columns or the specific table schema.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/TestSchemaSmoothing.html" title="class in org.apache.drill.exec.physical.impl.scan.project">TestSchemaSmoothing</a></td>
<td class="colLast">
<div class="block">Tests schema smoothing at the schema projection level.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/WildcardProjection.html" title="class in org.apache.drill.exec.physical.impl.scan.project">WildcardProjection</a></td>
<td class="colLast">
<div class="block">Perform a wildcard projection.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/WildcardSchemaProjection.html" title="class in org.apache.drill.exec.physical.impl.scan.project">WildcardSchemaProjection</a></td>
<td class="colLast">
<div class="block">Perform a wildcard projection with an associated output schema.</div>
</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Enum Summary table, listing enums, and an explanation">
<caption><span>Enum Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Enum</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/ScanLevelProjection.ScanProjectionType.html" title="enum in org.apache.drill.exec.physical.impl.scan.project">ScanLevelProjection.ScanProjectionType</a></td>
<td class="colLast">
<div class="block">Identifies the kind of projection done for this scan.</div>
</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Exception Summary table, listing exceptions, and an explanation">
<caption><span>Exception Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Exception</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/SchemaSmoother.IncompatibleSchemaException.html" title="class in org.apache.drill.exec.physical.impl.scan.project">SchemaSmoother.IncompatibleSchemaException</a></td>
<td class="colLast">
<div class="block">Exception thrown if the prior schema is not compatible with the
 new table schema.</div>
</td>
</tr>
</tbody>
</table>
</li>
</ul>
<a name="package.description">
<!--   -->
</a>
<h2 title="Package org.apache.drill.exec.physical.impl.scan.project Description">Package org.apache.drill.exec.physical.impl.scan.project Description</h2>
<div class="block">Provides run-time semantic analysis of the projection list for the
 scan operator. The project list can include table columns and a
 variety of special columns. Requested columns can exist in the table,
 or may be "missing" with null values applied. The code here prepares
 a run-time projection plan based on the actual table schema.

 <h4>Overview</h4>

 The projection framework look at schema as a set of transforms:
 <p>
 <ul>
 <li>Scan level: physical plan projection list and optional provided
 schema information.</li>
 <li>File level: materializes implicit file and parition columns.</li>
 <li>Reader level: integrates the actual schema discovered by the
 reader with the scan-level projection list.</li>
 </ul>
 <p>
 Projection turns out to be a very complex operation in a schema-on-read
 system such as Drill. Provided schema helps resolve ambiguities inherent
 in schema-on-read, but at the cost of some additional complexity.

 <h4>Background</h4>

 The Scan-level projection holds the list of columns
 (or the wildcard) as requested by the user in the query. The planner
 determines which columns to project. In Drill, projection is speculative:
 it is a list of names which the planner hopes will appear in the data
 files. The reader must make up columns (the infamous nullable INT) when
 it turns out that no such column exists. Else, the reader must figure out
 the data type for any columns that does exist.
 <p>
 With the advent of provided schema in Drill 1.16, the scan level projection
 integrates that schema information with the projection list provided in
 the physical operator. If a schema is provided, then each scan-level
 column tracks the schema information for that column.
 <p>
 The scan-level projection also
 implements the special rules for a "strict" provided schema: if the operator
 projection list contains a wildcard, a schema is provided, and the schema
 is strict, then the scan level projection expands the wildcard into the
 set of columns in the provided schema. Doing so ensures that the scan
 output contains exactly those columns from the schema, even if the columns
 must be null or at a default value. (The result set loader does additional
 filtering as well.)
 <p>
 The scan project list defines the set of columns which the scan operator
 is obliged to send downstream. Ideally, the scan operator sends exactly the
 same schema (the project list with types filled in) for all batches. Since
 batches may come from different files, the scan operator is obligated to
 unify the schemas from those files (or blocks.)
 <p>
 Reader (file)-level projection occurs for each reader. A single scan
 may use multiple readers to read data. From the reader's perspective, it
 offers the schema it discovers in the file. The reader itself is rather
 inflexible: it must deal with the data it finds, of the type found in
 the data source.
 <p>
 The reader thus tells the result set loader that it has such-and-so schema.
 It does that either at open time (so-called "early" schema, such as for
 CSV, JDBC or Parquet) or as it discovers the columns (so-called "late"
 schema as in JSON.) Again, in each case, the data source schema is what
 it is; it can't be changed due to the wishes of the scan-level projection.
 <p>
 Readers obtain column schema from the file or data source. For example,
 a Parquet reader can obtain schema information
 from the Parquet headers. A JDBC reader obtains schema information from the
 returned schema. As noted above, we use the term "early schema" when type
 information is available at open time, before reading the first row of data.
 <p>
 By contrast eaders such as JSON and CSV are "late schema": they don't know the data
 schema until they read the file. This is true "schema on read." Further, for
 JSON, the data may change from one batch to the next as the reader "discovers"
 fields that did not appear in earlier batches. This requires some amount of
 "schema smoothing": the ability to preserve a consistent output schema even
 as the input schema jiggles around some.
 <p>
 Drill supports many kinds of data sources via plugins. The DFS plugin works
 with files in a distributed store such as HDFS. Such file-based readers
 add implicit file or partition columns. Since these columns are generic to
 all format plugins, they are factored out into a file scan framework which
 inserts the "implicit" columns separate from the reader-provided columns.

 <h4>Design</h4>

 This leads to a multi-stage merge operation. The result set loader is
 presented with each column one-by-one (either at open time or during read.)
 When a column is presented, the projection framework makes a number of
 decisions:
 <p>
 <ul>
 <li>Is the column projected? For example, if a query is <tt>SELECT a, b, c</tt>
 and the reader offers column <tt>d</tt>, then column d will not be projected.
 In the wildcard case, "special" columns will be omitted from the column
 expansion and will be unprojected.</li>
 <li>Is type conversion needed? If a schema is provided, and the type of the
 column requested in the provided schema differs from that offered by the
 reader, the framework can insert a type-conversion "shim", assuming that
 the framework knows how to do the conversion. Else, and error is raised.</li>
 <li>Is the column type and mode consistent with the projection list?
 Suppose the query is <tt>SELECT a, b[10], c.d</tt>. Column `a` matches
 any reader column. But, column `b` is valid only for an array (not a map
 and not a scalar.) Column `c` must be a map (or array of maps.) And so on.</li>
 </ul>
 <p>
 The result is a refined schema: the scan level schema with more information
 filled in. For Parquet, all projection information can be filled in. For
 CSV or JSON, we can only add file metadata information, but not yet the
 actual data schema.
 <p>
 Batch-level schema: once a reader reads actual data, it now knows
 exactly what it read. This is the "schema on read model." Thus, after reading
 a batch, any remaining uncertainty about the projected schema is removed.
 The actual data defined data types and so on.
 <p>
 The goal of this mechanism is to handle the above use cases cleanly, in a
 common set of classes, and to avoid the need for each reader to figure out
 all these issues for themselves (as was the case with earlier versions of
 Drill.)
 <p>
 Because these issues are complex, the code itself is complex. To make the
 code easier to manage, each bit of functionality is encapsulated in a
 distinct class. Classes combine via composition to create a "framework"
 suitable for each kind of reader: whether it be early or late schema,
 file-based or something else, etc.

 <h4>Nuances of Reader-Level Projection</h4>

 We've said that the scan-level projection identifies what the query
 <i>wants</i>. We've said that the reader identifies what the external
 data actually <i>is</i>. We've mentioned how we bridge between the
 two. Here we explore this in more detail.
 <p>
 Run-time schema resolution occurs at various stages:
 <p>
 <ul>
 <li>The per-column resolution identified earlier: matching types,
 type conversion, and so on.</li>
 <li>The reader provides some set of columns. We don't know which
 columns until the end of the first (or more generally, every) batch.
 Suppose the query wants <tt>SELECT a, b, c</tt> but the reader turns
 out to provide only `a` and `b`. On after the first batch do we
 realize that we need column `c` as a "null" column (of a type defined
 in the provided schema, specified by the plugin, or good-old nullable
 INT.)</li>
 <li>The result set loader will have created "dummy" columns for
 unprojected columns. The reader can still write to such columns
 (because they represent data in the file), but the associated column
 writer simply ignores the data. As a result, the result set loader
 should produce only a (possibly full) subset of projected columns.</li>
 <li>After each reader batch, the projection framework goes to work
 filling in implicit columns, and filling in missing columns. It is
 important to remember that this pass *must* be done *after* a batch
 is read since we don't now the columns that the reader can provided
 until after a batch is read.</li>
 <li>Some readers, such as JSON, can "change its mind" about the
 schema across batches. For example, the first batch may include
 only columns a and b. Later in the JSON file, the reader may
 discover column c. This means that the above post-batch analysis
 must be repeated each time the reader changes the schema. (The result
 set loader tracks schema changes for this purpose.)</li>
 <li>File schemas evolve. The same changes noted above can occur
 cross files. Maybe file 1 has column `x` as a BIGINT, while file 2
 has column 'x' as INT. A "smoothing" step attempts to avoid hard
 schema changes if they can be avoided. While smoothing is a clever
 idea, it only handles some cases. Provided schema is a more reliable
 solution (but is not yet widely deployed.)</li>
 </ul>

 <h4>Reader-Level Projection Set</h4>

 The Projection Set mechanism is designed to handle the increasing nuances
 of Drill run-time projection by providing a source of information about
 each column that the reader may discover:
 <ul>
 <li>Is the column projected?</li><ul>
   <li>If the query is explicit (<tt>SELECT a, b, c</tt>), is the column
   in the projection list?</li>
   <li>If the query is a wildcard (<tt>SELECT *</tt>), is the column
   marked as special (not included in the wildcard)?</li>
   <li>If the query is wildcard, and a strict schema is provided, is
   the column part of the provided schema?</li></ul></li>
 <li>Verify column is consistent with projection.</li>
 <li>Type conversion, if needed.</li>
 </ul>

 <h4>Projection Via Rewrites</h4>

 The core concept is one of successive refinement of the project
 list through a set of rewrites:
 <p>
 <ul>
 <li>Scan-level rewrite: convert <code>SchemaPath</code> entries into
 internal column nodes, tagging the nodes with the column type:
 wildcard, unresolved table column, or special columns (such as
 file metadata.) The scan-level rewrite is done once per scan
 operator.</li>
 <li>Reader-level rewrite: convert the internal column nodes into
 other internal nodes, leaving table column nodes unresolved. The
 typical use is to fill in metadata columns with information about a
 specific file.</li>
 <li>Schema-level rewrite: given the actual schema of a record batch,
 rewrite the reader-level projection to describe the final projection
 from incoming data to output container. This step fills in missing
 columns, expands wildcards, etc.</li>
 </ul>
 The following outlines the steps from scan plan to per-file data
 loading to producing the output batch. The center path is the
 projection metadata which turns into an actual output batch.
 <pre>
                   Scan Plan
                       |
                       v
               +--------------+
               | Project List |
               |    Parser    |
               +--------------+
                       |
                       v
                +------------+
                | Scan Level |     +----------------+
                | Projection | --->| Projection Set |
                +------------+     +----------------+
                       |                  |
                       v                  v
  +------+      +------------+     +------------+      +-----------+
  | File | ---> | File Level |     | Result Set | ---> | Data File |
  | Data |      | Projection |     |   Loader   | <--- |  Reader   |
  +------+      +------------+     +------------+      +-----------+
                       |                  |
                       v                  |
               +--------------+   Reader  |
               | Reader Level |   Schema  |
               |  Projection  | <---------+
               +--------------+           |
                       |                  |
                       v                  |
                  +--------+   Loaded     |
                  | Output |   Vectors    |
                  | Mapper | <------------+
                  +--------+
                       |
                       v
                 Output Batch
 </pre>
 <p>
 The left side can be thought of as the "what we want" description of the
 schema, with the right side being "what the reader actually discovered."
 <p>
 The output mapper includes mechanisms to populate implicit columns, create
 null columns, and to merge implicit, null and data columns, omitting
 unprojected data columns.
 <p>
 In all cases, projection must handle maps, which are a recursive structure
 much like a row. That is, Drill consists of nested tuples (the row and maps),
 each of which contains columns which can be maps. Thus, there is a set of
 alternating layers of tuples, columns, tuples, and so on until we get to leaf
 (non-map) columns. As a result, most of the above structures are in the form
 of tuple trees, requiring recursive algorithms to apply rules down through the
 nested layers of tuples.
 <p>
 The above mechanism is done at runtime, in each scan fragment. Since Drill is
 schema-on-read, and has no plan-time schema concept, run-time projection is
 required. On the other hand, if Drill were ever to support the "classic"
 plan-time schema resolution, then much of this work could be done at plan
 time rather than (redundantly) at runtime. The main change would be to do
 the work abstractly, working with column and row descriptions, rather than
 concretely with vectors as is done here. Then, that abstract description
 would feed directly into these mechanisms with the "final answer" about
 projection, batch layout, and so on. The parts of this mechanism that
 create and populate vectors would remain.</div>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/framework/package-summary.html">Prev&nbsp;Package</a></li>
<li><a href="../../../../../../../../org/apache/drill/exec/physical/impl/scan/project/projSet/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../../../../index.html?org/apache/drill/exec/physical/impl/scan/project/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2019 <a href="https://www.apache.org/">The Apache Software Foundation</a>. All rights reserved.</small></p>
</body>
</html>
